{"version":3,"file":"main.js","mappings":"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","sources":["webpack://gaussian-splatting-web/./node_modules/webgpu-radix-sort/dist/umd/radix-sort-umd.js","webpack://gaussian-splatting-web/webpack/bootstrap","webpack://gaussian-splatting-web/./src/mylib.ts","webpack://gaussian-splatting-web/./src/packing.ts","webpack://gaussian-splatting-web/./src/ply.ts","webpack://gaussian-splatting-web/./node_modules/wgpu-matrix/dist/2.x/wgpu-matrix.module.js","webpack://gaussian-splatting-web/./src/camera.ts","webpack://gaussian-splatting-web/./src/gpu_context.ts","webpack://gaussian-splatting-web/./src/simple_render.ts","webpack://gaussian-splatting-web/./src/post_process_render.ts","webpack://gaussian-splatting-web/./src/renderer.ts","webpack://gaussian-splatting-web/./src/shaders.ts","webpack://gaussian-splatting-web/./src/index.ts"],"sourcesContent":["(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.RadixSort = {}));\n})(this, (function (exports) { 'use strict';\n\n  function _arrayLikeToArray(r, a) {\n    (null == a || a > r.length) && (a = r.length);\n    for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];\n    return n;\n  }\n  function _arrayWithoutHoles(r) {\n    if (Array.isArray(r)) return _arrayLikeToArray(r);\n  }\n  function _assertClassBrand(e, t, n) {\n    if (\"function\" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n;\n    throw new TypeError(\"Private element is not present on this object\");\n  }\n  function _checkPrivateRedeclaration(e, t) {\n    if (t.has(e)) throw new TypeError(\"Cannot initialize the same private elements twice on an object\");\n  }\n  function _classCallCheck(a, n) {\n    if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\");\n  }\n  function _classPrivateMethodInitSpec(e, a) {\n    _checkPrivateRedeclaration(e, a), a.add(e);\n  }\n  function _defineProperties(e, r) {\n    for (var t = 0; t < r.length; t++) {\n      var o = r[t];\n      o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o);\n    }\n  }\n  function _createClass(e, r, t) {\n    return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", {\n      writable: !1\n    }), e;\n  }\n  function _defineProperty(e, r, t) {\n    return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n      value: t,\n      enumerable: !0,\n      configurable: !0,\n      writable: !0\n    }) : e[r] = t, e;\n  }\n  function _iterableToArray(r) {\n    if (\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return Array.from(r);\n  }\n  function _nonIterableSpread() {\n    throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n  function ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n      var o = Object.getOwnPropertySymbols(e);\n      r && (o = o.filter(function (r) {\n        return Object.getOwnPropertyDescriptor(e, r).enumerable;\n      })), t.push.apply(t, o);\n    }\n    return t;\n  }\n  function _objectSpread2(e) {\n    for (var r = 1; r < arguments.length; r++) {\n      var t = null != arguments[r] ? arguments[r] : {};\n      r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {\n        _defineProperty(e, r, t[r]);\n      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {\n        Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n      });\n    }\n    return e;\n  }\n  function _toConsumableArray(r) {\n    return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread();\n  }\n  function _toPrimitive(t, r) {\n    if (\"object\" != typeof t || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n      var i = e.call(t, r || \"default\");\n      if (\"object\" != typeof i) return i;\n      throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n  }\n  function _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == typeof i ? i : i + \"\";\n  }\n  function _unsupportedIterableToArray(r, a) {\n    if (r) {\n      if (\"string\" == typeof r) return _arrayLikeToArray(r, a);\n      var t = {}.toString.call(r).slice(8, -1);\n      return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;\n    }\n  }\n\n  var prefixSumSource = /* wgsl */\"\\n\\n@group(0) @binding(0) var<storage, read_write> items: array<u32>;\\n@group(0) @binding(1) var<storage, read_write> blockSums: array<u32>;\\n\\noverride WORKGROUP_SIZE_X: u32;\\noverride WORKGROUP_SIZE_Y: u32;\\noverride THREADS_PER_WORKGROUP: u32;\\noverride ITEMS_PER_WORKGROUP: u32;\\noverride ELEMENT_COUNT: u32;\\n\\nvar<workgroup> temp: array<u32, ITEMS_PER_WORKGROUP*2>;\\n\\n@compute @workgroup_size(WORKGROUP_SIZE_X, WORKGROUP_SIZE_Y, 1)\\nfn reduce_downsweep(\\n    @builtin(workgroup_id) w_id: vec3<u32>,\\n    @builtin(num_workgroups) w_dim: vec3<u32>,\\n    @builtin(local_invocation_index) TID: u32, // Local thread ID\\n) {\\n    let WORKGROUP_ID = w_id.x + w_id.y * w_dim.x;\\n    let WID = WORKGROUP_ID * THREADS_PER_WORKGROUP;\\n    let GID = WID + TID; // Global thread ID\\n    \\n    let ELM_TID = TID * 2; // Element pair local ID\\n    let ELM_GID = GID * 2; // Element pair global ID\\n    \\n    // Load input to shared memory\\n    temp[ELM_TID]     = select(items[ELM_GID], 0, ELM_GID >= ELEMENT_COUNT);\\n    temp[ELM_TID + 1] = select(items[ELM_GID + 1], 0, ELM_GID + 1 >= ELEMENT_COUNT);\\n\\n    var offset: u32 = 1;\\n\\n    // Up-sweep (reduce) phase\\n    for (var d: u32 = ITEMS_PER_WORKGROUP >> 1; d > 0; d >>= 1) {\\n        workgroupBarrier();\\n\\n        if (TID < d) {\\n            var ai: u32 = offset * (ELM_TID + 1) - 1;\\n            var bi: u32 = offset * (ELM_TID + 2) - 1;\\n            temp[bi] += temp[ai];\\n        }\\n\\n        offset *= 2;\\n    }\\n\\n    // Save workgroup sum and clear last element\\n    if (TID == 0) {\\n        let last_offset = ITEMS_PER_WORKGROUP - 1;\\n\\n        blockSums[WORKGROUP_ID] = temp[last_offset];\\n        temp[last_offset] = 0;\\n    }\\n\\n    // Down-sweep phase\\n    for (var d: u32 = 1; d < ITEMS_PER_WORKGROUP; d *= 2) {\\n        offset >>= 1;\\n        workgroupBarrier();\\n\\n        if (TID < d) {\\n            var ai: u32 = offset * (ELM_TID + 1) - 1;\\n            var bi: u32 = offset * (ELM_TID + 2) - 1;\\n\\n            let t: u32 = temp[ai];\\n            temp[ai] = temp[bi];\\n            temp[bi] += t;\\n        }\\n    }\\n    workgroupBarrier();\\n\\n    // Copy result from shared memory to global memory\\n    if (ELM_GID >= ELEMENT_COUNT) {\\n        return;\\n    }\\n    items[ELM_GID] = temp[ELM_TID];\\n\\n    if (ELM_GID + 1 >= ELEMENT_COUNT) {\\n        return;\\n    }\\n    items[ELM_GID + 1] = temp[ELM_TID + 1];\\n}\\n\\n@compute @workgroup_size(WORKGROUP_SIZE_X, WORKGROUP_SIZE_Y, 1)\\nfn add_block_sums(\\n    @builtin(workgroup_id) w_id: vec3<u32>,\\n    @builtin(num_workgroups) w_dim: vec3<u32>,\\n    @builtin(local_invocation_index) TID: u32, // Local thread ID\\n) {\\n    let WORKGROUP_ID = w_id.x + w_id.y * w_dim.x;\\n    let WID = WORKGROUP_ID * THREADS_PER_WORKGROUP;\\n    let GID = WID + TID; // Global thread ID\\n\\n    let ELM_ID = GID * 2;\\n\\n    if (ELM_ID >= ELEMENT_COUNT) {\\n        return;\\n    }\\n\\n    let blockSum = blockSums[WORKGROUP_ID];\\n\\n    items[ELM_ID] += blockSum;\\n\\n    if (ELM_ID + 1 >= ELEMENT_COUNT) {\\n        return;\\n    }\\n\\n    items[ELM_ID + 1] += blockSum;\\n}\";\n\n  /**\r\n   * Prefix sum with optimization to avoid bank conflicts\r\n   * \r\n   * (see Implementation section in README for details)\r\n   */\n  var prefixSumNoBankConflictSource = /* wgsl */\"\\n\\n@group(0) @binding(0) var<storage, read_write> items: array<u32>;\\n@group(0) @binding(1) var<storage, read_write> blockSums: array<u32>;\\n\\noverride WORKGROUP_SIZE_X: u32;\\noverride WORKGROUP_SIZE_Y: u32;\\noverride THREADS_PER_WORKGROUP: u32;\\noverride ITEMS_PER_WORKGROUP: u32;\\noverride ELEMENT_COUNT: u32;\\n\\nconst NUM_BANKS: u32 = 32;\\nconst LOG_NUM_BANKS: u32 = 5;\\n\\nfn get_offset(offset: u32) -> u32 {\\n    // return offset >> LOG_NUM_BANKS; // Conflict-free\\n    return (offset >> NUM_BANKS) + (offset >> (2 * LOG_NUM_BANKS)); // Zero bank conflict\\n}\\n\\nvar<workgroup> temp: array<u32, ITEMS_PER_WORKGROUP*2>;\\n\\n@compute @workgroup_size(WORKGROUP_SIZE_X, WORKGROUP_SIZE_Y, 1)\\nfn reduce_downsweep(\\n    @builtin(workgroup_id) w_id: vec3<u32>,\\n    @builtin(num_workgroups) w_dim: vec3<u32>,\\n    @builtin(local_invocation_index) TID: u32, // Local thread ID\\n) {\\n    let WORKGROUP_ID = w_id.x + w_id.y * w_dim.x;\\n    let WID = WORKGROUP_ID * THREADS_PER_WORKGROUP;\\n    let GID = WID + TID; // Global thread ID\\n    \\n    let ELM_TID = TID * 2; // Element pair local ID\\n    let ELM_GID = GID * 2; // Element pair global ID\\n    \\n    // Load input to shared memory\\n    let ai: u32 = TID;\\n    let bi: u32 = TID + (ITEMS_PER_WORKGROUP >> 1);\\n    let s_ai = ai + get_offset(ai);\\n    let s_bi = bi + get_offset(bi);\\n    let g_ai = ai + WID * 2;\\n    let g_bi = bi + WID * 2;\\n    temp[s_ai] = select(items[g_ai], 0, g_ai >= ELEMENT_COUNT);\\n    temp[s_bi] = select(items[g_bi], 0, g_bi >= ELEMENT_COUNT);\\n\\n    var offset: u32 = 1;\\n\\n    // Up-sweep (reduce) phase\\n    for (var d: u32 = ITEMS_PER_WORKGROUP >> 1; d > 0; d >>= 1) {\\n        workgroupBarrier();\\n\\n        if (TID < d) {\\n            var ai: u32 = offset * (ELM_TID + 1) - 1;\\n            var bi: u32 = offset * (ELM_TID + 2) - 1;\\n            ai += get_offset(ai);\\n            bi += get_offset(bi);\\n            temp[bi] += temp[ai];\\n        }\\n\\n        offset *= 2;\\n    }\\n\\n    // Save workgroup sum and clear last element\\n    if (TID == 0) {\\n        var last_offset = ITEMS_PER_WORKGROUP - 1;\\n        last_offset += get_offset(last_offset);\\n\\n        blockSums[WORKGROUP_ID] = temp[last_offset];\\n        temp[last_offset] = 0;\\n    }\\n\\n    // Down-sweep phase\\n    for (var d: u32 = 1; d < ITEMS_PER_WORKGROUP; d *= 2) {\\n        offset >>= 1;\\n        workgroupBarrier();\\n\\n        if (TID < d) {\\n            var ai: u32 = offset * (ELM_TID + 1) - 1;\\n            var bi: u32 = offset * (ELM_TID + 2) - 1;\\n            ai += get_offset(ai);\\n            bi += get_offset(bi);\\n\\n            let t: u32 = temp[ai];\\n            temp[ai] = temp[bi];\\n            temp[bi] += t;\\n        }\\n    }\\n    workgroupBarrier();\\n\\n    // Copy result from shared memory to global memory\\n    if (g_ai < ELEMENT_COUNT) {\\n        items[g_ai] = temp[s_ai];\\n    }\\n    if (g_bi < ELEMENT_COUNT) {\\n        items[g_bi] = temp[s_bi];\\n    }\\n}\\n\\n@compute @workgroup_size(WORKGROUP_SIZE_X, WORKGROUP_SIZE_Y, 1)\\nfn add_block_sums(\\n    @builtin(workgroup_id) w_id: vec3<u32>,\\n    @builtin(num_workgroups) w_dim: vec3<u32>,\\n    @builtin(local_invocation_index) TID: u32, // Local thread ID\\n) {\\n    let WORKGROUP_ID = w_id.x + w_id.y * w_dim.x;\\n    let WID = WORKGROUP_ID * THREADS_PER_WORKGROUP;\\n    let GID = WID + TID; // Global thread ID\\n\\n    let ELM_ID = GID * 2;\\n\\n    if (ELM_ID >= ELEMENT_COUNT) {\\n        return;\\n    }\\n\\n    let blockSum = blockSums[WORKGROUP_ID];\\n\\n    items[ELM_ID] += blockSum;\\n\\n    if (ELM_ID + 1 >= ELEMENT_COUNT) {\\n        return;\\n    }\\n\\n    items[ELM_ID + 1] += blockSum;\\n}\";\n\n  /**\r\n   * Find the best dispatch size x and y dimensions to minimize unused workgroups\r\n   * \r\n   * @param {GPUDevice} device - The GPU device\r\n   * @param {int} workgroup_count - Number of workgroups to dispatch\r\n   * @returns \r\n   */\n  function find_optimal_dispatch_size(device, workgroup_count) {\n    var dispatchSize = {\n      x: workgroup_count,\n      y: 1\n    };\n    if (workgroup_count > device.limits.maxComputeWorkgroupsPerDimension) {\n      var x = Math.floor(Math.sqrt(workgroup_count));\n      var y = Math.ceil(workgroup_count / x);\n      dispatchSize.x = x;\n      dispatchSize.y = y;\n    }\n    return dispatchSize;\n  }\n  function create_buffer_from_data(_ref) {\n    var device = _ref.device,\n      label = _ref.label,\n      data = _ref.data,\n      _ref$usage = _ref.usage,\n      usage = _ref$usage === void 0 ? 0 : _ref$usage;\n    var dispatchSizes = device.createBuffer({\n      label: label,\n      usage: usage,\n      size: data.length * 4,\n      mappedAtCreation: true\n    });\n    var dispatchData = new Uint32Array(dispatchSizes.getMappedRange());\n    dispatchData.set(data);\n    dispatchSizes.unmap();\n    return dispatchSizes;\n  }\n\n  var PrefixSumKernel = /*#__PURE__*/function () {\n    /**\r\n     * Perform a parallel prefix sum on the given data buffer\r\n     * \r\n     * Based on \"Parallel Prefix Sum (Scan) with CUDA\"\r\n     * https://www.eecs.umich.edu/courses/eecs570/hw/parprefix.pdf\r\n     * \r\n     * @param {GPUDevice} device\r\n     * @param {GPUBuffer} data - Buffer containing the data to process\r\n     * @param {number} count - Max number of elements to process\r\n     * @param {object} workgroup_size - Workgroup size in x and y dimensions. (x * y) must be a power of two\r\n     * @param {boolean} avoid_bank_conflicts - Use the \"Avoid bank conflicts\" optimization from the original publication\r\n     */\n    function PrefixSumKernel(_ref) {\n      var device = _ref.device,\n        data = _ref.data,\n        count = _ref.count,\n        _ref$workgroup_size = _ref.workgroup_size,\n        workgroup_size = _ref$workgroup_size === void 0 ? {\n          x: 16,\n          y: 16\n        } : _ref$workgroup_size,\n        _ref$avoid_bank_confl = _ref.avoid_bank_conflicts,\n        avoid_bank_conflicts = _ref$avoid_bank_confl === void 0 ? false : _ref$avoid_bank_confl;\n      _classCallCheck(this, PrefixSumKernel);\n      this.device = device;\n      this.workgroup_size = workgroup_size;\n      this.threads_per_workgroup = workgroup_size.x * workgroup_size.y;\n      this.items_per_workgroup = 2 * this.threads_per_workgroup; // 2 items are processed per thread\n\n      if (Math.log2(this.threads_per_workgroup) % 1 !== 0) throw new Error(\"workgroup_size.x * workgroup_size.y must be a power of two. (current: \".concat(this.threads_per_workgroup, \")\"));\n      this.pipelines = [];\n      this.shaderModule = this.device.createShaderModule({\n        label: 'prefix-sum',\n        code: avoid_bank_conflicts ? prefixSumNoBankConflictSource : prefixSumSource\n      });\n      this.create_pass_recursive(data, count);\n    }\n    return _createClass(PrefixSumKernel, [{\n      key: \"create_pass_recursive\",\n      value: function create_pass_recursive(data, count) {\n        // Find best dispatch x and y dimensions to minimize unused threads\n        var workgroup_count = Math.ceil(count / this.items_per_workgroup);\n        var dispatchSize = find_optimal_dispatch_size(this.device, workgroup_count);\n\n        // Create buffer for block sums        \n        var blockSumBuffer = this.device.createBuffer({\n          label: 'prefix-sum-block-sum',\n          size: workgroup_count * 4,\n          usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST\n        });\n\n        // Create bind group and pipeline layout\n        var bindGroupLayout = this.device.createBindGroupLayout({\n          entries: [{\n            binding: 0,\n            visibility: GPUShaderStage.COMPUTE,\n            buffer: {\n              type: 'storage'\n            }\n          }, {\n            binding: 1,\n            visibility: GPUShaderStage.COMPUTE,\n            buffer: {\n              type: 'storage'\n            }\n          }]\n        });\n        var bindGroup = this.device.createBindGroup({\n          label: 'prefix-sum-bind-group',\n          layout: bindGroupLayout,\n          entries: [{\n            binding: 0,\n            resource: {\n              buffer: data\n            }\n          }, {\n            binding: 1,\n            resource: {\n              buffer: blockSumBuffer\n            }\n          }]\n        });\n        var pipelineLayout = this.device.createPipelineLayout({\n          bindGroupLayouts: [bindGroupLayout]\n        });\n\n        // Per-workgroup (block) prefix sum\n        var scanPipeline = this.device.createComputePipeline({\n          label: 'prefix-sum-scan-pipeline',\n          layout: pipelineLayout,\n          compute: {\n            module: this.shaderModule,\n            entryPoint: 'reduce_downsweep',\n            constants: {\n              'WORKGROUP_SIZE_X': this.workgroup_size.x,\n              'WORKGROUP_SIZE_Y': this.workgroup_size.y,\n              'THREADS_PER_WORKGROUP': this.threads_per_workgroup,\n              'ITEMS_PER_WORKGROUP': this.items_per_workgroup,\n              'ELEMENT_COUNT': count\n            }\n          }\n        });\n        this.pipelines.push({\n          pipeline: scanPipeline,\n          bindGroup: bindGroup,\n          dispatchSize: dispatchSize\n        });\n        if (workgroup_count > 1) {\n          // Prefix sum on block sums\n          this.create_pass_recursive(blockSumBuffer, workgroup_count);\n\n          // Add block sums to local prefix sums\n          var blockSumPipeline = this.device.createComputePipeline({\n            label: 'prefix-sum-add-block-pipeline',\n            layout: pipelineLayout,\n            compute: {\n              module: this.shaderModule,\n              entryPoint: 'add_block_sums',\n              constants: {\n                'WORKGROUP_SIZE_X': this.workgroup_size.x,\n                'WORKGROUP_SIZE_Y': this.workgroup_size.y,\n                'THREADS_PER_WORKGROUP': this.threads_per_workgroup,\n                'ELEMENT_COUNT': count\n              }\n            }\n          });\n          this.pipelines.push({\n            pipeline: blockSumPipeline,\n            bindGroup: bindGroup,\n            dispatchSize: dispatchSize\n          });\n        }\n      }\n    }, {\n      key: \"get_dispatch_chain\",\n      value: function get_dispatch_chain() {\n        return this.pipelines.flatMap(function (p) {\n          return [p.dispatchSize.x, p.dispatchSize.y, 1];\n        });\n      }\n\n      /**\r\n       * Encode the prefix sum pipeline into the current pass.\r\n       * If dispatchSizeBuffer is provided, the dispatch will be indirect (dispatchWorkgroupsIndirect)\r\n       * \r\n       * @param {GPUComputePassEncoder} pass \r\n       * @param {GPUBuffer} dispatchSizeBuffer - (optional) Indirect dispatch buffer\r\n       * @param {int} offset - (optional) Offset in bytes in the dispatch buffer. Default: 0\r\n       */\n    }, {\n      key: \"dispatch\",\n      value: function dispatch(pass, dispatchSizeBuffer) {\n        var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n        for (var i = 0; i < this.pipelines.length; i++) {\n          var _this$pipelines$i = this.pipelines[i],\n            pipeline = _this$pipelines$i.pipeline,\n            bindGroup = _this$pipelines$i.bindGroup,\n            dispatchSize = _this$pipelines$i.dispatchSize;\n          pass.setPipeline(pipeline);\n          pass.setBindGroup(0, bindGroup);\n          if (dispatchSizeBuffer == null) pass.dispatchWorkgroups(dispatchSize.x, dispatchSize.y, 1);else pass.dispatchWorkgroupsIndirect(dispatchSizeBuffer, offset + i * 3 * 4);\n        }\n      }\n    }]);\n  }();\n\n  var radixSortSource = /* wgsl */\"\\n\\n@group(0) @binding(0) var<storage, read> input: array<u32>;\\n@group(0) @binding(1) var<storage, read_write> local_prefix_sums: array<u32>;\\n@group(0) @binding(2) var<storage, read_write> block_sums: array<u32>;\\n\\noverride WORKGROUP_COUNT: u32;\\noverride THREADS_PER_WORKGROUP: u32;\\noverride WORKGROUP_SIZE_X: u32;\\noverride WORKGROUP_SIZE_Y: u32;\\noverride CURRENT_BIT: u32;\\noverride ELEMENT_COUNT: u32;\\n\\nvar<workgroup> s_prefix_sum: array<u32, 2 * (THREADS_PER_WORKGROUP + 1)>;\\n\\n@compute @workgroup_size(WORKGROUP_SIZE_X, WORKGROUP_SIZE_Y, 1)\\nfn radix_sort(\\n    @builtin(workgroup_id) w_id: vec3<u32>,\\n    @builtin(num_workgroups) w_dim: vec3<u32>,\\n    @builtin(local_invocation_index) TID: u32, // Local thread ID\\n) {\\n    let WORKGROUP_ID = w_id.x + w_id.y * w_dim.x;\\n    let WID = WORKGROUP_ID * THREADS_PER_WORKGROUP;\\n    let GID = WID + TID; // Global thread ID\\n\\n    // Extract 2 bits from the input\\n    let elm = select(input[GID], 0, GID >= ELEMENT_COUNT);\\n    let extract_bits: u32 = (elm >> CURRENT_BIT) & 0x3;\\n\\n    var bit_prefix_sums = array<u32, 4>(0, 0, 0, 0);\\n\\n    // If the workgroup is inactive, prevent block_sums buffer update\\n    var LAST_THREAD: u32 = 0xffffffff; \\n\\n    if (WORKGROUP_ID < WORKGROUP_COUNT) {\\n        // Otherwise store the index of the last active thread in the workgroup\\n        LAST_THREAD = min(THREADS_PER_WORKGROUP, ELEMENT_COUNT - WID) - 1;\\n    }\\n\\n    // Initialize parameters for double-buffering\\n    let TPW = THREADS_PER_WORKGROUP + 1;\\n    var swapOffset: u32 = 0;\\n    var inOffset:  u32 = TID;\\n    var outOffset: u32 = TID + TPW;\\n\\n    // 4-way prefix sum\\n    for (var b: u32 = 0; b < 4; b++) {\\n        // Initialize local prefix with bitmask\\n        let bitmask = select(0u, 1u, extract_bits == b);\\n        s_prefix_sum[inOffset + 1] = bitmask;\\n        workgroupBarrier();\\n\\n        var prefix_sum: u32 = 0;\\n\\n        // Prefix sum\\n        for (var offset: u32 = 1; offset < THREADS_PER_WORKGROUP; offset *= 2) {\\n            if (TID >= offset) {\\n                prefix_sum = s_prefix_sum[inOffset] + s_prefix_sum[inOffset - offset];\\n            } else {\\n                prefix_sum = s_prefix_sum[inOffset];\\n            }\\n\\n            s_prefix_sum[outOffset] = prefix_sum;\\n            \\n            // Swap buffers\\n            outOffset = inOffset;\\n            swapOffset = TPW - swapOffset;\\n            inOffset = TID + swapOffset;\\n            \\n            workgroupBarrier();\\n        }\\n\\n        // Store prefix sum for current bit\\n        bit_prefix_sums[b] = prefix_sum;\\n\\n        if (TID == LAST_THREAD) {\\n            // Store block sum to global memory\\n            let total_sum: u32 = prefix_sum + bitmask;\\n            block_sums[b * WORKGROUP_COUNT + WORKGROUP_ID] = total_sum;\\n        }\\n\\n        // Swap buffers\\n        outOffset = inOffset;\\n        swapOffset = TPW - swapOffset;\\n        inOffset = TID + swapOffset;\\n    }\\n\\n    if (GID < ELEMENT_COUNT) {\\n        // Store local prefix sum to global memory\\n        local_prefix_sums[GID] = bit_prefix_sums[extract_bits];\\n    }\\n}\";\n\n  /**\r\n   * Radix sort with \"local shuffle and coalesced mapping\" optimization\r\n   * \r\n   * (see Implementation section in README for details)\r\n   */\n  var radixSortCoalescedSource = /* wgsl */\"\\n\\n@group(0) @binding(0) var<storage, read_write> input: array<u32>;\\n@group(0) @binding(1) var<storage, read_write> local_prefix_sums: array<u32>;\\n@group(0) @binding(2) var<storage, read_write> block_sums: array<u32>;\\n@group(0) @binding(3) var<storage, read_write> values: array<u32>;\\n\\noverride WORKGROUP_COUNT: u32;\\noverride THREADS_PER_WORKGROUP: u32;\\noverride WORKGROUP_SIZE_X: u32;\\noverride WORKGROUP_SIZE_Y: u32;\\noverride CURRENT_BIT: u32;\\noverride ELEMENT_COUNT: u32;\\n\\nvar<workgroup> s_prefix_sum: array<u32, 2 * (THREADS_PER_WORKGROUP + 1)>;\\nvar<workgroup> s_prefix_sum_scan: array<u32, 4>;\\n\\n@compute @workgroup_size(WORKGROUP_SIZE_X, WORKGROUP_SIZE_Y, 1)\\nfn radix_sort(\\n    @builtin(workgroup_id) w_id: vec3<u32>,\\n    @builtin(num_workgroups) w_dim: vec3<u32>,\\n    @builtin(local_invocation_index) TID: u32, // Local thread ID\\n) {\\n    let WORKGROUP_ID = w_id.x + w_id.y * w_dim.x;\\n    let WID = WORKGROUP_ID * THREADS_PER_WORKGROUP;\\n    let GID = WID + TID; // Global thread ID\\n\\n    // Extract 2 bits from the input\\n    var elm: u32 = 0;\\n    var val: u32 = 0;\\n    if (GID < ELEMENT_COUNT) {\\n        elm = input[GID];\\n        val = values[GID];\\n    }\\n    let extract_bits: u32 = (elm >> CURRENT_BIT) & 0x3;\\n\\n    var bit_prefix_sums = array<u32, 4>(0, 0, 0, 0);\\n\\n    // If the workgroup is inactive, prevent block_sums buffer update\\n    var LAST_THREAD: u32 = 0xffffffff; \\n\\n    if (WORKGROUP_ID < WORKGROUP_COUNT) {\\n        // Otherwise store the index of the last active thread in the workgroup\\n        LAST_THREAD = min(THREADS_PER_WORKGROUP, ELEMENT_COUNT - WID) - 1;\\n    }\\n\\n    // Initialize parameters for double-buffering\\n    let TPW = THREADS_PER_WORKGROUP + 1;\\n    var swapOffset: u32 = 0;\\n    var inOffset:  u32 = TID;\\n    var outOffset: u32 = TID + TPW;\\n\\n    // 4-way prefix sum\\n    for (var b: u32 = 0; b < 4; b++) {\\n        // Initialize local prefix with bitmask\\n        let bitmask = select(0u, 1u, extract_bits == b);\\n        s_prefix_sum[inOffset + 1] = bitmask;\\n        workgroupBarrier();\\n\\n        var prefix_sum: u32 = 0;\\n\\n        // Prefix sum\\n        for (var offset: u32 = 1; offset < THREADS_PER_WORKGROUP; offset *= 2) {\\n            if (TID >= offset) {\\n                prefix_sum = s_prefix_sum[inOffset] + s_prefix_sum[inOffset - offset];\\n            } else {\\n                prefix_sum = s_prefix_sum[inOffset];\\n            }\\n\\n            s_prefix_sum[outOffset] = prefix_sum;\\n\\n            // Swap buffers\\n            outOffset = inOffset;\\n            swapOffset = TPW - swapOffset;\\n            inOffset = TID + swapOffset;\\n            \\n            workgroupBarrier();\\n        }\\n\\n        // Store prefix sum for current bit\\n        bit_prefix_sums[b] = prefix_sum;\\n\\n        if (TID == LAST_THREAD) {\\n            // Store block sum to global memory\\n            let total_sum: u32 = prefix_sum + bitmask;\\n            block_sums[b * WORKGROUP_COUNT + WORKGROUP_ID] = total_sum;\\n        }\\n\\n        // Swap buffers\\n        outOffset = inOffset;\\n        swapOffset = TPW - swapOffset;\\n        inOffset = TID + swapOffset;\\n    }\\n\\n    let prefix_sum = bit_prefix_sums[extract_bits];   \\n\\n    // Scan bit prefix sums\\n    if (TID == LAST_THREAD) {\\n        var sum: u32 = 0;\\n        bit_prefix_sums[extract_bits] += 1;\\n        for (var i: u32 = 0; i < 4; i++) {\\n            s_prefix_sum_scan[i] = sum;\\n            sum += bit_prefix_sums[i];\\n        }\\n    }\\n    workgroupBarrier();\\n\\n    if (GID < ELEMENT_COUNT) {\\n        // Compute new position\\n        let new_pos: u32 = prefix_sum + s_prefix_sum_scan[extract_bits];\\n\\n        // Shuffle elements locally\\n        input[WID + new_pos] = elm;\\n        values[WID + new_pos] = val;\\n        local_prefix_sums[WID + new_pos] = prefix_sum;\\n    }\\n}\";\n\n  var radixSortReorderSource = /* wgsl */\"\\n\\n@group(0) @binding(0) var<storage, read> inputKeys: array<u32>;\\n@group(0) @binding(1) var<storage, read_write> outputKeys: array<u32>;\\n@group(0) @binding(2) var<storage, read> local_prefix_sum: array<u32>;\\n@group(0) @binding(3) var<storage, read> prefix_block_sum: array<u32>;\\n@group(0) @binding(4) var<storage, read> inputValues: array<u32>;\\n@group(0) @binding(5) var<storage, read_write> outputValues: array<u32>;\\n\\noverride WORKGROUP_COUNT: u32;\\noverride THREADS_PER_WORKGROUP: u32;\\noverride WORKGROUP_SIZE_X: u32;\\noverride WORKGROUP_SIZE_Y: u32;\\noverride CURRENT_BIT: u32;\\noverride ELEMENT_COUNT: u32;\\n\\n@compute @workgroup_size(WORKGROUP_SIZE_X, WORKGROUP_SIZE_Y, 1)\\nfn radix_sort_reorder(\\n    @builtin(workgroup_id) w_id: vec3<u32>,\\n    @builtin(num_workgroups) w_dim: vec3<u32>,\\n    @builtin(local_invocation_index) TID: u32, // Local thread ID\\n) { \\n    let WORKGROUP_ID = w_id.x + w_id.y * w_dim.x;\\n    let WID = WORKGROUP_ID * THREADS_PER_WORKGROUP;\\n    let GID = WID + TID; // Global thread ID\\n\\n    if (GID >= ELEMENT_COUNT) {\\n        return;\\n    }\\n\\n    let k = inputKeys[GID];\\n    let v = inputValues[GID];\\n\\n    let local_prefix = local_prefix_sum[GID];\\n\\n    // Calculate new position\\n    let extract_bits = (k >> CURRENT_BIT) & 0x3;\\n    let pid = extract_bits * WORKGROUP_COUNT + WORKGROUP_ID;\\n    let sorted_position = prefix_block_sum[pid] + local_prefix;\\n    \\n    outputKeys[sorted_position] = k;\\n    outputValues[sorted_position] = v;\\n}\";\n\n  var checkSortSource = function checkSortSource() {\n    var isFirstPass = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    var isLastPass = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    var kernelMode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'full';\n    return /* wgsl */\"\\n\\n@group(0) @binding(0) var<storage, read> input: array<u32>;\\n@group(0) @binding(1) var<storage, read_write> output: array<u32>;\\n@group(0) @binding(2) var<storage, read> original: array<u32>;\\n@group(0) @binding(3) var<storage, read_write> is_sorted: u32;\\n\\noverride WORKGROUP_SIZE_X: u32;\\noverride WORKGROUP_SIZE_Y: u32;\\noverride THREADS_PER_WORKGROUP: u32;\\noverride ELEMENT_COUNT: u32;\\noverride START_ELEMENT: u32;\\n\\nvar<workgroup> s_data: array<u32, THREADS_PER_WORKGROUP>;\\n\\n// Reset dispatch buffer and is_sorted flag\\n@compute @workgroup_size(WORKGROUP_SIZE_X, WORKGROUP_SIZE_Y, 1)\\nfn reset(\\n    @builtin(workgroup_id) w_id: vec3<u32>,\\n    @builtin(num_workgroups) w_dim: vec3<u32>,\\n    @builtin(local_invocation_index) TID: u32, // Local thread ID\\n) {\\n    if (TID >= ELEMENT_COUNT) {\\n        return;\\n    }\\n\\n    if (TID == 0) {\\n        is_sorted = 0u;\\n    }\\n\\n    let ELM_ID = TID * 3;\\n\\n    output[ELM_ID] = original[ELM_ID];\\n}\\n\\n@compute @workgroup_size(WORKGROUP_SIZE_X, WORKGROUP_SIZE_Y, 1)\\nfn check_sort(\\n    @builtin(workgroup_id) w_id: vec3<u32>,\\n    @builtin(num_workgroups) w_dim: vec3<u32>,\\n    @builtin(local_invocation_index) TID: u32, // Local thread ID\\n) {\\n    let WORKGROUP_ID = w_id.x + w_id.y * w_dim.x;\\n    let WID = WORKGROUP_ID * THREADS_PER_WORKGROUP + START_ELEMENT;\\n    let GID = TID + WID; // Global thread ID\\n\\n    // Load data into shared memory\\n    \".concat(isFirstPass ? first_pass_load_data : \"s_data[TID] = select(0u, input[GID], GID < ELEMENT_COUNT);\", \"\\n\\n    // Perform parallel reduction\\n    for (var d = 1u; d < THREADS_PER_WORKGROUP; d *= 2u) {      \\n        workgroupBarrier();  \\n        if (TID % (2u * d) == 0u) {\\n            s_data[TID] += s_data[TID + d];\\n        }\\n    }\\n    workgroupBarrier();\\n\\n    // Write reduction result\\n    \").concat(isLastPass ? last_pass(kernelMode) : write_reduction_result, \"\\n}\");\n  };\n  var write_reduction_result = /* wgsl */\"\\n    if (TID == 0) {\\n        output[WORKGROUP_ID] = s_data[0];\\n    }\\n\";\n  var first_pass_load_data = /* wgsl */\"\\n    let LAST_THREAD = min(THREADS_PER_WORKGROUP, ELEMENT_COUNT - WID) - 1;\\n\\n    // Load current element into shared memory\\n    // Also load next element for comparison\\n    let elm = select(0u, input[GID], GID < ELEMENT_COUNT);\\n    let next = select(0u, input[GID + 1], GID < ELEMENT_COUNT-1);\\n    s_data[TID] = elm;\\n    workgroupBarrier();\\n\\n    s_data[TID] = select(0u, 1u, GID < ELEMENT_COUNT-1 && elm > next);\\n\";\n  var last_pass = function last_pass(kernelMode) {\n    return /* wgsl */\"\\n    let fullDispatchLength = arrayLength(&output);\\n    let dispatchIndex = TID * 3;\\n\\n    if (dispatchIndex >= fullDispatchLength) {\\n        return;\\n    }\\n\\n    \".concat(kernelMode == 'full' ? last_pass_full : last_pass_fast, \"\\n\");\n  };\n\n  // If the fast check kernel is sorted and the data isn't already sorted, run the full check\n  var last_pass_fast = /* wgsl */\"\\n    output[dispatchIndex] = select(0, original[dispatchIndex], s_data[0] == 0 && is_sorted == 0u);\\n\";\n\n  // If the full check kernel is sorted, set the flag to 1 and skip radix sort passes\n  var last_pass_full = /* wgsl */\"\\n    if (TID == 0 && s_data[0] == 0) {\\n        is_sorted = 1u;\\n    }\\n\\n    output[dispatchIndex] = select(0, original[dispatchIndex], s_data[0] != 0);\\n\";\n\n  var CheckSortKernel = /*#__PURE__*/function () {\n    /**\r\n     * CheckSortKernel - Performs a parralel reduction to check if an array is sorted.\r\n     * \r\n     * @param {GPUDevice} device\r\n     * @param {GPUBuffer} data - The buffer containing the data to check\r\n     * @param {GPUBuffer} result - The result dispatch size buffer\r\n     * @param {GPUBuffer} original - The original dispatch size buffer\r\n     * @param {GPUBuffer} is_sorted - 1-element buffer to store whether the array is sorted\r\n     * @param {number} count - The number of elements to check\r\n     * @param {number} start - The index to start checking from\r\n     * @param {boolean} mode - The type of check sort kernel ('reset', 'fast', 'full')\r\n     * @param {object} workgroup_size - The workgroup size in x and y dimensions\r\n     */\n    function CheckSortKernel(_ref) {\n      var device = _ref.device,\n        data = _ref.data,\n        result = _ref.result,\n        original = _ref.original,\n        is_sorted = _ref.is_sorted,\n        count = _ref.count,\n        _ref$start = _ref.start,\n        start = _ref$start === void 0 ? 0 : _ref$start,\n        _ref$mode = _ref.mode,\n        mode = _ref$mode === void 0 ? 'full' : _ref$mode,\n        _ref$workgroup_size = _ref.workgroup_size,\n        workgroup_size = _ref$workgroup_size === void 0 ? {\n          x: 16,\n          y: 16\n        } : _ref$workgroup_size;\n      _classCallCheck(this, CheckSortKernel);\n      this.device = device;\n      this.count = count;\n      this.start = start;\n      this.mode = mode;\n      this.workgroup_size = workgroup_size;\n      this.threads_per_workgroup = workgroup_size.x * workgroup_size.y;\n      this.pipelines = [];\n      this.buffers = {\n        data: data,\n        result: result,\n        original: original,\n        is_sorted: is_sorted,\n        outputs: []\n      };\n      this.create_passes_recursive(data, count);\n    }\n\n    // Find the best dispatch size for each pass to minimize unused workgroups\n    return _createClass(CheckSortKernel, [{\n      key: \"create_passes_recursive\",\n      value: function create_passes_recursive(buffer, count) {\n        var passIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n        var workgroup_count = Math.ceil(count / this.threads_per_workgroup);\n        var isFirstPass = passIndex === 0;\n        var isLastPass = workgroup_count <= 1;\n        var label = \"check-sort-\".concat(this.mode, \"-\").concat(passIndex);\n        var outputBuffer = isLastPass ? this.buffers.result : this.device.createBuffer({\n          label: label,\n          size: workgroup_count * 4,\n          usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST\n        });\n        var bindGroupLayout = this.device.createBindGroupLayout({\n          entries: [{\n            binding: 0,\n            visibility: GPUShaderStage.COMPUTE,\n            buffer: {\n              type: 'read-only-storage'\n            }\n          }, {\n            binding: 1,\n            visibility: GPUShaderStage.COMPUTE,\n            buffer: {\n              type: 'storage'\n            }\n          }].concat(_toConsumableArray(isLastPass ? [{\n            binding: 2,\n            visibility: GPUShaderStage.COMPUTE,\n            buffer: {\n              type: 'read-only-storage'\n            }\n          }, {\n            binding: 3,\n            visibility: GPUShaderStage.COMPUTE,\n            buffer: {\n              type: 'storage'\n            }\n          }] : []))\n        });\n        var bindGroup = this.device.createBindGroup({\n          layout: bindGroupLayout,\n          entries: [{\n            binding: 0,\n            resource: {\n              buffer: buffer\n            }\n          }, {\n            binding: 1,\n            resource: {\n              buffer: outputBuffer\n            }\n          }].concat(_toConsumableArray(isLastPass ? [{\n            binding: 2,\n            resource: {\n              buffer: this.buffers.original\n            }\n          }, {\n            binding: 3,\n            resource: {\n              buffer: this.buffers.is_sorted\n            }\n          }] : []))\n        });\n        var pipelineLayout = this.device.createPipelineLayout({\n          bindGroupLayouts: [bindGroupLayout]\n        });\n        var element_count = isFirstPass ? this.start + count : count;\n        var start_element = isFirstPass ? this.start : 0;\n        var checkSortPipeline = this.device.createComputePipeline({\n          layout: pipelineLayout,\n          compute: {\n            module: this.device.createShaderModule({\n              label: label,\n              code: checkSortSource(isFirstPass, isLastPass, this.mode)\n            }),\n            entryPoint: this.mode == 'reset' ? 'reset' : 'check_sort',\n            constants: _objectSpread2({\n              'ELEMENT_COUNT': element_count,\n              'WORKGROUP_SIZE_X': this.workgroup_size.x,\n              'WORKGROUP_SIZE_Y': this.workgroup_size.y\n            }, this.mode != 'reset' && {\n              'THREADS_PER_WORKGROUP': this.threads_per_workgroup,\n              'START_ELEMENT': start_element\n            })\n          }\n        });\n        this.buffers.outputs.push(outputBuffer);\n        this.pipelines.push({\n          pipeline: checkSortPipeline,\n          bindGroup: bindGroup\n        });\n        if (!isLastPass) {\n          this.create_passes_recursive(outputBuffer, workgroup_count, passIndex + 1);\n        }\n      }\n    }, {\n      key: \"dispatch\",\n      value: function dispatch(pass, dispatchSize) {\n        var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n        for (var i = 0; i < this.pipelines.length; i++) {\n          var _this$pipelines$i = this.pipelines[i],\n            pipeline = _this$pipelines$i.pipeline,\n            bindGroup = _this$pipelines$i.bindGroup;\n          var dispatchIndirect = this.mode != 'reset' && (this.mode == 'full' || i < this.pipelines.length - 1);\n          pass.setPipeline(pipeline);\n          pass.setBindGroup(0, bindGroup);\n          if (dispatchIndirect) pass.dispatchWorkgroupsIndirect(dispatchSize, offset + i * 3 * 4);else\n            // Only the reset kernel and the last dispatch of the fast check kernel are constant to (1, 1, 1)\n            pass.dispatchWorkgroups(1, 1, 1);\n        }\n      }\n    }], [{\n      key: \"find_optimal_dispatch_chain\",\n      value: function find_optimal_dispatch_chain(device, item_count, workgroup_size) {\n        var threads_per_workgroup = workgroup_size.x * workgroup_size.y;\n        var sizes = [];\n        do {\n          // Number of workgroups required to process all items\n          var target_workgroup_count = Math.ceil(item_count / threads_per_workgroup);\n\n          // Optimal dispatch size and updated workgroup count\n          var dispatchSize = find_optimal_dispatch_size(device, target_workgroup_count);\n          sizes.push(dispatchSize.x, dispatchSize.y, 1);\n          item_count = target_workgroup_count;\n        } while (item_count > 1);\n        return sizes;\n      }\n    }]);\n  }();\n\n  var _RadixSortKernel_brand = /*#__PURE__*/new WeakSet();\n  var RadixSortKernel = /*#__PURE__*/function () {\n    /**\r\n     * Perform a parallel radix sort on the GPU given a buffer of keys and (optionnaly) values\r\n     * Note: The buffers are sorted in-place.\r\n     * \r\n     * Based on \"Fast 4-way parallel radix sorting on GPUs\"\r\n     * https://www.sci.utah.edu/~csilva/papers/cgf.pdf]\r\n     * \r\n     * @param {GPUDevice} device\r\n     * @param {GPUBuffer} keys - Buffer containing the keys to sort\r\n     * @param {GPUBuffer} values - (optional) Buffer containing the associated values\r\n     * @param {number} count - Number of elements to sort\r\n     * @param {number} bit_count - Number of bits per element (default: 32)\r\n     * @param {object} workgroup_size - Workgroup size in x and y dimensions. (x * y) must be a power of two\r\n     * @param {boolean} check_order - Enable \"order checking\" optimization. Can improve performance if the data needs to be sorted in real-time and doesn't change much. (default: false)\r\n     * @param {boolean} local_shuffle - Enable \"local shuffling\" optimization for the radix sort kernel (default: false)\r\n     * @param {boolean} avoid_bank_conflicts - Enable \"avoiding bank conflicts\" optimization for the prefix sum kernel (default: false)\r\n     */\n    function RadixSortKernel() {\n      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        device = _ref.device,\n        keys = _ref.keys,\n        values = _ref.values,\n        count = _ref.count,\n        _ref$bit_count = _ref.bit_count,\n        bit_count = _ref$bit_count === void 0 ? 32 : _ref$bit_count,\n        _ref$workgroup_size = _ref.workgroup_size,\n        workgroup_size = _ref$workgroup_size === void 0 ? {\n          x: 16,\n          y: 16\n        } : _ref$workgroup_size,\n        _ref$check_order = _ref.check_order,\n        check_order = _ref$check_order === void 0 ? false : _ref$check_order,\n        _ref$local_shuffle = _ref.local_shuffle,\n        local_shuffle = _ref$local_shuffle === void 0 ? false : _ref$local_shuffle,\n        _ref$avoid_bank_confl = _ref.avoid_bank_conflicts,\n        avoid_bank_conflicts = _ref$avoid_bank_confl === void 0 ? false : _ref$avoid_bank_confl;\n      _classCallCheck(this, RadixSortKernel);\n      /**\r\n       * Dispatch workgroups from CPU args\r\n       */\n      _classPrivateMethodInitSpec(this, _RadixSortKernel_brand);\n      if (device == null) throw new Error('No device provided');\n      if (keys == null) throw new Error('No keys buffer provided');\n      if (!Number.isInteger(count) || count <= 0) throw new Error('Invalid count parameter');\n      if (!Number.isInteger(bit_count) || bit_count <= 0 || bit_count > 32) throw new Error(\"Invalid bit_count parameter: \".concat(bit_count));\n      if (!Number.isInteger(workgroup_size.x) || !Number.isInteger(workgroup_size.y)) throw new Error('Invalid workgroup_size parameter');\n      if (bit_count % 4 != 0) throw new Error('bit_count must be a multiple of 4');\n      this.device = device;\n      this.count = count;\n      this.bit_count = bit_count;\n      this.workgroup_size = workgroup_size;\n      this.check_order = check_order;\n      this.local_shuffle = local_shuffle;\n      this.avoid_bank_conflicts = avoid_bank_conflicts;\n      this.threads_per_workgroup = workgroup_size.x * workgroup_size.y;\n      this.workgroup_count = Math.ceil(count / this.threads_per_workgroup);\n      this.prefix_block_workgroup_count = 4 * this.workgroup_count;\n      this.has_values = values != null; // Is the values buffer provided ?\n\n      this.dispatchSize = {}; // Dispatch dimension x and y\n      this.shaderModules = {}; // GPUShaderModules\n      this.kernels = {}; // PrefixSumKernel & CheckSortKernels\n      this.pipelines = []; // List of passes\n      this.buffers = {\n        // GPUBuffers\n        keys: keys,\n        values: values\n      };\n\n      // Create shader modules from wgsl code\n      this.create_shader_modules();\n\n      // Create multi-pass pipelines\n      this.create_pipelines();\n    }\n    return _createClass(RadixSortKernel, [{\n      key: \"create_shader_modules\",\n      value: function create_shader_modules() {\n        // Remove every occurence of \"values\" in the shader code if values buffer is not provided\n        var remove_values = function remove_values(source) {\n          return source.split('\\n').filter(function (line) {\n            return !line.toLowerCase().includes('values');\n          }).join('\\n');\n        };\n        var blockSumSource = this.local_shuffle ? radixSortCoalescedSource : radixSortSource;\n        this.shaderModules = {\n          blockSum: this.device.createShaderModule({\n            label: 'radix-sort-block-sum',\n            code: this.has_values ? blockSumSource : remove_values(blockSumSource)\n          }),\n          reorder: this.device.createShaderModule({\n            label: 'radix-sort-reorder',\n            code: this.has_values ? radixSortReorderSource : remove_values(radixSortReorderSource)\n          })\n        };\n      }\n    }, {\n      key: \"create_pipelines\",\n      value: function create_pipelines() {\n        // Block prefix sum kernel    \n        this.create_prefix_sum_kernel();\n\n        // Indirect dispatch buffers\n        var dispatchData = this.calculate_dispatch_sizes();\n\n        // GPU buffers\n        this.create_buffers(dispatchData);\n\n        // Check sort kernels\n        this.create_check_sort_kernels(dispatchData);\n\n        // Radix sort passes for every 2 bits\n        for (var bit = 0; bit < this.bit_count; bit += 2) {\n          // Swap buffers every pass\n          var even = bit % 4 == 0;\n          var inKeys = even ? this.buffers.keys : this.buffers.tmpKeys;\n          var inValues = even ? this.buffers.values : this.buffers.tmpValues;\n          var outKeys = even ? this.buffers.tmpKeys : this.buffers.keys;\n          var outValues = even ? this.buffers.tmpValues : this.buffers.values;\n\n          // Compute local prefix sums and block sums\n          var blockSumPipeline = this.create_block_sum_pipeline(inKeys, inValues, bit);\n\n          // Reorder keys and values\n          var reorderPipeline = this.create_reorder_pipeline(inKeys, inValues, outKeys, outValues, bit);\n          this.pipelines.push({\n            blockSumPipeline: blockSumPipeline,\n            reorderPipeline: reorderPipeline\n          });\n        }\n      }\n    }, {\n      key: \"create_prefix_sum_kernel\",\n      value: function create_prefix_sum_kernel() {\n        // Prefix Block Sum buffer (4 element per workgroup)\n        var prefixBlockSumBuffer = this.device.createBuffer({\n          label: 'radix-sort-prefix-block-sum',\n          size: this.prefix_block_workgroup_count * 4,\n          usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST\n        });\n\n        // Create block prefix sum kernel\n        var prefixSumKernel = new PrefixSumKernel({\n          device: this.device,\n          data: prefixBlockSumBuffer,\n          count: this.prefix_block_workgroup_count,\n          workgroup_size: this.workgroup_size,\n          avoid_bank_conflicts: this.avoid_bank_conflicts\n        });\n        this.kernels.prefixSum = prefixSumKernel;\n        this.buffers.prefixBlockSum = prefixBlockSumBuffer;\n      }\n    }, {\n      key: \"calculate_dispatch_sizes\",\n      value: function calculate_dispatch_sizes() {\n        // Radix sort dispatch size\n        var dispatchSize = find_optimal_dispatch_size(this.device, this.workgroup_count);\n\n        // Prefix sum dispatch sizes\n        var prefixSumDispatchSize = this.kernels.prefixSum.get_dispatch_chain();\n\n        // Check sort element count (fast/full)\n        var check_sort_fast_count = Math.min(this.count, this.threads_per_workgroup * 4);\n        var check_sort_full_count = this.count - check_sort_fast_count;\n        var start_full = check_sort_fast_count - 1;\n\n        // Check sort dispatch sizes\n        var dispatchSizesFast = CheckSortKernel.find_optimal_dispatch_chain(this.device, check_sort_fast_count, this.workgroup_size);\n        var dispatchSizesFull = CheckSortKernel.find_optimal_dispatch_chain(this.device, check_sort_full_count, this.workgroup_size);\n\n        // Initial dispatch sizes\n        var initialDispatch = [dispatchSize.x, dispatchSize.y, 1].concat(_toConsumableArray(dispatchSizesFast.slice(0, 3)), _toConsumableArray(prefixSumDispatchSize));\n\n        // Dispatch offsets in main buffer\n        this.dispatchOffsets = {\n          radix_sort: 0,\n          check_sort_fast: 3 * 4,\n          prefix_sum: 6 * 4\n        };\n        this.dispatchSize = dispatchSize;\n        this.initialDispatch = initialDispatch;\n        return {\n          initialDispatch: initialDispatch,\n          dispatchSizesFull: dispatchSizesFull,\n          check_sort_fast_count: check_sort_fast_count,\n          check_sort_full_count: check_sort_full_count,\n          start_full: start_full\n        };\n      }\n    }, {\n      key: \"create_buffers\",\n      value: function create_buffers(dispatchData) {\n        // Keys and values double buffering\n        var tmpKeysBuffer = this.device.createBuffer({\n          label: 'radix-sort-tmp-keys',\n          size: this.count * 4,\n          usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST\n        });\n        var tmpValuesBuffer = !this.has_values ? null : this.device.createBuffer({\n          label: 'radix-sort-tmp-values',\n          size: this.count * 4,\n          usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST\n        });\n\n        // Local Prefix Sum buffer (1 element per item)\n        var localPrefixSumBuffer = this.device.createBuffer({\n          label: 'radix-sort-local-prefix-sum',\n          size: this.count * 4,\n          usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST\n        });\n        this.buffers.tmpKeys = tmpKeysBuffer;\n        this.buffers.tmpValues = tmpValuesBuffer;\n        this.buffers.localPrefixSum = localPrefixSumBuffer;\n\n        // Only create indirect dispatch buffers when check_order optimization is enabled\n        if (!this.check_order) {\n          return;\n        }\n\n        // Dispatch sizes (radix sort, check sort, prefix sum)\n        var dispatchBuffer = create_buffer_from_data({\n          device: this.device,\n          label: 'radix-sort-dispatch-size',\n          data: dispatchData.initialDispatch,\n          usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.INDIRECT\n        });\n        var originalDispatchBuffer = create_buffer_from_data({\n          device: this.device,\n          label: 'radix-sort-dispatch-size-original',\n          data: dispatchData.initialDispatch,\n          usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC\n        });\n\n        // Dispatch sizes (full sort)\n        var checkSortFullDispatchBuffer = create_buffer_from_data({\n          label: 'check-sort-full-dispatch-size',\n          device: this.device,\n          data: dispatchData.dispatchSizesFull,\n          usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.INDIRECT\n        });\n        var checkSortFullOriginalDispatchBuffer = create_buffer_from_data({\n          label: 'check-sort-full-dispatch-size-original',\n          device: this.device,\n          data: dispatchData.dispatchSizesFull,\n          usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC\n        });\n\n        // Flag to tell if the data is sorted\n        var isSortedBuffer = create_buffer_from_data({\n          label: 'is-sorted',\n          device: this.device,\n          data: new Uint32Array([0]),\n          usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST\n        });\n        this.buffers.dispatchSize = dispatchBuffer;\n        this.buffers.originalDispatchSize = originalDispatchBuffer;\n        this.buffers.checkSortFullDispatchSize = checkSortFullDispatchBuffer;\n        this.buffers.originalCheckSortFullDispatchSize = checkSortFullOriginalDispatchBuffer;\n        this.buffers.isSorted = isSortedBuffer;\n      }\n    }, {\n      key: \"create_check_sort_kernels\",\n      value: function create_check_sort_kernels(checkSortPartitionData) {\n        if (!this.check_order) {\n          return;\n        }\n        var check_sort_fast_count = checkSortPartitionData.check_sort_fast_count,\n          check_sort_full_count = checkSortPartitionData.check_sort_full_count,\n          start_full = checkSortPartitionData.start_full;\n\n        // Create the full pass\n        var checkSortFull = new CheckSortKernel({\n          mode: 'full',\n          device: this.device,\n          data: this.buffers.keys,\n          result: this.buffers.dispatchSize,\n          original: this.buffers.originalDispatchSize,\n          is_sorted: this.buffers.isSorted,\n          count: check_sort_full_count,\n          start: start_full,\n          workgroup_size: this.workgroup_size\n        });\n\n        // Create the fast pass\n        var checkSortFast = new CheckSortKernel({\n          mode: 'fast',\n          device: this.device,\n          data: this.buffers.keys,\n          result: this.buffers.checkSortFullDispatchSize,\n          original: this.buffers.originalCheckSortFullDispatchSize,\n          is_sorted: this.buffers.isSorted,\n          count: check_sort_fast_count,\n          workgroup_size: this.workgroup_size\n        });\n        var initialDispatchElementCount = this.initialDispatch.length / 3;\n        if (checkSortFast.threads_per_workgroup < checkSortFull.pipelines.length || checkSortFull.threads_per_workgroup < initialDispatchElementCount) {\n          console.warn(\"Warning: workgroup size is too small to enable check sort optimization, disabling...\");\n          this.check_order = false;\n          return;\n        }\n\n        // Create the reset pass\n        var checkSortReset = new CheckSortKernel({\n          mode: 'reset',\n          device: this.device,\n          data: this.buffers.keys,\n          original: this.buffers.originalDispatchSize,\n          result: this.buffers.dispatchSize,\n          is_sorted: this.buffers.isSorted,\n          count: initialDispatchElementCount,\n          workgroup_size: find_optimal_dispatch_size(this.device, initialDispatchElementCount)\n        });\n        this.kernels.checkSort = {\n          reset: checkSortReset,\n          fast: checkSortFast,\n          full: checkSortFull\n        };\n      }\n    }, {\n      key: \"create_block_sum_pipeline\",\n      value: function create_block_sum_pipeline(inKeys, inValues, bit) {\n        var bindGroupLayout = this.device.createBindGroupLayout({\n          label: 'radix-sort-block-sum',\n          entries: [{\n            binding: 0,\n            visibility: GPUShaderStage.COMPUTE,\n            buffer: {\n              type: this.local_shuffle ? 'storage' : 'read-only-storage'\n            }\n          }, {\n            binding: 1,\n            visibility: GPUShaderStage.COMPUTE,\n            buffer: {\n              type: 'storage'\n            }\n          }, {\n            binding: 2,\n            visibility: GPUShaderStage.COMPUTE,\n            buffer: {\n              type: 'storage'\n            }\n          }].concat(_toConsumableArray(this.local_shuffle && this.has_values ? [{\n            binding: 3,\n            visibility: GPUShaderStage.COMPUTE,\n            buffer: {\n              type: 'storage'\n            }\n          }] : []))\n        });\n        var bindGroup = this.device.createBindGroup({\n          layout: bindGroupLayout,\n          entries: [{\n            binding: 0,\n            resource: {\n              buffer: inKeys\n            }\n          }, {\n            binding: 1,\n            resource: {\n              buffer: this.buffers.localPrefixSum\n            }\n          }, {\n            binding: 2,\n            resource: {\n              buffer: this.buffers.prefixBlockSum\n            }\n          }].concat(_toConsumableArray(this.local_shuffle && this.has_values ? [{\n            binding: 3,\n            resource: {\n              buffer: inValues\n            }\n          }] : []))\n        });\n        var pipelineLayout = this.device.createPipelineLayout({\n          bindGroupLayouts: [bindGroupLayout]\n        });\n        var blockSumPipeline = this.device.createComputePipeline({\n          label: 'radix-sort-block-sum',\n          layout: pipelineLayout,\n          compute: {\n            module: this.shaderModules.blockSum,\n            entryPoint: 'radix_sort',\n            constants: {\n              'WORKGROUP_SIZE_X': this.workgroup_size.x,\n              'WORKGROUP_SIZE_Y': this.workgroup_size.y,\n              'WORKGROUP_COUNT': this.workgroup_count,\n              'THREADS_PER_WORKGROUP': this.threads_per_workgroup,\n              'ELEMENT_COUNT': this.count,\n              'CURRENT_BIT': bit\n            }\n          }\n        });\n        return {\n          pipeline: blockSumPipeline,\n          bindGroup: bindGroup\n        };\n      }\n    }, {\n      key: \"create_reorder_pipeline\",\n      value: function create_reorder_pipeline(inKeys, inValues, outKeys, outValues, bit) {\n        var bindGroupLayout = this.device.createBindGroupLayout({\n          label: 'radix-sort-reorder',\n          entries: [{\n            binding: 0,\n            visibility: GPUShaderStage.COMPUTE,\n            buffer: {\n              type: 'read-only-storage'\n            }\n          }, {\n            binding: 1,\n            visibility: GPUShaderStage.COMPUTE,\n            buffer: {\n              type: 'storage'\n            }\n          }, {\n            binding: 2,\n            visibility: GPUShaderStage.COMPUTE,\n            buffer: {\n              type: 'read-only-storage'\n            }\n          }, {\n            binding: 3,\n            visibility: GPUShaderStage.COMPUTE,\n            buffer: {\n              type: 'read-only-storage'\n            }\n          }].concat(_toConsumableArray(this.has_values ? [{\n            binding: 4,\n            visibility: GPUShaderStage.COMPUTE,\n            buffer: {\n              type: 'read-only-storage'\n            }\n          }, {\n            binding: 5,\n            visibility: GPUShaderStage.COMPUTE,\n            buffer: {\n              type: 'storage'\n            }\n          }] : []))\n        });\n        var bindGroup = this.device.createBindGroup({\n          layout: bindGroupLayout,\n          entries: [{\n            binding: 0,\n            resource: {\n              buffer: inKeys\n            }\n          }, {\n            binding: 1,\n            resource: {\n              buffer: outKeys\n            }\n          }, {\n            binding: 2,\n            resource: {\n              buffer: this.buffers.localPrefixSum\n            }\n          }, {\n            binding: 3,\n            resource: {\n              buffer: this.buffers.prefixBlockSum\n            }\n          }].concat(_toConsumableArray(this.has_values ? [{\n            binding: 4,\n            resource: {\n              buffer: inValues\n            }\n          }, {\n            binding: 5,\n            resource: {\n              buffer: outValues\n            }\n          }] : []))\n        });\n        var pipelineLayout = this.device.createPipelineLayout({\n          bindGroupLayouts: [bindGroupLayout]\n        });\n        var reorderPipeline = this.device.createComputePipeline({\n          label: 'radix-sort-reorder',\n          layout: pipelineLayout,\n          compute: {\n            module: this.shaderModules.reorder,\n            entryPoint: 'radix_sort_reorder',\n            constants: {\n              'WORKGROUP_SIZE_X': this.workgroup_size.x,\n              'WORKGROUP_SIZE_Y': this.workgroup_size.y,\n              'WORKGROUP_COUNT': this.workgroup_count,\n              'THREADS_PER_WORKGROUP': this.threads_per_workgroup,\n              'ELEMENT_COUNT': this.count,\n              'CURRENT_BIT': bit\n            }\n          }\n        });\n        return {\n          pipeline: reorderPipeline,\n          bindGroup: bindGroup\n        };\n      }\n\n      /**\r\n       * Encode all pipelines into the current pass\r\n       * \r\n       * @param {GPUComputePassEncoder} pass \r\n       */\n    }, {\n      key: \"dispatch\",\n      value: function dispatch(pass) {\n        if (!this.check_order) {\n          _assertClassBrand(_RadixSortKernel_brand, this, _dispatchPipelines).call(this, pass);\n        } else {\n          _assertClassBrand(_RadixSortKernel_brand, this, _dispatchPipelinesIndirect).call(this, pass);\n        }\n      }\n    }]);\n  }();\n  function _dispatchPipelines(pass) {\n    for (var i = 0; i < this.bit_count / 2; i++) {\n      var _this$pipelines$i = this.pipelines[i],\n        blockSumPipeline = _this$pipelines$i.blockSumPipeline,\n        reorderPipeline = _this$pipelines$i.reorderPipeline;\n\n      // Compute local prefix sums and block sums\n      pass.setPipeline(blockSumPipeline.pipeline);\n      pass.setBindGroup(0, blockSumPipeline.bindGroup);\n      pass.dispatchWorkgroups(this.dispatchSize.x, this.dispatchSize.y, 1);\n\n      // Compute block sums prefix sum\n      this.kernels.prefixSum.dispatch(pass);\n\n      // Reorder keys and values\n      pass.setPipeline(reorderPipeline.pipeline);\n      pass.setBindGroup(0, reorderPipeline.bindGroup);\n      pass.dispatchWorkgroups(this.dispatchSize.x, this.dispatchSize.y, 1);\n    }\n  }\n  /**\r\n   * Dispatch workgroups from indirect GPU buffers (used when check_order is enabled)\r\n   */\n  function _dispatchPipelinesIndirect(pass) {\n    // Reset the `dispatch` and `is_sorted` buffers\n    this.kernels.checkSort.reset.dispatch(pass);\n    for (var i = 0; i < this.bit_count / 2; i++) {\n      var _this$pipelines$i2 = this.pipelines[i],\n        blockSumPipeline = _this$pipelines$i2.blockSumPipeline,\n        reorderPipeline = _this$pipelines$i2.reorderPipeline;\n      if (i % 2 == 0) {\n        // Check if the data is sorted every 2 passes\n        this.kernels.checkSort.fast.dispatch(pass, this.buffers.dispatchSize, this.dispatchOffsets.check_sort_fast);\n        this.kernels.checkSort.full.dispatch(pass, this.buffers.checkSortFullDispatchSize);\n      }\n\n      // Compute local prefix sums and block sums\n      pass.setPipeline(blockSumPipeline.pipeline);\n      pass.setBindGroup(0, blockSumPipeline.bindGroup);\n      pass.dispatchWorkgroupsIndirect(this.buffers.dispatchSize, this.dispatchOffsets.radix_sort);\n\n      // Compute block sums prefix sum\n      this.kernels.prefixSum.dispatch(pass, this.buffers.dispatchSize, this.dispatchOffsets.prefix_sum);\n\n      // Reorder keys and values\n      pass.setPipeline(reorderPipeline.pipeline);\n      pass.setBindGroup(0, reorderPipeline.bindGroup);\n      pass.dispatchWorkgroupsIndirect(this.buffers.dispatchSize, this.dispatchOffsets.radix_sort);\n    }\n  }\n\n  exports.PrefixSumKernel = PrefixSumKernel;\n  exports.RadixSortKernel = RadixSortKernel;\n\n}));\n//# sourceMappingURL=radix-sort-umd.js.map\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","export function dot(a, b) {\n    return a[0] * b[0] +\n        a[1] * b[1] +\n        a[2] * b[2] +\n        a[3] * b[3];\n}\nexport function dotF(a, b) {\n    var r = 0;\n    for (var i = 0; i < a.length; i++) {\n        r += a[i] * b[i];\n    }\n    return r;\n}\nexport function saturate(value) {\n    return Math.min(Math.max(value, 0), 1);\n}\n","// This file contains the code for packing and unpacking data into webGPU buffers.\n// WebGPU buffers have rules about datatype layouts, padding etc, so it's much easier\n// to define a code which automatically generates the correct packing methods.\n// It is weakly typed and relies on runtime check, a proper solution would be with\n// extensive generics, but that's outside my comfort zone.\nfunction roundUp(n, multiple) {\n    return Math.ceil(n / multiple) * multiple;\n}\nclass PackingError extends Error {\n    constructor(message) {\n        super(message);\n        this.name = 'PackingError';\n    }\n}\nexport class PackingType {\n    constructor(size, alignment) {\n        this.size = size;\n        this.alignment = alignment;\n    }\n}\nclass i32Type extends PackingType {\n    constructor() { super(4, 4); }\n    pack(offset, value, view) {\n        if (typeof value !== 'number') {\n            throw new PackingError(`Expected number, got ${value}`);\n        }\n        view.setInt32(offset, value, true);\n        return offset + this.size;\n    }\n    unpack(offset, view) {\n        const content = view.getInt32(offset, true);\n        return [offset + this.size, content];\n    }\n}\nclass u32Type extends PackingType {\n    constructor() { super(4, 4); }\n    pack(offset, value, view) {\n        if (typeof value !== 'number') {\n            throw new PackingError(`Expected number, got ${value}`);\n        }\n        view.setUint32(offset, value, true);\n        return offset + this.size;\n    }\n    unpack(offset, view) {\n        const content = view.getUint32(offset, true);\n        return [offset + this.size, content];\n    }\n}\nclass f32Type extends PackingType {\n    constructor() { super(4, 4); }\n    pack(offset, value, view) {\n        if (typeof value !== 'number') {\n            throw new PackingError(`Expected number, got ${value}`);\n        }\n        view.setFloat32(offset, value, true);\n        return offset + this.size;\n    }\n    unpack(offset, view) {\n        const content = view.getFloat32(offset, true);\n        return [offset + this.size, content];\n    }\n}\nexport const i32 = new i32Type();\nexport const u32 = new u32Type();\nexport const f32 = new f32Type();\nclass VectorType extends PackingType {\n    constructor(baseType, nValues, alignment) {\n        super(baseType.size * nValues, alignment);\n        this.baseType = baseType;\n        this.nValues = nValues;\n    }\n    pack(offset, values, view) {\n        if (!Array.isArray(values)) {\n            throw new PackingError(`Expected array, got ${values}`);\n        }\n        if (values.length !== this.nValues) {\n            throw new PackingError(`Expected ${this.nValues} values, got ${values.length}`);\n        }\n        while (offset % this.alignment !== 0) {\n            offset++;\n        }\n        for (let i = 0; i < values.length; i++) {\n            try {\n                offset = this.baseType.pack(offset, values[i], view);\n            }\n            catch (e) {\n                if (e instanceof PackingError) {\n                    throw new PackingError(`Error packing value ${i}: ${e.message}`);\n                }\n                else {\n                    throw e;\n                }\n            }\n            ;\n        }\n        return offset;\n    }\n    unpack(offset, view) {\n        const values = [];\n        while (offset % this.alignment !== 0) {\n            offset++;\n        }\n        for (let i = 0; i < this.nValues; i++) {\n            let [newOffset, value] = this.baseType.unpack(offset, view);\n            offset = newOffset;\n            values.push(value);\n        }\n        return [offset, values];\n    }\n}\nexport class vec2 extends VectorType {\n    constructor(baseType) { super(baseType, 2, 8); }\n}\nexport class vec3 extends VectorType {\n    constructor(baseType) { super(baseType, 3, 16); }\n}\nexport class vec4 extends VectorType {\n    constructor(baseType) { super(baseType, 4, 16); }\n}\nexport class Struct extends PackingType {\n    constructor(members) {\n        const alignment = Math.max(...members.map(([_name, type]) => type.alignment));\n        let offset = 0;\n        for (const [_, type] of members) {\n            while (offset % type.alignment !== 0) {\n                offset++;\n            }\n            offset += type.size;\n        }\n        // SizeOf(S) = roundUp(AlignOf(S), justPastLastMember)\n        // where justPastLastMember = OffsetOfMember(S,N) + SizeOfMember(S,N)\n        const size = roundUp(offset, alignment);\n        super(size, alignment);\n        this.members = members;\n    }\n    pack(offset, values, view) {\n        const expectedKeys = this.members.map(([name, _type]) => name);\n        const actualKeys = Object.keys(values);\n        if (expectedKeys.length !== actualKeys.length) {\n            throw new PackingError(`Expected values for ${expectedKeys}, got ${actualKeys}`);\n        }\n        if (!expectedKeys.every((key) => actualKeys.includes(key))) {\n            throw new PackingError(`Expected values for ${expectedKeys}, got ${actualKeys}`);\n        }\n        const startingOffset = offset;\n        while (offset % this.alignment !== 0) {\n            offset++;\n        }\n        for (const [name, type] of this.members) {\n            const value = values[name];\n            try {\n                offset = type.pack(offset, value, view);\n            }\n            catch (e) {\n                // error packing the thing inside\n                if (e instanceof PackingError) {\n                    throw new PackingError(`Error packing value ${name}: ${e.message}`);\n                }\n                else {\n                    throw e;\n                }\n            }\n        }\n        offset += this.size - (offset - startingOffset);\n        return offset;\n    }\n    unpack(offset, view) {\n        const values = {};\n        const startingOffset = offset;\n        while (offset % this.alignment !== 0) {\n            offset++;\n        }\n        for (const [name, type] of this.members) {\n            let [newOffset, value] = type.unpack(offset, view);\n            offset = newOffset;\n            values[name] = value;\n        }\n        offset += this.size - (offset - startingOffset);\n        return [offset, values];\n    }\n}\nexport class StaticArray extends PackingType {\n    constructor(type, nElements) {\n        const alignment = type.alignment;\n        const size = nElements * roundUp(type.size, type.alignment);\n        super(size, alignment);\n        this.type = type;\n        this.nElements = nElements;\n        this.stride = roundUp(type.size, type.alignment);\n    }\n    pack(offset, values, view) {\n        if (!Array.isArray(values)) {\n            throw new PackingError(`Expected array, got ${values}`);\n        }\n        if (values.length !== this.nElements) {\n            throw new PackingError(`Expected ${this.nElements} values, got ${values.length}`);\n        }\n        while (offset % this.alignment !== 0) {\n            offset++;\n        }\n        for (let i = 0; i < values.length; i++) {\n            try {\n                offset = this.type.pack(offset, values[i], view);\n            }\n            catch (e) {\n                if (e instanceof PackingError) {\n                    throw new PackingError(`Error packing value ${i}: ${e.message}`);\n                }\n                else {\n                    throw e;\n                }\n            }\n            offset += this.stride - this.type.size;\n        }\n        return offset;\n    }\n    unpack(offset, view) {\n        const values = [];\n        while (offset % this.alignment !== 0) {\n            offset++;\n        }\n        for (let i = 0; i < this.nElements; i++) {\n            let [newOffset, value] = this.type.unpack(offset, view);\n            offset = newOffset;\n            values.push(value);\n            offset += this.stride - this.type.size;\n        }\n        return [offset, values];\n    }\n}\nclass MatrixType extends PackingType {\n    constructor(baseType, nRows, nColumns) {\n        var vecType;\n        if (nRows === 2) {\n            vecType = new vec2(baseType);\n        }\n        else if (nRows === 3) {\n            vecType = new vec3(baseType);\n        }\n        else if (nRows === 4) {\n            vecType = new vec4(baseType);\n        }\n        else {\n            throw new Error(`Invalid number of rows: ${nRows}`);\n        }\n        const arrayType = new StaticArray(vecType, nColumns);\n        super(arrayType.size, vecType.alignment);\n        this.baseType = baseType;\n        this.nRows = nRows;\n        this.nColumns = nColumns;\n    }\n    pack(offset, values, view) {\n        if (!Array.isArray(values)) {\n            throw new PackingError(`Expected array, got ${values}`);\n        }\n        if (values.length !== this.nColumns) {\n            throw new PackingError(`Expected ${this.nColumns} columns, got ${values.length}`);\n        }\n        while (offset % this.alignment !== 0) {\n            offset++;\n        }\n        const startOffset = offset;\n        for (let i = 0; i < values.length; i++) {\n            if (!Array.isArray(values[i])) {\n                throw new PackingError(`Expected array, got ${values[i]}`);\n            }\n            for (let j = 0; j < values[i].length; j++) {\n                try {\n                    offset = this.baseType.pack(offset, values[i][j], view);\n                }\n                catch (e) {\n                    if (e instanceof PackingError) {\n                        throw new PackingError(`Error packing value ${i},${j}: ${e.message}`);\n                    }\n                    else {\n                        throw e;\n                    }\n                }\n            }\n        }\n        offset = startOffset + this.size;\n        return offset;\n    }\n    unpack(offset, view) {\n        while (offset % this.alignment !== 0) {\n            offset++;\n        }\n        const startOffset = offset;\n        const outerValues = [];\n        for (let i = 0; i < this.nColumns; i++) {\n            const innerValues = [];\n            for (let j = 0; j < this.nRows; j++) {\n                let [newOffset, value] = this.baseType.unpack(offset, view);\n                offset = newOffset;\n                innerValues.push(value);\n            }\n            outerValues.push(innerValues);\n        }\n        offset += this.size - (offset - startOffset);\n        return [offset, outerValues];\n    }\n}\nexport class mat4x4 extends MatrixType {\n    constructor(baseType) { super(baseType, 4, 4); }\n}\n","import { dotF, saturate } from \"./mylib\";\nimport { StaticArray, Struct, vec3, vec4, f32 } from \"./packing\";\nexport function loadFileAsArrayBuffer(file) {\n    /* loads a file as an ArrayBuffer (i.e. a binary blob) */\n    return new Promise((resolve, reject) => {\n        const reader = new FileReader();\n        reader.onload = (event) => {\n            if (!event.target || !event.target.result) {\n                reject('Failed to load file');\n                return;\n            }\n            if (typeof event.target.result === 'string') {\n                reject('Got a text file instead of a binary one');\n                return;\n            }\n            resolve(event.target.result);\n        };\n        reader.onerror = (event) => {\n            if (!event.target) {\n                reject('Failed to load file');\n                return;\n            }\n            reject(event.target.error);\n        };\n        reader.readAsArrayBuffer(file);\n    });\n}\nexport class PackedGaussians {\n    static decodeHeader(plyArrayBuffer) {\n        /* decodes the .ply file header and returns a tuple of:\n            * - vertexCount: number of vertices in the point cloud\n            * - propertyTypes: a map from property names to their types\n            * - vertexData: a DataView of the vertex data\n        */\n        const decoder = new TextDecoder();\n        let headerOffset = 0;\n        let headerText = '';\n        while (true) {\n            const headerChunk = new Uint8Array(plyArrayBuffer, headerOffset, 50);\n            headerText += decoder.decode(headerChunk);\n            headerOffset += 50;\n            if (headerText.includes('end_header')) {\n                break;\n            }\n        }\n        const headerLines = headerText.split('\\n');\n        let vertexCount = 0;\n        let propertyTypes = {};\n        for (let i = 0; i < headerLines.length; i++) {\n            const line = headerLines[i].trim();\n            if (line.startsWith('element vertex')) {\n                const vertexCountMatch = line.match(/\\d+/);\n                if (vertexCountMatch) {\n                    vertexCount = parseInt(vertexCountMatch[0]);\n                }\n            }\n            else if (line.startsWith('property')) {\n                const propertyMatch = line.match(/(\\w+)\\s+(\\w+)\\s+(\\w+)/);\n                if (propertyMatch) {\n                    const propertyType = propertyMatch[2];\n                    const propertyName = propertyMatch[3];\n                    propertyTypes[propertyName] = propertyType;\n                }\n            }\n            else if (line === 'end_header') {\n                break;\n            }\n        }\n        const vertexByteOffset = headerText.indexOf('end_header') + 'end_header'.length + 1;\n        const vertexData = new DataView(plyArrayBuffer, vertexByteOffset);\n        return [\n            vertexCount,\n            propertyTypes,\n            vertexData,\n        ];\n    }\n    readRawVertex(offset, vertexData, propertyTypes) {\n        /* reads a single vertex from the vertexData DataView and returns a tuple of:\n            * - offset: the offset of the next vertex in the vertexData DataView\n            * - rawVertex: a map from property names to their values\n        */\n        let rawVertex = {};\n        for (const property in propertyTypes) {\n            const propertyType = propertyTypes[property];\n            if (propertyType === 'float') {\n                rawVertex[property] = vertexData.getFloat32(offset, true);\n                offset += Float32Array.BYTES_PER_ELEMENT;\n            }\n            else if (propertyType === 'uchar') {\n                rawVertex[property] = vertexData.getUint8(offset) / 255.0;\n                offset += Uint8Array.BYTES_PER_ELEMENT;\n            }\n        }\n        return [offset, rawVertex];\n    }\n    get nShCoeffs() {\n        /* returns the expected number of spherical harmonics coefficients */\n        if (this.sphericalHarmonicsDegree === 0) {\n            return 1;\n        }\n        else if (this.sphericalHarmonicsDegree === 1) {\n            return 4;\n        }\n        else if (this.sphericalHarmonicsDegree === 2) {\n            return 9;\n        }\n        else if (this.sphericalHarmonicsDegree === 3) {\n            return 16;\n        }\n        else {\n            throw new Error(`Unsupported SH degree: ${this.sphericalHarmonicsDegree}`);\n        }\n    }\n    arrangeVertex(rawVertex, shFeatureOrder) {\n        /* arranges a raw vertex into a vertex that can be packed by the gaussianLayout utility */\n        const shCoeffs = [];\n        for (let i = 0; i < this.nShCoeffs; ++i) {\n            const coeff = [];\n            for (let j = 0; j < 3; ++j) {\n                const coeffName = shFeatureOrder[i * 3 + j];\n                coeff.push(rawVertex[coeffName]);\n            }\n            shCoeffs.push(coeff);\n        }\n        const arrangedVertex = {\n            position: [rawVertex.x, rawVertex.y, rawVertex.z],\n            logScale: [rawVertex.scale_0, rawVertex.scale_1, rawVertex.scale_2],\n            rotQuat: [rawVertex.rot_0, rawVertex.rot_1, rawVertex.rot_2, rawVertex.rot_3],\n            opacityLogit: rawVertex.opacity,\n            shCoeffs: shCoeffs,\n        };\n        return arrangedVertex;\n    }\n    normalizeV4(xyzw) {\n        let len = Math.sqrt(xyzw[0] * xyzw[0] + xyzw[1] * xyzw[1] + xyzw[2] * xyzw[2] + xyzw[3] * xyzw[3]);\n        return [xyzw[0] / len, xyzw[1] / len, xyzw[2] / len, xyzw[3] / len];\n    }\n    NormalizeSwizzleRotation(wxyz) {\n        //return Math.normalize(wxyz).yzwx;\n        var a = this.normalizeV4(wxyz);\n        var result = [a[1], a[2], a[3], a[0]];\n        return result;\n    }\n    PackSmallest3Rotation(q) {\n        var absQ = [Math.abs(q[0]), Math.abs(q[1]), Math.abs(q[2]), Math.abs(q[3])];\n        var index = 0;\n        var maxV = absQ[0];\n        if (absQ[1] > maxV) {\n            index = 1;\n            maxV = absQ[1];\n        }\n        if (absQ[2] > maxV) {\n            index = 2;\n            maxV = absQ[2];\n        }\n        if (absQ[3] > maxV) {\n            index = 3;\n            maxV = absQ[3];\n        }\n        if (index == 0) {\n            q = [q[1], q[2], q[3], q[0]];\n        }\n        ;\n        if (index == 1) {\n            q = [q[0], q[2], q[3], q[1]];\n        }\n        ;\n        if (index == 2) {\n            q = [q[0], q[1], q[3], q[2]];\n        }\n        ;\n        let s = (q[4] >= 0 ? 1 : -1);\n        var q3d = [q[0] * s, q[1] * s, q[2] * s];\n        var three = q3d;\n        three[0] = three[0] * Math.SQRT2 * 0.5 + 0.5;\n        three[1] = three[1] * Math.SQRT2 * 0.5 + 0.5;\n        three[2] = three[2] * Math.SQRT2 * 0.5 + 0.5;\n        return [three[0], three[1], three[2], index / 3.0];\n    }\n    LinearScale(s) {\n        return Math.abs(Math.exp(s));\n    }\n    constructor(arrayBuffer) {\n        // decode the header\n        const [vertexCount, propertyTypes, vertexData] = PackedGaussians.decodeHeader(arrayBuffer);\n        this.numGaussians = vertexCount;\n        // figure out the SH degree from the number of coefficients\n        var nRestCoeffs = 0;\n        for (const propertyName in propertyTypes) {\n            if (propertyName.startsWith('f_rest_')) {\n                nRestCoeffs += 1;\n            }\n        }\n        const nCoeffsPerColor = nRestCoeffs / 3;\n        this.sphericalHarmonicsDegree = Math.sqrt(nCoeffsPerColor + 1) - 1;\n        console.log('Detected degree', this.sphericalHarmonicsDegree, 'with ', nCoeffsPerColor, 'coefficients per color');\n        // figure out the order in which spherical harmonics should be read\n        const shFeatureOrder = [];\n        for (let rgb = 0; rgb < 3; ++rgb) {\n            shFeatureOrder.push(`f_dc_${rgb}`);\n        }\n        for (let i = 0; i < nCoeffsPerColor; ++i) {\n            for (let rgb = 0; rgb < 3; ++rgb) {\n                shFeatureOrder.push(`f_rest_${rgb * nCoeffsPerColor + i}`);\n            }\n        }\n        // define the layout of a single point\n        this.gaussianLayout = new Struct([\n            ['position', new vec3(f32)],\n            ['logScale', new vec3(f32)],\n            ['rotQuat', new vec4(f32)],\n            ['opacityLogit', f32],\n            ['shCoeffs', new StaticArray(new vec3(f32), this.nShCoeffs)],\n        ]);\n        // define the layout of the entire point cloud\n        this.gaussianArrayLayout = new StaticArray(this.gaussianLayout, vertexCount);\n        this.positionsLayout = new vec3(f32);\n        this.positionsArrayLayout = new StaticArray(this.positionsLayout, vertexCount);\n        // pack the points\n        this.gaussiansBuffer = new ArrayBuffer(this.gaussianArrayLayout.size);\n        const gaussianWriteView = new DataView(this.gaussiansBuffer);\n        this.positionsBuffer = new ArrayBuffer(this.positionsArrayLayout.size);\n        const positionsWriteView = new DataView(this.positionsBuffer);\n        var readOffset = 0;\n        var gaussianWriteOffset = 0;\n        var positionWriteOffset = 0;\n        for (let i = 0; i < vertexCount; i++) {\n            const [newReadOffset, rawVertex] = this.readRawVertex(readOffset, vertexData, propertyTypes);\n            readOffset = newReadOffset;\n            //console.log(\"origin\" + rawVertex.rot_0 +\" \" + rawVertex.rot_1 + \" \" + rawVertex.rot_2 + \" \"+rawVertex.rot_3);\n            // Pre-process rotation:\n            var q = [rawVertex.rot_0, rawVertex.rot_1, rawVertex.rot_2, rawVertex.rot_3];\n            var qq = this.NormalizeSwizzleRotation(q);\n            qq = this.PackSmallest3Rotation(qq);\n            qq[0] || (qq[0] = 0);\n            qq[1] || (qq[1] = 0);\n            qq[2] || (qq[2] = 0);\n            qq[3] || (qq[3] = 0);\n            //console.log(qq); // Correct\n            // Decode rotation in \"DecodeRotation\"\n            // Do not try to simplify this code !!!!\n            // For some resone, Vec4 does not work as excepted.\n            let idx = Math.max(Math.round(qq[3] * 3.0));\n            //var pq : Vec4 = [  rawVertex.rot_0 ,   rawVertex.rot_1 ,   rawVertex.rot_2 , 0]\n            //var pq : Vec4 = [  qq[0] ,   qq[1] ,  qq[3] , 0];\n            var a = qq[0] * Math.sqrt(2.0) - (1.0 / Math.sqrt(2.0));\n            var b = qq[1] * Math.sqrt(2.0) - (1.0 / Math.sqrt(2.0));\n            var c = qq[2] * Math.sqrt(2.0) - (1.0 / Math.sqrt(2.0));\n            var d = dotF(new Float32Array([a, b, c]), new Float32Array([a, b, c]));\n            d = Math.sqrt(1.0 - saturate(d));\n            var result_rot = new Float32Array([a, b, c, d]);\n            if (idx == 0) {\n                result_rot = new Float32Array([d, a, b, c]);\n            }\n            if (idx == 1) {\n                result_rot = new Float32Array([a, d, b, c]);\n            }\n            if (idx == 2) {\n                result_rot = new Float32Array([a, b, d, c]);\n            }\n            rawVertex.rot_0 = result_rot[0];\n            rawVertex.rot_1 = result_rot[1];\n            rawVertex.rot_2 = result_rot[2];\n            rawVertex.rot_3 = result_rot[3];\n            //console.log(\"rot :\" +rawVertex.rot_0 +\" \" + rawVertex.rot_1 + \" \" + rawVertex.rot_2 + \" \"+rawVertex.rot_3);\n            // Pre-process scale:        \n            rawVertex.scale_0 = this.LinearScale(rawVertex.scale_0);\n            rawVertex.scale_1 = this.LinearScale(rawVertex.scale_1);\n            rawVertex.scale_2 = this.LinearScale(rawVertex.scale_2);\n            //rawVertex.scale_3 = this.LinearScale(rawVertex.scale_3);\n            //console.log(\"scale \" + rawVertex.scale_0 + \" \" + rawVertex.scale_1 +\" \" + rawVertex.scale_2 );\n            // Original code:\n            gaussianWriteOffset = this.gaussianLayout.pack(gaussianWriteOffset, this.arrangeVertex(rawVertex, shFeatureOrder), gaussianWriteView);\n            positionWriteOffset = this.positionsLayout.pack(positionWriteOffset, [rawVertex.x, rawVertex.y, rawVertex.z], positionsWriteView);\n            //console.log(\"vertex x \" + rawVertex.x + \" y \" +  rawVertex.y + \" z \" + rawVertex.z);\n        }\n    }\n}\n","/* wgpu-matrix@2.9.1, license MIT */\n/*\n * Copyright 2022 Gregg Tavares\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\nlet EPSILON = 0.000001;\n/**\n * Set the value for EPSILON for various checks\n * @param v - Value to use for EPSILON.\n * @returns previous value of EPSILON;\n */\nfunction setEpsilon(v) {\n    const old = EPSILON;\n    EPSILON = v;\n    return old;\n}\n/**\n * Convert degrees to radians\n * @param degrees - Angle in degrees\n * @returns angle converted to radians\n */\nfunction degToRad(degrees) {\n    return degrees * Math.PI / 180;\n}\n/**\n * Convert radians to degrees\n * @param radians - Angle in radians\n * @returns angle converted to degrees\n */\nfunction radToDeg(radians) {\n    return radians * 180 / Math.PI;\n}\n/**\n * Lerps between a and b via t\n * @param a - starting value\n * @param b - ending value\n * @param t - value where 0 = a and 1 = b\n * @returns a + (b - a) * t\n */\nfunction lerp$4(a, b, t) {\n    return a + (b - a) * t;\n}\n/**\n * Compute the opposite of lerp. Given a and b and a value between\n * a and b returns a value between 0 and 1. 0 if a, 1 if b.\n * Note: no clamping is done.\n * @param a - start value\n * @param b - end value\n * @param v - value between a and b\n * @returns (v - a) / (b - a)\n */\nfunction inverseLerp(a, b, v) {\n    const d = b - a;\n    return (Math.abs(b - a) < EPSILON)\n        ? a\n        : (v - a) / d;\n}\n/**\n * Compute the euclidean modulo\n *\n * ```\n * // table for n / 3\n * -5, -4, -3, -2, -1,  0,  1,  2,  3,  4,  5   <- n\n * ------------------------------------\n * -2  -1  -0  -2  -1   0,  1,  2,  0,  1,  2   <- n % 3\n *  1   2   0   1   2   0,  1,  2,  0,  1,  2   <- euclideanModule(n, 3)\n * ```\n *\n * @param n - dividend\n * @param m - divisor\n * @returns the euclidean modulo of n / m\n */\nfunction euclideanModulo(n, m) {\n    return ((n % m) + m) % m;\n}\n\nvar utils = {\n    __proto__: null,\n    get EPSILON () { return EPSILON; },\n    degToRad: degToRad,\n    euclideanModulo: euclideanModulo,\n    inverseLerp: inverseLerp,\n    lerp: lerp$4,\n    radToDeg: radToDeg,\n    setEpsilon: setEpsilon\n};\n\n/*\n * Copyright 2022 Gregg Tavares\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n/**\n *\n * Vec2 math functions.\n *\n * Almost all functions take an optional `dst` argument. If it is not passed in the\n * functions will create a new Vec2. In other words you can do this\n *\n *     const v = vec2.cross(v1, v2);  // Creates a new Vec2 with the cross product of v1 x v2.\n *\n * or\n *\n *     const v = vec2.create();\n *     vec2.cross(v1, v2, v);  // Puts the cross product of v1 x v2 in v\n *\n * The first style is often easier but depending on where it's used it generates garbage where\n * as there is almost never allocation with the second style.\n *\n * It is always safe to pass any vector as the destination. So for example\n *\n *     vec2.cross(v1, v2, v1);  // Puts the cross product of v1 x v2 in v1\n *\n */\nlet VecType$2 = Float32Array;\n/**\n * Sets the type this library creates for a Vec2\n * @param ctor - the constructor for the type. Either `Float32Array`, `Float64Array`, or `Array`\n * @returns previous constructor for Vec2\n */\nfunction setDefaultType$6(ctor) {\n    const oldType = VecType$2;\n    VecType$2 = ctor;\n    return oldType;\n}\n/**\n * Creates a Vec2; may be called with x, y, z to set initial values.\n *\n * Note: Since passing in a raw JavaScript array\n * is valid in all circumstances, if you want to\n * force a JavaScript array into a Vec2's specified type\n * it would be faster to use\n *\n * ```\n * const v = vec2.clone(someJSArray);\n * ```\n *\n * Note: a consequence of the implementation is if your Vec2Type = `Array`\n * instead of `Float32Array` or `Float64Array` then any values you\n * don't pass in will be undefined. Usually this is not an issue since\n * (a) using `Array` is rare and (b) using `vec2.create` is usually used\n * to create a Vec2 to be filled out as in\n *\n * ```\n * const sum = vec2.create();\n * vec2.add(v1, v2, sum);\n * ```\n *\n * @param x - Initial x value.\n * @param y - Initial y value.\n * @returns the created vector\n */\nfunction create$5(x = 0, y = 0) {\n    const dst = new VecType$2(2);\n    if (x !== undefined) {\n        dst[0] = x;\n        if (y !== undefined) {\n            dst[1] = y;\n        }\n    }\n    return dst;\n}\n\n/*\n * Copyright 2022 Gregg Tavares\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n/**\n *\n * Vec3 math functions.\n *\n * Almost all functions take an optional `dst` argument. If it is not passed in the\n * functions will create a new `Vec3`. In other words you can do this\n *\n *     const v = vec3.cross(v1, v2);  // Creates a new Vec3 with the cross product of v1 x v2.\n *\n * or\n *\n *     const v = vec3.create();\n *     vec3.cross(v1, v2, v);  // Puts the cross product of v1 x v2 in v\n *\n * The first style is often easier but depending on where it's used it generates garbage where\n * as there is almost never allocation with the second style.\n *\n * It is always safe to pass any vector as the destination. So for example\n *\n *     vec3.cross(v1, v2, v1);  // Puts the cross product of v1 x v2 in v1\n *\n */\nlet VecType$1 = Float32Array;\n/**\n * Sets the type this library creates for a Vec3\n * @param ctor - the constructor for the type. Either `Float32Array`, `Float64Array`, or `Array`\n * @returns previous constructor for Vec3\n */\nfunction setDefaultType$5(ctor) {\n    const oldType = VecType$1;\n    VecType$1 = ctor;\n    return oldType;\n}\n/**\n * Creates a vec3; may be called with x, y, z to set initial values.\n * @param x - Initial x value.\n * @param y - Initial y value.\n * @param z - Initial z value.\n * @returns the created vector\n */\nfunction create$4(x, y, z) {\n    const dst = new VecType$1(3);\n    if (x !== undefined) {\n        dst[0] = x;\n        if (y !== undefined) {\n            dst[1] = y;\n            if (z !== undefined) {\n                dst[2] = z;\n            }\n        }\n    }\n    return dst;\n}\n\n/*\n * Copyright 2022 Gregg Tavares\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n/**\n * Creates a Vec2; may be called with x, y, z to set initial values. (same as create)\n * @param x - Initial x value.\n * @param y - Initial y value.\n * @returns the created vector\n */\nconst fromValues$3 = create$5;\n/**\n * Sets the values of a Vec2\n * Also see {@link vec2.create} and {@link vec2.copy}\n *\n * @param x first value\n * @param y second value\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector with its elements set.\n */\nfunction set$5(x, y, dst) {\n    dst = dst || new VecType$2(2);\n    dst[0] = x;\n    dst[1] = y;\n    return dst;\n}\n/**\n * Applies Math.ceil to each element of vector\n * @param v - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the ceil of each element of v.\n */\nfunction ceil$2(v, dst) {\n    dst = dst || new VecType$2(2);\n    dst[0] = Math.ceil(v[0]);\n    dst[1] = Math.ceil(v[1]);\n    return dst;\n}\n/**\n * Applies Math.floor to each element of vector\n * @param v - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the floor of each element of v.\n */\nfunction floor$2(v, dst) {\n    dst = dst || new VecType$2(2);\n    dst[0] = Math.floor(v[0]);\n    dst[1] = Math.floor(v[1]);\n    return dst;\n}\n/**\n * Applies Math.round to each element of vector\n * @param v - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the round of each element of v.\n */\nfunction round$2(v, dst) {\n    dst = dst || new VecType$2(2);\n    dst[0] = Math.round(v[0]);\n    dst[1] = Math.round(v[1]);\n    return dst;\n}\n/**\n * Clamp each element of vector between min and max\n * @param v - Operand vector.\n * @param max - Min value, default 0\n * @param min - Max value, default 1\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that the clamped value of each element of v.\n */\nfunction clamp$2(v, min = 0, max = 1, dst) {\n    dst = dst || new VecType$2(2);\n    dst[0] = Math.min(max, Math.max(min, v[0]));\n    dst[1] = Math.min(max, Math.max(min, v[1]));\n    return dst;\n}\n/**\n * Adds two vectors; assumes a and b have the same dimension.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the sum of a and b.\n */\nfunction add$3(a, b, dst) {\n    dst = dst || new VecType$2(2);\n    dst[0] = a[0] + b[0];\n    dst[1] = a[1] + b[1];\n    return dst;\n}\n/**\n * Adds two vectors, scaling the 2nd; assumes a and b have the same dimension.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param scale - Amount to scale b\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the sum of a + b * scale.\n */\nfunction addScaled$2(a, b, scale, dst) {\n    dst = dst || new VecType$2(2);\n    dst[0] = a[0] + b[0] * scale;\n    dst[1] = a[1] + b[1] * scale;\n    return dst;\n}\n/**\n * Returns the angle in radians between two vectors.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @returns The angle in radians between the 2 vectors.\n */\nfunction angle$2(a, b) {\n    const ax = a[0];\n    const ay = a[1];\n    const bx = b[0];\n    const by = b[1];\n    const mag1 = Math.sqrt(ax * ax + ay * ay);\n    const mag2 = Math.sqrt(bx * bx + by * by);\n    const mag = mag1 * mag2;\n    const cosine = mag && dot$3(a, b) / mag;\n    return Math.acos(cosine);\n}\n/**\n * Subtracts two vectors.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the difference of a and b.\n */\nfunction subtract$3(a, b, dst) {\n    dst = dst || new VecType$2(2);\n    dst[0] = a[0] - b[0];\n    dst[1] = a[1] - b[1];\n    return dst;\n}\n/**\n * Subtracts two vectors.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the difference of a and b.\n */\nconst sub$3 = subtract$3;\n/**\n * Check if 2 vectors are approximately equal\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @returns true if vectors are approximately equal\n */\nfunction equalsApproximately$5(a, b) {\n    return Math.abs(a[0] - b[0]) < EPSILON &&\n        Math.abs(a[1] - b[1]) < EPSILON;\n}\n/**\n * Check if 2 vectors are exactly equal\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @returns true if vectors are exactly equal\n */\nfunction equals$5(a, b) {\n    return a[0] === b[0] && a[1] === b[1];\n}\n/**\n * Performs linear interpolation on two vectors.\n * Given vectors a and b and interpolation coefficient t, returns\n * a + t * (b - a).\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param t - Interpolation coefficient.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The linear interpolated result.\n */\nfunction lerp$3(a, b, t, dst) {\n    dst = dst || new VecType$2(2);\n    dst[0] = a[0] + t * (b[0] - a[0]);\n    dst[1] = a[1] + t * (b[1] - a[1]);\n    return dst;\n}\n/**\n * Performs linear interpolation on two vectors.\n * Given vectors a and b and interpolation coefficient vector t, returns\n * a + t * (b - a).\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param t - Interpolation coefficients vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns the linear interpolated result.\n */\nfunction lerpV$2(a, b, t, dst) {\n    dst = dst || new VecType$2(2);\n    dst[0] = a[0] + t[0] * (b[0] - a[0]);\n    dst[1] = a[1] + t[1] * (b[1] - a[1]);\n    return dst;\n}\n/**\n * Return max values of two vectors.\n * Given vectors a and b returns\n * [max(a[0], b[0]), max(a[1], b[1]), max(a[2], b[2])].\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The max components vector.\n */\nfunction max$2(a, b, dst) {\n    dst = dst || new VecType$2(2);\n    dst[0] = Math.max(a[0], b[0]);\n    dst[1] = Math.max(a[1], b[1]);\n    return dst;\n}\n/**\n * Return min values of two vectors.\n * Given vectors a and b returns\n * [min(a[0], b[0]), min(a[1], b[1]), min(a[2], b[2])].\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The min components vector.\n */\nfunction min$2(a, b, dst) {\n    dst = dst || new VecType$2(2);\n    dst[0] = Math.min(a[0], b[0]);\n    dst[1] = Math.min(a[1], b[1]);\n    return dst;\n}\n/**\n * Multiplies a vector by a scalar.\n * @param v - The vector.\n * @param k - The scalar.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The scaled vector.\n */\nfunction mulScalar$3(v, k, dst) {\n    dst = dst || new VecType$2(2);\n    dst[0] = v[0] * k;\n    dst[1] = v[1] * k;\n    return dst;\n}\n/**\n * Multiplies a vector by a scalar. (same as mulScalar)\n * @param v - The vector.\n * @param k - The scalar.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The scaled vector.\n */\nconst scale$5 = mulScalar$3;\n/**\n * Divides a vector by a scalar.\n * @param v - The vector.\n * @param k - The scalar.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The scaled vector.\n */\nfunction divScalar$3(v, k, dst) {\n    dst = dst || new VecType$2(2);\n    dst[0] = v[0] / k;\n    dst[1] = v[1] / k;\n    return dst;\n}\n/**\n * Inverse a vector.\n * @param v - The vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The inverted vector.\n */\nfunction inverse$5(v, dst) {\n    dst = dst || new VecType$2(2);\n    dst[0] = 1 / v[0];\n    dst[1] = 1 / v[1];\n    return dst;\n}\n/**\n * Invert a vector. (same as inverse)\n * @param v - The vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The inverted vector.\n */\nconst invert$4 = inverse$5;\n/**\n * Computes the cross product of two vectors; assumes both vectors have\n * three entries.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The vector of a cross b.\n */\nfunction cross$1(a, b, dst) {\n    dst = dst || new VecType$1(3);\n    const z = a[0] * b[1] - a[1] * b[0];\n    dst[0] = 0;\n    dst[1] = 0;\n    dst[2] = z;\n    return dst;\n}\n/**\n * Computes the dot product of two vectors; assumes both vectors have\n * three entries.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @returns dot product\n */\nfunction dot$3(a, b) {\n    return a[0] * b[0] + a[1] * b[1];\n}\n/**\n * Computes the length of vector\n * @param v - vector.\n * @returns length of vector.\n */\nfunction length$3(v) {\n    const v0 = v[0];\n    const v1 = v[1];\n    return Math.sqrt(v0 * v0 + v1 * v1);\n}\n/**\n * Computes the length of vector (same as length)\n * @param v - vector.\n * @returns length of vector.\n */\nconst len$3 = length$3;\n/**\n * Computes the square of the length of vector\n * @param v - vector.\n * @returns square of the length of vector.\n */\nfunction lengthSq$3(v) {\n    const v0 = v[0];\n    const v1 = v[1];\n    return v0 * v0 + v1 * v1;\n}\n/**\n * Computes the square of the length of vector (same as lengthSq)\n * @param v - vector.\n * @returns square of the length of vector.\n */\nconst lenSq$3 = lengthSq$3;\n/**\n * Computes the distance between 2 points\n * @param a - vector.\n * @param b - vector.\n * @returns distance between a and b\n */\nfunction distance$2(a, b) {\n    const dx = a[0] - b[0];\n    const dy = a[1] - b[1];\n    return Math.sqrt(dx * dx + dy * dy);\n}\n/**\n * Computes the distance between 2 points (same as distance)\n * @param a - vector.\n * @param b - vector.\n * @returns distance between a and b\n */\nconst dist$2 = distance$2;\n/**\n * Computes the square of the distance between 2 points\n * @param a - vector.\n * @param b - vector.\n * @returns square of the distance between a and b\n */\nfunction distanceSq$2(a, b) {\n    const dx = a[0] - b[0];\n    const dy = a[1] - b[1];\n    return dx * dx + dy * dy;\n}\n/**\n * Computes the square of the distance between 2 points (same as distanceSq)\n * @param a - vector.\n * @param b - vector.\n * @returns square of the distance between a and b\n */\nconst distSq$2 = distanceSq$2;\n/**\n * Divides a vector by its Euclidean length and returns the quotient.\n * @param v - The vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The normalized vector.\n */\nfunction normalize$3(v, dst) {\n    dst = dst || new VecType$2(2);\n    const v0 = v[0];\n    const v1 = v[1];\n    const len = Math.sqrt(v0 * v0 + v1 * v1);\n    if (len > 0.00001) {\n        dst[0] = v0 / len;\n        dst[1] = v1 / len;\n    }\n    else {\n        dst[0] = 0;\n        dst[1] = 0;\n    }\n    return dst;\n}\n/**\n * Negates a vector.\n * @param v - The vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns -v.\n */\nfunction negate$4(v, dst) {\n    dst = dst || new VecType$2(2);\n    dst[0] = -v[0];\n    dst[1] = -v[1];\n    return dst;\n}\n/**\n * Copies a vector. (same as {@link vec2.clone})\n * Also see {@link vec2.create} and {@link vec2.set}\n * @param v - The vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A copy of v.\n */\nfunction copy$5(v, dst) {\n    dst = dst || new VecType$2(2);\n    dst[0] = v[0];\n    dst[1] = v[1];\n    return dst;\n}\n/**\n * Clones a vector. (same as {@link vec2.copy})\n * Also see {@link vec2.create} and {@link vec2.set}\n * @param v - The vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A copy of v.\n */\nconst clone$5 = copy$5;\n/**\n * Multiplies a vector by another vector (component-wise); assumes a and\n * b have the same length.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The vector of products of entries of a and b.\n */\nfunction multiply$5(a, b, dst) {\n    dst = dst || new VecType$2(2);\n    dst[0] = a[0] * b[0];\n    dst[1] = a[1] * b[1];\n    return dst;\n}\n/**\n * Multiplies a vector by another vector (component-wise); assumes a and\n * b have the same length. (same as mul)\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The vector of products of entries of a and b.\n */\nconst mul$5 = multiply$5;\n/**\n * Divides a vector by another vector (component-wise); assumes a and\n * b have the same length.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The vector of quotients of entries of a and b.\n */\nfunction divide$2(a, b, dst) {\n    dst = dst || new VecType$2(2);\n    dst[0] = a[0] / b[0];\n    dst[1] = a[1] / b[1];\n    return dst;\n}\n/**\n * Divides a vector by another vector (component-wise); assumes a and\n * b have the same length. (same as divide)\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The vector of quotients of entries of a and b.\n */\nconst div$2 = divide$2;\n/**\n * Creates a random unit vector * scale\n * @param scale - Default 1\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The random vector.\n */\nfunction random$1(scale = 1, dst) {\n    dst = dst || new VecType$2(2);\n    const angle = Math.random() * 2 * Math.PI;\n    dst[0] = Math.cos(angle) * scale;\n    dst[1] = Math.sin(angle) * scale;\n    return dst;\n}\n/**\n * Zero's a vector\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The zeroed vector.\n */\nfunction zero$2(dst) {\n    dst = dst || new VecType$2(2);\n    dst[0] = 0;\n    dst[1] = 0;\n    return dst;\n}\n/**\n * transform Vec2 by 4x4 matrix\n * @param v - the vector\n * @param m - The matrix.\n * @param dst - optional Vec2 to store result. If not passed a new one is created.\n * @returns the transformed vector\n */\nfunction transformMat4$2(v, m, dst) {\n    dst = dst || new VecType$2(2);\n    const x = v[0];\n    const y = v[1];\n    dst[0] = x * m[0] + y * m[4] + m[12];\n    dst[1] = x * m[1] + y * m[5] + m[13];\n    return dst;\n}\n/**\n * Transforms vec4 by 3x3 matrix\n *\n * @param v - the vector\n * @param m - The matrix.\n * @param dst - optional Vec2 to store result. If not passed a new one is created.\n * @returns the transformed vector\n */\nfunction transformMat3$1(v, m, dst) {\n    dst = dst || new VecType$2(2);\n    const x = v[0];\n    const y = v[1];\n    dst[0] = m[0] * x + m[4] * y + m[8];\n    dst[1] = m[1] * x + m[5] * y + m[9];\n    return dst;\n}\n/**\n * Rotate a 2D vector\n *\n * @param a The vec2 point to rotate\n * @param b The origin of the rotation\n * @param rad The angle of rotation in radians\n * @returns the rotated vector\n */\nfunction rotate$2(a, b, rad, dst) {\n    dst = dst || new VecType$2(2);\n    // Translate point to the origin\n    const p0 = a[0] - b[0];\n    const p1 = a[1] - b[1];\n    const sinC = Math.sin(rad);\n    const cosC = Math.cos(rad);\n    //perform rotation and translate to correct position\n    dst[0] = p0 * cosC - p1 * sinC + b[0];\n    dst[1] = p0 * sinC + p1 * cosC + b[1];\n    return dst;\n}\n/**\n * Treat a 2D vector as a direction and set it's length\n *\n * @param a The vec2 to lengthen\n * @param len The length of the resulting vector\n * @returns The lengthened vector\n */\nfunction setLength$2(a, len, dst) {\n    dst = dst || new VecType$2(2);\n    normalize$3(a, dst);\n    return mulScalar$3(dst, len, dst);\n}\n/**\n * Ensure a vector is not longer than a max length\n *\n * @param a The vec2 to limit\n * @param maxLen The longest length of the resulting vector\n * @returns The vector, shortened to maxLen if it's too long\n */\nfunction truncate$2(a, maxLen, dst) {\n    dst = dst || new VecType$2(2);\n    if (length$3(a) > maxLen) {\n        return setLength$2(a, maxLen, dst);\n    }\n    return copy$5(a, dst);\n}\n/**\n * Return the vector exactly between 2 endpoint vectors\n *\n * @param a Endpoint 1\n * @param b Endpoint 2\n * @returns The vector exactly residing between endpoints 1 and 2\n */\nfunction midpoint$2(a, b, dst) {\n    dst = dst || new VecType$2(2);\n    return lerp$3(a, b, 0.5, dst);\n}\n\nvar vec2Impl = {\n    __proto__: null,\n    add: add$3,\n    addScaled: addScaled$2,\n    angle: angle$2,\n    ceil: ceil$2,\n    clamp: clamp$2,\n    clone: clone$5,\n    copy: copy$5,\n    create: create$5,\n    cross: cross$1,\n    dist: dist$2,\n    distSq: distSq$2,\n    distance: distance$2,\n    distanceSq: distanceSq$2,\n    div: div$2,\n    divScalar: divScalar$3,\n    divide: divide$2,\n    dot: dot$3,\n    equals: equals$5,\n    equalsApproximately: equalsApproximately$5,\n    floor: floor$2,\n    fromValues: fromValues$3,\n    inverse: inverse$5,\n    invert: invert$4,\n    len: len$3,\n    lenSq: lenSq$3,\n    length: length$3,\n    lengthSq: lengthSq$3,\n    lerp: lerp$3,\n    lerpV: lerpV$2,\n    max: max$2,\n    midpoint: midpoint$2,\n    min: min$2,\n    mul: mul$5,\n    mulScalar: mulScalar$3,\n    multiply: multiply$5,\n    negate: negate$4,\n    normalize: normalize$3,\n    random: random$1,\n    rotate: rotate$2,\n    round: round$2,\n    scale: scale$5,\n    set: set$5,\n    setDefaultType: setDefaultType$6,\n    setLength: setLength$2,\n    sub: sub$3,\n    subtract: subtract$3,\n    transformMat3: transformMat3$1,\n    transformMat4: transformMat4$2,\n    truncate: truncate$2,\n    zero: zero$2\n};\n\n/*\n * Copyright 2022 Gregg Tavares\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n/**\n * 3x3 Matrix math math functions.\n *\n * Almost all functions take an optional `dst` argument. If it is not passed in the\n * functions will create a new matrix. In other words you can do this\n *\n *     const mat = mat3.translation([1, 2, 3]);  // Creates a new translation matrix\n *\n * or\n *\n *     const mat = mat3.create();\n *     mat3.translation([1, 2, 3], mat);  // Puts translation matrix in mat.\n *\n * The first style is often easier but depending on where it's used it generates garbage where\n * as there is almost never allocation with the second style.\n *\n * It is always save to pass any matrix as the destination. So for example\n *\n *     const mat = mat3.identity();\n *     const trans = mat3.translation([1, 2, 3]);\n *     mat3.multiply(mat, trans, mat);  // Multiplies mat * trans and puts result in mat.\n *\n */\nlet MatType$1 = Float32Array;\n// This mess is because with Mat3 we have 3 unused elements.\n// For Float32Array and Float64Array that's not an issue\n// but for Array it's troublesome\nconst ctorMap = new Map([\n    [Float32Array, () => new Float32Array(12)],\n    [Float64Array, () => new Float64Array(12)],\n    [Array, () => new Array(12).fill(0)],\n]);\nlet newMat3 = ctorMap.get(Float32Array);\n/**\n * Sets the type this library creates for a Mat3\n * @param ctor - the constructor for the type. Either `Float32Array`, `Float64Array`, or `Array`\n * @returns previous constructor for Mat3\n */\nfunction setDefaultType$4(ctor) {\n    const oldType = MatType$1;\n    MatType$1 = ctor;\n    newMat3 = ctorMap.get(ctor);\n    return oldType;\n}\n/**\n * Create a Mat3 from values\n *\n * Note: Since passing in a raw JavaScript array\n * is valid in all circumstances, if you want to\n * force a JavaScript array into a Mat3's specified type\n * it would be faster to use\n *\n * ```\n * const m = mat3.clone(someJSArray);\n * ```\n *\n * Note: a consequence of the implementation is if your Mat3Type = `Array`\n * instead of `Float32Array` or `Float64Array` then any values you\n * don't pass in will be undefined. Usually this is not an issue since\n * (a) using `Array` is rare and (b) using `mat3.create` is usually used\n * to create a Mat3 to be filled out as in\n *\n * ```\n * const m = mat3.create();\n * mat3.perspective(fov, aspect, near, far, m);\n * ```\n *\n * @param v0 - value for element 0\n * @param v1 - value for element 1\n * @param v2 - value for element 2\n * @param v3 - value for element 3\n * @param v4 - value for element 4\n * @param v5 - value for element 5\n * @param v6 - value for element 6\n * @param v7 - value for element 7\n * @param v8 - value for element 8\n * @returns matrix created from values.\n */\nfunction create$3(v0, v1, v2, v3, v4, v5, v6, v7, v8) {\n    const dst = newMat3();\n    // to make the array homogenous\n    dst[3] = 0;\n    dst[7] = 0;\n    dst[11] = 0;\n    if (v0 !== undefined) {\n        dst[0] = v0;\n        if (v1 !== undefined) {\n            dst[1] = v1;\n            if (v2 !== undefined) {\n                dst[2] = v2;\n                if (v3 !== undefined) {\n                    dst[4] = v3;\n                    if (v4 !== undefined) {\n                        dst[5] = v4;\n                        if (v5 !== undefined) {\n                            dst[6] = v5;\n                            if (v6 !== undefined) {\n                                dst[8] = v6;\n                                if (v7 !== undefined) {\n                                    dst[9] = v7;\n                                    if (v8 !== undefined) {\n                                        dst[10] = v8;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return dst;\n}\n/**\n * Sets the values of a Mat3\n * Also see {@link mat3.create} and {@link mat3.copy}\n *\n * @param v0 - value for element 0\n * @param v1 - value for element 1\n * @param v2 - value for element 2\n * @param v3 - value for element 3\n * @param v4 - value for element 4\n * @param v5 - value for element 5\n * @param v6 - value for element 6\n * @param v7 - value for element 7\n * @param v8 - value for element 8\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns Mat3 set from values.\n */\nfunction set$4(v0, v1, v2, v3, v4, v5, v6, v7, v8, dst) {\n    dst = dst || newMat3();\n    dst[0] = v0;\n    dst[1] = v1;\n    dst[2] = v2;\n    dst[3] = 0;\n    dst[4] = v3;\n    dst[5] = v4;\n    dst[6] = v5;\n    dst[7] = 0;\n    dst[8] = v6;\n    dst[9] = v7;\n    dst[10] = v8;\n    dst[11] = 0;\n    return dst;\n}\n/**\n * Creates a Mat3 from the upper left 3x3 part of a Mat4\n * @param m4 - source matrix\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns Mat3 made from m4\n */\nfunction fromMat4(m4, dst) {\n    dst = dst || newMat3();\n    dst[0] = m4[0];\n    dst[1] = m4[1];\n    dst[2] = m4[2];\n    dst[3] = 0;\n    dst[4] = m4[4];\n    dst[5] = m4[5];\n    dst[6] = m4[6];\n    dst[7] = 0;\n    dst[8] = m4[8];\n    dst[9] = m4[9];\n    dst[10] = m4[10];\n    dst[11] = 0;\n    return dst;\n}\n/**\n * Creates a Mat3 rotation matrix from a quaternion\n * @param q - quaternion to create matrix from\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns Mat3 made from q\n */\nfunction fromQuat$1(q, dst) {\n    dst = dst || newMat3();\n    const x = q[0];\n    const y = q[1];\n    const z = q[2];\n    const w = q[3];\n    const x2 = x + x;\n    const y2 = y + y;\n    const z2 = z + z;\n    const xx = x * x2;\n    const yx = y * x2;\n    const yy = y * y2;\n    const zx = z * x2;\n    const zy = z * y2;\n    const zz = z * z2;\n    const wx = w * x2;\n    const wy = w * y2;\n    const wz = w * z2;\n    dst[0] = 1 - yy - zz;\n    dst[1] = yx + wz;\n    dst[2] = zx - wy;\n    dst[3] = 0;\n    dst[4] = yx - wz;\n    dst[5] = 1 - xx - zz;\n    dst[6] = zy + wx;\n    dst[7] = 0;\n    dst[8] = zx + wy;\n    dst[9] = zy - wx;\n    dst[10] = 1 - xx - yy;\n    dst[11] = 0;\n    return dst;\n}\n/**\n * Negates a matrix.\n * @param m - The matrix.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns -m.\n */\nfunction negate$3(m, dst) {\n    dst = dst || newMat3();\n    dst[0] = -m[0];\n    dst[1] = -m[1];\n    dst[2] = -m[2];\n    dst[4] = -m[4];\n    dst[5] = -m[5];\n    dst[6] = -m[6];\n    dst[8] = -m[8];\n    dst[9] = -m[9];\n    dst[10] = -m[10];\n    return dst;\n}\n/**\n * Copies a matrix. (same as {@link mat3.clone})\n * Also see {@link mat3.create} and {@link mat3.set}\n * @param m - The matrix.\n * @param dst - The matrix. If not passed a new one is created.\n * @returns A copy of m.\n */\nfunction copy$4(m, dst) {\n    dst = dst || newMat3();\n    dst[0] = m[0];\n    dst[1] = m[1];\n    dst[2] = m[2];\n    dst[4] = m[4];\n    dst[5] = m[5];\n    dst[6] = m[6];\n    dst[8] = m[8];\n    dst[9] = m[9];\n    dst[10] = m[10];\n    return dst;\n}\n/**\n * Copies a matrix (same as {@link mat3.copy})\n * Also see {@link mat3.create} and {@link mat3.set}\n * @param m - The matrix.\n * @param dst - The matrix. If not passed a new one is created.\n * @returns A copy of m.\n */\nconst clone$4 = copy$4;\n/**\n * Check if 2 matrices are approximately equal\n * @param a Operand matrix.\n * @param b Operand matrix.\n * @returns true if matrices are approximately equal\n */\nfunction equalsApproximately$4(a, b) {\n    return Math.abs(a[0] - b[0]) < EPSILON &&\n        Math.abs(a[1] - b[1]) < EPSILON &&\n        Math.abs(a[2] - b[2]) < EPSILON &&\n        Math.abs(a[4] - b[4]) < EPSILON &&\n        Math.abs(a[5] - b[5]) < EPSILON &&\n        Math.abs(a[6] - b[6]) < EPSILON &&\n        Math.abs(a[8] - b[8]) < EPSILON &&\n        Math.abs(a[9] - b[9]) < EPSILON &&\n        Math.abs(a[10] - b[10]) < EPSILON;\n}\n/**\n * Check if 2 matrices are exactly equal\n * @param a Operand matrix.\n * @param b Operand matrix.\n * @returns true if matrices are exactly equal\n */\nfunction equals$4(a, b) {\n    return a[0] === b[0] &&\n        a[1] === b[1] &&\n        a[2] === b[2] &&\n        a[4] === b[4] &&\n        a[5] === b[5] &&\n        a[6] === b[6] &&\n        a[8] === b[8] &&\n        a[9] === b[9] &&\n        a[10] === b[10];\n}\n/**\n * Creates a 3-by-3 identity matrix.\n *\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns A 3-by-3 identity matrix.\n */\nfunction identity$2(dst) {\n    dst = dst || newMat3();\n    dst[0] = 1;\n    dst[1] = 0;\n    dst[2] = 0;\n    dst[4] = 0;\n    dst[5] = 1;\n    dst[6] = 0;\n    dst[8] = 0;\n    dst[9] = 0;\n    dst[10] = 1;\n    return dst;\n}\n/**\n * Takes the transpose of a matrix.\n * @param m - The matrix.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The transpose of m.\n */\nfunction transpose$1(m, dst) {\n    dst = dst || newMat3();\n    if (dst === m) {\n        let t;\n        // 0 1 2\n        // 4 5 6\n        // 8 9 10\n        t = m[1];\n        m[1] = m[4];\n        m[4] = t;\n        t = m[2];\n        m[2] = m[8];\n        m[8] = t;\n        t = m[6];\n        m[6] = m[9];\n        m[9] = t;\n        return dst;\n    }\n    const m00 = m[0 * 4 + 0];\n    const m01 = m[0 * 4 + 1];\n    const m02 = m[0 * 4 + 2];\n    const m10 = m[1 * 4 + 0];\n    const m11 = m[1 * 4 + 1];\n    const m12 = m[1 * 4 + 2];\n    const m20 = m[2 * 4 + 0];\n    const m21 = m[2 * 4 + 1];\n    const m22 = m[2 * 4 + 2];\n    dst[0] = m00;\n    dst[1] = m10;\n    dst[2] = m20;\n    dst[4] = m01;\n    dst[5] = m11;\n    dst[6] = m21;\n    dst[8] = m02;\n    dst[9] = m12;\n    dst[10] = m22;\n    return dst;\n}\n/**\n * Computes the inverse of a 3-by-3 matrix.\n * @param m - The matrix.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The inverse of m.\n */\nfunction inverse$4(m, dst) {\n    dst = dst || newMat3();\n    const m00 = m[0 * 4 + 0];\n    const m01 = m[0 * 4 + 1];\n    const m02 = m[0 * 4 + 2];\n    const m10 = m[1 * 4 + 0];\n    const m11 = m[1 * 4 + 1];\n    const m12 = m[1 * 4 + 2];\n    const m20 = m[2 * 4 + 0];\n    const m21 = m[2 * 4 + 1];\n    const m22 = m[2 * 4 + 2];\n    const b01 = m22 * m11 - m12 * m21;\n    const b11 = -m22 * m10 + m12 * m20;\n    const b21 = m21 * m10 - m11 * m20;\n    const invDet = 1 / (m00 * b01 + m01 * b11 + m02 * b21);\n    dst[0] = b01 * invDet;\n    dst[1] = (-m22 * m01 + m02 * m21) * invDet;\n    dst[2] = (m12 * m01 - m02 * m11) * invDet;\n    dst[4] = b11 * invDet;\n    dst[5] = (m22 * m00 - m02 * m20) * invDet;\n    dst[6] = (-m12 * m00 + m02 * m10) * invDet;\n    dst[8] = b21 * invDet;\n    dst[9] = (-m21 * m00 + m01 * m20) * invDet;\n    dst[10] = (m11 * m00 - m01 * m10) * invDet;\n    return dst;\n}\n/**\n * Compute the determinant of a matrix\n * @param m - the matrix\n * @returns the determinant\n */\nfunction determinant$1(m) {\n    const m00 = m[0 * 4 + 0];\n    const m01 = m[0 * 4 + 1];\n    const m02 = m[0 * 4 + 2];\n    const m10 = m[1 * 4 + 0];\n    const m11 = m[1 * 4 + 1];\n    const m12 = m[1 * 4 + 2];\n    const m20 = m[2 * 4 + 0];\n    const m21 = m[2 * 4 + 1];\n    const m22 = m[2 * 4 + 2];\n    return m00 * (m11 * m22 - m21 * m12) -\n        m10 * (m01 * m22 - m21 * m02) +\n        m20 * (m01 * m12 - m11 * m02);\n}\n/**\n * Computes the inverse of a 3-by-3 matrix. (same as inverse)\n * @param m - The matrix.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The inverse of m.\n */\nconst invert$3 = inverse$4;\n/**\n * Multiplies two 3-by-3 matrices with a on the left and b on the right\n * @param a - The matrix on the left.\n * @param b - The matrix on the right.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The matrix product of a and b.\n */\nfunction multiply$4(a, b, dst) {\n    dst = dst || newMat3();\n    const a00 = a[0];\n    const a01 = a[1];\n    const a02 = a[2];\n    const a10 = a[4 + 0];\n    const a11 = a[4 + 1];\n    const a12 = a[4 + 2];\n    const a20 = a[8 + 0];\n    const a21 = a[8 + 1];\n    const a22 = a[8 + 2];\n    const b00 = b[0];\n    const b01 = b[1];\n    const b02 = b[2];\n    const b10 = b[4 + 0];\n    const b11 = b[4 + 1];\n    const b12 = b[4 + 2];\n    const b20 = b[8 + 0];\n    const b21 = b[8 + 1];\n    const b22 = b[8 + 2];\n    dst[0] = a00 * b00 + a10 * b01 + a20 * b02;\n    dst[1] = a01 * b00 + a11 * b01 + a21 * b02;\n    dst[2] = a02 * b00 + a12 * b01 + a22 * b02;\n    dst[4] = a00 * b10 + a10 * b11 + a20 * b12;\n    dst[5] = a01 * b10 + a11 * b11 + a21 * b12;\n    dst[6] = a02 * b10 + a12 * b11 + a22 * b12;\n    dst[8] = a00 * b20 + a10 * b21 + a20 * b22;\n    dst[9] = a01 * b20 + a11 * b21 + a21 * b22;\n    dst[10] = a02 * b20 + a12 * b21 + a22 * b22;\n    return dst;\n}\n/**\n * Multiplies two 3-by-3 matrices with a on the left and b on the right (same as multiply)\n * @param a - The matrix on the left.\n * @param b - The matrix on the right.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The matrix product of a and b.\n */\nconst mul$4 = multiply$4;\n/**\n * Sets the translation component of a 3-by-3 matrix to the given\n * vector.\n * @param a - The matrix.\n * @param v - The vector.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The matrix with translation set.\n */\nfunction setTranslation$1(a, v, dst) {\n    dst = dst || identity$2();\n    if (a !== dst) {\n        dst[0] = a[0];\n        dst[1] = a[1];\n        dst[2] = a[2];\n        dst[4] = a[4];\n        dst[5] = a[5];\n        dst[6] = a[6];\n    }\n    dst[8] = v[0];\n    dst[9] = v[1];\n    dst[10] = 1;\n    return dst;\n}\n/**\n * Returns the translation component of a 3-by-3 matrix as a vector with 3\n * entries.\n * @param m - The matrix.\n * @param dst - vector to hold result. If not passed a new one is created.\n * @returns The translation component of m.\n */\nfunction getTranslation$2(m, dst) {\n    dst = dst || create$5();\n    dst[0] = m[8];\n    dst[1] = m[9];\n    return dst;\n}\n/**\n * Returns an axis of a 3x3 matrix as a vector with 2 entries\n * @param m - The matrix.\n * @param axis - The axis 0 = x, 1 = y,\n * @returns The axis component of m.\n */\nfunction getAxis$2(m, axis, dst) {\n    dst = dst || create$5();\n    const off = axis * 4;\n    dst[0] = m[off + 0];\n    dst[1] = m[off + 1];\n    return dst;\n}\n/**\n * Sets an axis of a 3x3 matrix as a vector with 2 entries\n * @param m - The matrix.\n * @param v - the axis vector\n * @param axis - The axis  0 = x, 1 = y;\n * @param dst - The matrix to set. If not passed a new one is created.\n * @returns The matrix with axis set.\n */\nfunction setAxis$1(m, v, axis, dst) {\n    if (dst !== m) {\n        dst = copy$4(m, dst);\n    }\n    const off = axis * 4;\n    dst[off + 0] = v[0];\n    dst[off + 1] = v[1];\n    return dst;\n}\n/**\n * Returns the scaling component of the matrix\n * @param m - The Matrix\n * @param dst - The vector to set. If not passed a new one is created.\n */\nfunction getScaling$2(m, dst) {\n    dst = dst || create$5();\n    const xx = m[0];\n    const xy = m[1];\n    const yx = m[4];\n    const yy = m[5];\n    dst[0] = Math.sqrt(xx * xx + xy * xy);\n    dst[1] = Math.sqrt(yx * yx + yy * yy);\n    return dst;\n}\n/**\n * Creates a 3-by-3 matrix which translates by the given vector v.\n * @param v - The vector by which to translate.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The translation matrix.\n */\nfunction translation$1(v, dst) {\n    dst = dst || newMat3();\n    dst[0] = 1;\n    dst[1] = 0;\n    dst[2] = 0;\n    dst[4] = 0;\n    dst[5] = 1;\n    dst[6] = 0;\n    dst[8] = v[0];\n    dst[9] = v[1];\n    dst[10] = 1;\n    return dst;\n}\n/**\n * Translates the given 3-by-3 matrix by the given vector v.\n * @param m - The matrix.\n * @param v - The vector by which to translate.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The translated matrix.\n */\nfunction translate$1(m, v, dst) {\n    dst = dst || newMat3();\n    const v0 = v[0];\n    const v1 = v[1];\n    const m00 = m[0];\n    const m01 = m[1];\n    const m02 = m[2];\n    const m10 = m[1 * 4 + 0];\n    const m11 = m[1 * 4 + 1];\n    const m12 = m[1 * 4 + 2];\n    const m20 = m[2 * 4 + 0];\n    const m21 = m[2 * 4 + 1];\n    const m22 = m[2 * 4 + 2];\n    if (m !== dst) {\n        dst[0] = m00;\n        dst[1] = m01;\n        dst[2] = m02;\n        dst[4] = m10;\n        dst[5] = m11;\n        dst[6] = m12;\n    }\n    dst[8] = m00 * v0 + m10 * v1 + m20;\n    dst[9] = m01 * v0 + m11 * v1 + m21;\n    dst[10] = m02 * v0 + m12 * v1 + m22;\n    return dst;\n}\n/**\n * Creates a 3-by-3 matrix which rotates  by the given angle.\n * @param angleInRadians - The angle by which to rotate (in radians).\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The rotation matrix.\n */\nfunction rotation$1(angleInRadians, dst) {\n    dst = dst || newMat3();\n    const c = Math.cos(angleInRadians);\n    const s = Math.sin(angleInRadians);\n    dst[0] = c;\n    dst[1] = s;\n    dst[2] = 0;\n    dst[4] = -s;\n    dst[5] = c;\n    dst[6] = 0;\n    dst[8] = 0;\n    dst[9] = 0;\n    dst[10] = 1;\n    return dst;\n}\n/**\n * Rotates the given 3-by-3 matrix  by the given angle.\n * @param m - The matrix.\n * @param angleInRadians - The angle by which to rotate (in radians).\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The rotated matrix.\n */\nfunction rotate$1(m, angleInRadians, dst) {\n    dst = dst || newMat3();\n    const m00 = m[0 * 4 + 0];\n    const m01 = m[0 * 4 + 1];\n    const m02 = m[0 * 4 + 2];\n    const m10 = m[1 * 4 + 0];\n    const m11 = m[1 * 4 + 1];\n    const m12 = m[1 * 4 + 2];\n    const c = Math.cos(angleInRadians);\n    const s = Math.sin(angleInRadians);\n    dst[0] = c * m00 + s * m10;\n    dst[1] = c * m01 + s * m11;\n    dst[2] = c * m02 + s * m12;\n    dst[4] = c * m10 - s * m00;\n    dst[5] = c * m11 - s * m01;\n    dst[6] = c * m12 - s * m02;\n    if (m !== dst) {\n        dst[8] = m[8];\n        dst[9] = m[9];\n        dst[10] = m[10];\n    }\n    return dst;\n}\n/**\n * Creates a 3-by-3 matrix which scales in each dimension by an amount given by\n * the corresponding entry in the given vector; assumes the vector has three\n * entries.\n * @param v - A vector of\n *     2 entries specifying the factor by which to scale in each dimension.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The scaling matrix.\n */\nfunction scaling$1(v, dst) {\n    dst = dst || newMat3();\n    dst[0] = v[0];\n    dst[1] = 0;\n    dst[2] = 0;\n    dst[4] = 0;\n    dst[5] = v[1];\n    dst[6] = 0;\n    dst[8] = 0;\n    dst[9] = 0;\n    dst[10] = 1;\n    return dst;\n}\n/**\n * Scales the given 3-by-3 matrix in each dimension by an amount\n * given by the corresponding entry in the given vector; assumes the vector has\n * three entries.\n * @param m - The matrix to be modified.\n * @param v - A vector of 2 entries specifying the\n *     factor by which to scale in each dimension.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The scaled matrix.\n */\nfunction scale$4(m, v, dst) {\n    dst = dst || newMat3();\n    const v0 = v[0];\n    const v1 = v[1];\n    dst[0] = v0 * m[0 * 4 + 0];\n    dst[1] = v0 * m[0 * 4 + 1];\n    dst[2] = v0 * m[0 * 4 + 2];\n    dst[4] = v1 * m[1 * 4 + 0];\n    dst[5] = v1 * m[1 * 4 + 1];\n    dst[6] = v1 * m[1 * 4 + 2];\n    if (m !== dst) {\n        dst[8] = m[8];\n        dst[9] = m[9];\n        dst[10] = m[10];\n    }\n    return dst;\n}\n/**\n * Creates a 3-by-3 matrix which scales uniformly in each dimension\n * @param s - Amount to scale\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The scaling matrix.\n */\nfunction uniformScaling$1(s, dst) {\n    dst = dst || newMat3();\n    dst[0] = s;\n    dst[1] = 0;\n    dst[2] = 0;\n    dst[4] = 0;\n    dst[5] = s;\n    dst[6] = 0;\n    dst[8] = 0;\n    dst[9] = 0;\n    dst[10] = 1;\n    return dst;\n}\n/**\n * Scales the given 3-by-3 matrix in each dimension by an amount\n * given.\n * @param m - The matrix to be modified.\n * @param s - Amount to scale.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The scaled matrix.\n */\nfunction uniformScale$1(m, s, dst) {\n    dst = dst || newMat3();\n    dst[0] = s * m[0 * 4 + 0];\n    dst[1] = s * m[0 * 4 + 1];\n    dst[2] = s * m[0 * 4 + 2];\n    dst[4] = s * m[1 * 4 + 0];\n    dst[5] = s * m[1 * 4 + 1];\n    dst[6] = s * m[1 * 4 + 2];\n    if (m !== dst) {\n        dst[8] = m[8];\n        dst[9] = m[9];\n        dst[10] = m[10];\n    }\n    return dst;\n}\n\nvar mat3Impl = {\n    __proto__: null,\n    clone: clone$4,\n    copy: copy$4,\n    create: create$3,\n    determinant: determinant$1,\n    equals: equals$4,\n    equalsApproximately: equalsApproximately$4,\n    fromMat4: fromMat4,\n    fromQuat: fromQuat$1,\n    getAxis: getAxis$2,\n    getScaling: getScaling$2,\n    getTranslation: getTranslation$2,\n    identity: identity$2,\n    inverse: inverse$4,\n    invert: invert$3,\n    mul: mul$4,\n    multiply: multiply$4,\n    negate: negate$3,\n    rotate: rotate$1,\n    rotation: rotation$1,\n    scale: scale$4,\n    scaling: scaling$1,\n    set: set$4,\n    setAxis: setAxis$1,\n    setDefaultType: setDefaultType$4,\n    setTranslation: setTranslation$1,\n    translate: translate$1,\n    translation: translation$1,\n    transpose: transpose$1,\n    uniformScale: uniformScale$1,\n    uniformScaling: uniformScaling$1\n};\n\n/*\n * Copyright 2022 Gregg Tavares\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n/**\n * Creates a vec3; may be called with x, y, z to set initial values. (same as create)\n * @param x - Initial x value.\n * @param y - Initial y value.\n * @param z - Initial z value.\n * @returns the created vector\n */\nconst fromValues$2 = create$4;\n/**\n * Sets the values of a Vec3\n * Also see {@link vec3.create} and {@link vec3.copy}\n *\n * @param x first value\n * @param y second value\n * @param z third value\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector with its elements set.\n */\nfunction set$3(x, y, z, dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = x;\n    dst[1] = y;\n    dst[2] = z;\n    return dst;\n}\n/**\n * Applies Math.ceil to each element of vector\n * @param v - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the ceil of each element of v.\n */\nfunction ceil$1(v, dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = Math.ceil(v[0]);\n    dst[1] = Math.ceil(v[1]);\n    dst[2] = Math.ceil(v[2]);\n    return dst;\n}\n/**\n * Applies Math.floor to each element of vector\n * @param v - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the floor of each element of v.\n */\nfunction floor$1(v, dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = Math.floor(v[0]);\n    dst[1] = Math.floor(v[1]);\n    dst[2] = Math.floor(v[2]);\n    return dst;\n}\n/**\n * Applies Math.round to each element of vector\n * @param v - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the round of each element of v.\n */\nfunction round$1(v, dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = Math.round(v[0]);\n    dst[1] = Math.round(v[1]);\n    dst[2] = Math.round(v[2]);\n    return dst;\n}\n/**\n * Clamp each element of vector between min and max\n * @param v - Operand vector.\n * @param max - Min value, default 0\n * @param min - Max value, default 1\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that the clamped value of each element of v.\n */\nfunction clamp$1(v, min = 0, max = 1, dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = Math.min(max, Math.max(min, v[0]));\n    dst[1] = Math.min(max, Math.max(min, v[1]));\n    dst[2] = Math.min(max, Math.max(min, v[2]));\n    return dst;\n}\n/**\n * Adds two vectors; assumes a and b have the same dimension.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the sum of a and b.\n */\nfunction add$2(a, b, dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = a[0] + b[0];\n    dst[1] = a[1] + b[1];\n    dst[2] = a[2] + b[2];\n    return dst;\n}\n/**\n * Adds two vectors, scaling the 2nd; assumes a and b have the same dimension.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param scale - Amount to scale b\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the sum of a + b * scale.\n */\nfunction addScaled$1(a, b, scale, dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = a[0] + b[0] * scale;\n    dst[1] = a[1] + b[1] * scale;\n    dst[2] = a[2] + b[2] * scale;\n    return dst;\n}\n/**\n * Returns the angle in radians between two vectors.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @returns The angle in radians between the 2 vectors.\n */\nfunction angle$1(a, b) {\n    const ax = a[0];\n    const ay = a[1];\n    const az = a[2];\n    const bx = b[0];\n    const by = b[1];\n    const bz = b[2];\n    const mag1 = Math.sqrt(ax * ax + ay * ay + az * az);\n    const mag2 = Math.sqrt(bx * bx + by * by + bz * bz);\n    const mag = mag1 * mag2;\n    const cosine = mag && dot$2(a, b) / mag;\n    return Math.acos(cosine);\n}\n/**\n * Subtracts two vectors.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the difference of a and b.\n */\nfunction subtract$2(a, b, dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = a[0] - b[0];\n    dst[1] = a[1] - b[1];\n    dst[2] = a[2] - b[2];\n    return dst;\n}\n/**\n * Subtracts two vectors.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the difference of a and b.\n */\nconst sub$2 = subtract$2;\n/**\n * Check if 2 vectors are approximately equal\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @returns true if vectors are approximately equal\n */\nfunction equalsApproximately$3(a, b) {\n    return Math.abs(a[0] - b[0]) < EPSILON &&\n        Math.abs(a[1] - b[1]) < EPSILON &&\n        Math.abs(a[2] - b[2]) < EPSILON;\n}\n/**\n * Check if 2 vectors are exactly equal\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @returns true if vectors are exactly equal\n */\nfunction equals$3(a, b) {\n    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];\n}\n/**\n * Performs linear interpolation on two vectors.\n * Given vectors a and b and interpolation coefficient t, returns\n * a + t * (b - a).\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param t - Interpolation coefficient.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The linear interpolated result.\n */\nfunction lerp$2(a, b, t, dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = a[0] + t * (b[0] - a[0]);\n    dst[1] = a[1] + t * (b[1] - a[1]);\n    dst[2] = a[2] + t * (b[2] - a[2]);\n    return dst;\n}\n/**\n * Performs linear interpolation on two vectors.\n * Given vectors a and b and interpolation coefficient vector t, returns\n * a + t * (b - a).\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param t - Interpolation coefficients vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns the linear interpolated result.\n */\nfunction lerpV$1(a, b, t, dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = a[0] + t[0] * (b[0] - a[0]);\n    dst[1] = a[1] + t[1] * (b[1] - a[1]);\n    dst[2] = a[2] + t[2] * (b[2] - a[2]);\n    return dst;\n}\n/**\n * Return max values of two vectors.\n * Given vectors a and b returns\n * [max(a[0], b[0]), max(a[1], b[1]), max(a[2], b[2])].\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The max components vector.\n */\nfunction max$1(a, b, dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = Math.max(a[0], b[0]);\n    dst[1] = Math.max(a[1], b[1]);\n    dst[2] = Math.max(a[2], b[2]);\n    return dst;\n}\n/**\n * Return min values of two vectors.\n * Given vectors a and b returns\n * [min(a[0], b[0]), min(a[1], b[1]), min(a[2], b[2])].\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The min components vector.\n */\nfunction min$1(a, b, dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = Math.min(a[0], b[0]);\n    dst[1] = Math.min(a[1], b[1]);\n    dst[2] = Math.min(a[2], b[2]);\n    return dst;\n}\n/**\n * Multiplies a vector by a scalar.\n * @param v - The vector.\n * @param k - The scalar.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The scaled vector.\n */\nfunction mulScalar$2(v, k, dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = v[0] * k;\n    dst[1] = v[1] * k;\n    dst[2] = v[2] * k;\n    return dst;\n}\n/**\n * Multiplies a vector by a scalar. (same as mulScalar)\n * @param v - The vector.\n * @param k - The scalar.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The scaled vector.\n */\nconst scale$3 = mulScalar$2;\n/**\n * Divides a vector by a scalar.\n * @param v - The vector.\n * @param k - The scalar.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The scaled vector.\n */\nfunction divScalar$2(v, k, dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = v[0] / k;\n    dst[1] = v[1] / k;\n    dst[2] = v[2] / k;\n    return dst;\n}\n/**\n * Inverse a vector.\n * @param v - The vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The inverted vector.\n */\nfunction inverse$3(v, dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = 1 / v[0];\n    dst[1] = 1 / v[1];\n    dst[2] = 1 / v[2];\n    return dst;\n}\n/**\n * Invert a vector. (same as inverse)\n * @param v - The vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The inverted vector.\n */\nconst invert$2 = inverse$3;\n/**\n * Computes the cross product of two vectors; assumes both vectors have\n * three entries.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The vector of a cross b.\n */\nfunction cross(a, b, dst) {\n    dst = dst || new VecType$1(3);\n    const t1 = a[2] * b[0] - a[0] * b[2];\n    const t2 = a[0] * b[1] - a[1] * b[0];\n    dst[0] = a[1] * b[2] - a[2] * b[1];\n    dst[1] = t1;\n    dst[2] = t2;\n    return dst;\n}\n/**\n * Computes the dot product of two vectors; assumes both vectors have\n * three entries.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @returns dot product\n */\nfunction dot$2(a, b) {\n    return (a[0] * b[0]) + (a[1] * b[1]) + (a[2] * b[2]);\n}\n/**\n * Computes the length of vector\n * @param v - vector.\n * @returns length of vector.\n */\nfunction length$2(v) {\n    const v0 = v[0];\n    const v1 = v[1];\n    const v2 = v[2];\n    return Math.sqrt(v0 * v0 + v1 * v1 + v2 * v2);\n}\n/**\n * Computes the length of vector (same as length)\n * @param v - vector.\n * @returns length of vector.\n */\nconst len$2 = length$2;\n/**\n * Computes the square of the length of vector\n * @param v - vector.\n * @returns square of the length of vector.\n */\nfunction lengthSq$2(v) {\n    const v0 = v[0];\n    const v1 = v[1];\n    const v2 = v[2];\n    return v0 * v0 + v1 * v1 + v2 * v2;\n}\n/**\n * Computes the square of the length of vector (same as lengthSq)\n * @param v - vector.\n * @returns square of the length of vector.\n */\nconst lenSq$2 = lengthSq$2;\n/**\n * Computes the distance between 2 points\n * @param a - vector.\n * @param b - vector.\n * @returns distance between a and b\n */\nfunction distance$1(a, b) {\n    const dx = a[0] - b[0];\n    const dy = a[1] - b[1];\n    const dz = a[2] - b[2];\n    return Math.sqrt(dx * dx + dy * dy + dz * dz);\n}\n/**\n * Computes the distance between 2 points (same as distance)\n * @param a - vector.\n * @param b - vector.\n * @returns distance between a and b\n */\nconst dist$1 = distance$1;\n/**\n * Computes the square of the distance between 2 points\n * @param a - vector.\n * @param b - vector.\n * @returns square of the distance between a and b\n */\nfunction distanceSq$1(a, b) {\n    const dx = a[0] - b[0];\n    const dy = a[1] - b[1];\n    const dz = a[2] - b[2];\n    return dx * dx + dy * dy + dz * dz;\n}\n/**\n * Computes the square of the distance between 2 points (same as distanceSq)\n * @param a - vector.\n * @param b - vector.\n * @returns square of the distance between a and b\n */\nconst distSq$1 = distanceSq$1;\n/**\n * Divides a vector by its Euclidean length and returns the quotient.\n * @param v - The vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The normalized vector.\n */\nfunction normalize$2(v, dst) {\n    dst = dst || new VecType$1(3);\n    const v0 = v[0];\n    const v1 = v[1];\n    const v2 = v[2];\n    const len = Math.sqrt(v0 * v0 + v1 * v1 + v2 * v2);\n    if (len > 0.00001) {\n        dst[0] = v0 / len;\n        dst[1] = v1 / len;\n        dst[2] = v2 / len;\n    }\n    else {\n        dst[0] = 0;\n        dst[1] = 0;\n        dst[2] = 0;\n    }\n    return dst;\n}\n/**\n * Negates a vector.\n * @param v - The vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns -v.\n */\nfunction negate$2(v, dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = -v[0];\n    dst[1] = -v[1];\n    dst[2] = -v[2];\n    return dst;\n}\n/**\n * Copies a vector. (same as {@link vec3.clone})\n * Also see {@link vec3.create} and {@link vec3.set}\n * @param v - The vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A copy of v.\n */\nfunction copy$3(v, dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = v[0];\n    dst[1] = v[1];\n    dst[2] = v[2];\n    return dst;\n}\n/**\n * Clones a vector. (same as {@link vec3.copy})\n * Also see {@link vec3.create} and {@link vec3.set}\n * @param v - The vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A copy of v.\n */\nconst clone$3 = copy$3;\n/**\n * Multiplies a vector by another vector (component-wise); assumes a and\n * b have the same length.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The vector of products of entries of a and b.\n */\nfunction multiply$3(a, b, dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = a[0] * b[0];\n    dst[1] = a[1] * b[1];\n    dst[2] = a[2] * b[2];\n    return dst;\n}\n/**\n * Multiplies a vector by another vector (component-wise); assumes a and\n * b have the same length. (same as mul)\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The vector of products of entries of a and b.\n */\nconst mul$3 = multiply$3;\n/**\n * Divides a vector by another vector (component-wise); assumes a and\n * b have the same length.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The vector of quotients of entries of a and b.\n */\nfunction divide$1(a, b, dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = a[0] / b[0];\n    dst[1] = a[1] / b[1];\n    dst[2] = a[2] / b[2];\n    return dst;\n}\n/**\n * Divides a vector by another vector (component-wise); assumes a and\n * b have the same length. (same as divide)\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The vector of quotients of entries of a and b.\n */\nconst div$1 = divide$1;\n/**\n * Creates a random vector\n * @param scale - Default 1\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The random vector.\n */\nfunction random(scale = 1, dst) {\n    dst = dst || new VecType$1(3);\n    const angle = Math.random() * 2 * Math.PI;\n    const z = Math.random() * 2 - 1;\n    const zScale = Math.sqrt(1 - z * z) * scale;\n    dst[0] = Math.cos(angle) * zScale;\n    dst[1] = Math.sin(angle) * zScale;\n    dst[2] = z * scale;\n    return dst;\n}\n/**\n * Zero's a vector\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The zeroed vector.\n */\nfunction zero$1(dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = 0;\n    dst[1] = 0;\n    dst[2] = 0;\n    return dst;\n}\n/**\n * transform vec3 by 4x4 matrix\n * @param v - the vector\n * @param m - The matrix.\n * @param dst - optional vec3 to store result. If not passed a new one is created.\n * @returns the transformed vector\n */\nfunction transformMat4$1(v, m, dst) {\n    dst = dst || new VecType$1(3);\n    const x = v[0];\n    const y = v[1];\n    const z = v[2];\n    const w = (m[3] * x + m[7] * y + m[11] * z + m[15]) || 1;\n    dst[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;\n    dst[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;\n    dst[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;\n    return dst;\n}\n/**\n * Transform vec4 by upper 3x3 matrix inside 4x4 matrix.\n * @param v - The direction.\n * @param m - The matrix.\n * @param dst - optional Vec3 to store result. If not passed a new one is created.\n * @returns The transformed vector.\n */\nfunction transformMat4Upper3x3(v, m, dst) {\n    dst = dst || new VecType$1(3);\n    const v0 = v[0];\n    const v1 = v[1];\n    const v2 = v[2];\n    dst[0] = v0 * m[0 * 4 + 0] + v1 * m[1 * 4 + 0] + v2 * m[2 * 4 + 0];\n    dst[1] = v0 * m[0 * 4 + 1] + v1 * m[1 * 4 + 1] + v2 * m[2 * 4 + 1];\n    dst[2] = v0 * m[0 * 4 + 2] + v1 * m[1 * 4 + 2] + v2 * m[2 * 4 + 2];\n    return dst;\n}\n/**\n * Transforms vec3 by 3x3 matrix\n *\n * @param v - the vector\n * @param m - The matrix.\n * @param dst - optional vec3 to store result. If not passed a new one is created.\n * @returns the transformed vector\n */\nfunction transformMat3(v, m, dst) {\n    dst = dst || new VecType$1(3);\n    const x = v[0];\n    const y = v[1];\n    const z = v[2];\n    dst[0] = x * m[0] + y * m[4] + z * m[8];\n    dst[1] = x * m[1] + y * m[5] + z * m[9];\n    dst[2] = x * m[2] + y * m[6] + z * m[10];\n    return dst;\n}\n/**\n * Transforms vec3 by Quaternion\n * @param v - the vector to transform\n * @param q - the quaternion to transform by\n * @param dst - optional vec3 to store result. If not passed a new one is created.\n * @returns the transformed\n */\nfunction transformQuat(v, q, dst) {\n    dst = dst || new VecType$1(3);\n    const qx = q[0];\n    const qy = q[1];\n    const qz = q[2];\n    const w2 = q[3] * 2;\n    const x = v[0];\n    const y = v[1];\n    const z = v[2];\n    const uvX = qy * z - qz * y;\n    const uvY = qz * x - qx * z;\n    const uvZ = qx * y - qy * x;\n    dst[0] = x + uvX * w2 + (qy * uvZ - qz * uvY) * 2;\n    dst[1] = y + uvY * w2 + (qz * uvX - qx * uvZ) * 2;\n    dst[2] = z + uvZ * w2 + (qx * uvY - qy * uvX) * 2;\n    return dst;\n}\n/**\n * Returns the translation component of a 4-by-4 matrix as a vector with 3\n * entries.\n * @param m - The matrix.\n * @param dst - vector to hold result. If not passed a new one is created.\n * @returns The translation component of m.\n */\nfunction getTranslation$1(m, dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = m[12];\n    dst[1] = m[13];\n    dst[2] = m[14];\n    return dst;\n}\n/**\n * Returns an axis of a 4x4 matrix as a vector with 3 entries\n * @param m - The matrix.\n * @param axis - The axis 0 = x, 1 = y, 2 = z;\n * @returns The axis component of m.\n */\nfunction getAxis$1(m, axis, dst) {\n    dst = dst || new VecType$1(3);\n    const off = axis * 4;\n    dst[0] = m[off + 0];\n    dst[1] = m[off + 1];\n    dst[2] = m[off + 2];\n    return dst;\n}\n/**\n * Returns the scaling component of the matrix\n * @param m - The Matrix\n * @param dst - The vector to set. If not passed a new one is created.\n */\nfunction getScaling$1(m, dst) {\n    dst = dst || new VecType$1(3);\n    const xx = m[0];\n    const xy = m[1];\n    const xz = m[2];\n    const yx = m[4];\n    const yy = m[5];\n    const yz = m[6];\n    const zx = m[8];\n    const zy = m[9];\n    const zz = m[10];\n    dst[0] = Math.sqrt(xx * xx + xy * xy + xz * xz);\n    dst[1] = Math.sqrt(yx * yx + yy * yy + yz * yz);\n    dst[2] = Math.sqrt(zx * zx + zy * zy + zz * zz);\n    return dst;\n}\n/**\n * Rotate a 3D vector around the x-axis\n *\n * @param {ReadonlyVec3} a The vec3 point to rotate\n * @param {ReadonlyVec3} b The origin of the rotation\n * @param {Number} rad The angle of rotation in radians\n * @param dst - The vector to set. If not passed a new one is created.\n * @returns the rotated vector\n */\nfunction rotateX$2(a, b, rad, dst) {\n    dst = dst || new VecType$1(3);\n    const p = [];\n    const r = [];\n    //Translate point to the origin\n    p[0] = a[0] - b[0];\n    p[1] = a[1] - b[1];\n    p[2] = a[2] - b[2];\n    //perform rotation\n    r[0] = p[0];\n    r[1] = p[1] * Math.cos(rad) - p[2] * Math.sin(rad);\n    r[2] = p[1] * Math.sin(rad) + p[2] * Math.cos(rad);\n    //translate to correct position\n    dst[0] = r[0] + b[0];\n    dst[1] = r[1] + b[1];\n    dst[2] = r[2] + b[2];\n    return dst;\n}\n/**\n * Rotate a 3D vector around the y-axis\n *\n * @param {ReadonlyVec3} a The vec3 point to rotate\n * @param {ReadonlyVec3} b The origin of the rotation\n * @param {Number} rad The angle of rotation in radians\n * @param dst - The vector to set. If not passed a new one is created.\n * @returns the rotated vector\n */\nfunction rotateY$2(a, b, rad, dst) {\n    dst = dst || new VecType$1(3);\n    const p = [];\n    const r = [];\n    // translate point to the origin\n    p[0] = a[0] - b[0];\n    p[1] = a[1] - b[1];\n    p[2] = a[2] - b[2];\n    // perform rotation\n    r[0] = p[2] * Math.sin(rad) + p[0] * Math.cos(rad);\n    r[1] = p[1];\n    r[2] = p[2] * Math.cos(rad) - p[0] * Math.sin(rad);\n    // translate to correct position\n    dst[0] = r[0] + b[0];\n    dst[1] = r[1] + b[1];\n    dst[2] = r[2] + b[2];\n    return dst;\n}\n/**\n * Rotate a 3D vector around the z-axis\n *\n * @param {ReadonlyVec3} a The vec3 point to rotate\n * @param {ReadonlyVec3} b The origin of the rotation\n * @param {Number} rad The angle of rotation in radians\n * @param dst - The vector to set. If not passed a new one is created.\n * @returns {vec3} out\n */\nfunction rotateZ$2(a, b, rad, dst) {\n    dst = dst || new VecType$1(3);\n    const p = [];\n    const r = [];\n    // translate point to the origin\n    p[0] = a[0] - b[0];\n    p[1] = a[1] - b[1];\n    p[2] = a[2] - b[2];\n    // perform rotation\n    r[0] = p[0] * Math.cos(rad) - p[1] * Math.sin(rad);\n    r[1] = p[0] * Math.sin(rad) + p[1] * Math.cos(rad);\n    r[2] = p[2];\n    // translate to correct position\n    dst[0] = r[0] + b[0];\n    dst[1] = r[1] + b[1];\n    dst[2] = r[2] + b[2];\n    return dst;\n}\n/**\n * Treat a 3D vector as a direction and set it's length\n *\n * @param a The vec3 to lengthen\n * @param len The length of the resulting vector\n * @returns The lengthened vector\n */\nfunction setLength$1(a, len, dst) {\n    dst = dst || new VecType$1(3);\n    normalize$2(a, dst);\n    return mulScalar$2(dst, len, dst);\n}\n/**\n * Ensure a vector is not longer than a max length\n *\n * @param a The vec3 to limit\n * @param maxLen The longest length of the resulting vector\n * @returns The vector, shortened to maxLen if it's too long\n */\nfunction truncate$1(a, maxLen, dst) {\n    dst = dst || new VecType$1(3);\n    if (length$2(a) > maxLen) {\n        return setLength$1(a, maxLen, dst);\n    }\n    return copy$3(a, dst);\n}\n/**\n * Return the vector exactly between 2 endpoint vectors\n *\n * @param a Endpoint 1\n * @param b Endpoint 2\n * @returns The vector exactly residing between endpoints 1 and 2\n */\nfunction midpoint$1(a, b, dst) {\n    dst = dst || new VecType$1(3);\n    return lerp$2(a, b, 0.5, dst);\n}\n\nvar vec3Impl = {\n    __proto__: null,\n    add: add$2,\n    addScaled: addScaled$1,\n    angle: angle$1,\n    ceil: ceil$1,\n    clamp: clamp$1,\n    clone: clone$3,\n    copy: copy$3,\n    create: create$4,\n    cross: cross,\n    dist: dist$1,\n    distSq: distSq$1,\n    distance: distance$1,\n    distanceSq: distanceSq$1,\n    div: div$1,\n    divScalar: divScalar$2,\n    divide: divide$1,\n    dot: dot$2,\n    equals: equals$3,\n    equalsApproximately: equalsApproximately$3,\n    floor: floor$1,\n    fromValues: fromValues$2,\n    getAxis: getAxis$1,\n    getScaling: getScaling$1,\n    getTranslation: getTranslation$1,\n    inverse: inverse$3,\n    invert: invert$2,\n    len: len$2,\n    lenSq: lenSq$2,\n    length: length$2,\n    lengthSq: lengthSq$2,\n    lerp: lerp$2,\n    lerpV: lerpV$1,\n    max: max$1,\n    midpoint: midpoint$1,\n    min: min$1,\n    mul: mul$3,\n    mulScalar: mulScalar$2,\n    multiply: multiply$3,\n    negate: negate$2,\n    normalize: normalize$2,\n    random: random,\n    rotateX: rotateX$2,\n    rotateY: rotateY$2,\n    rotateZ: rotateZ$2,\n    round: round$1,\n    scale: scale$3,\n    set: set$3,\n    setDefaultType: setDefaultType$5,\n    setLength: setLength$1,\n    sub: sub$2,\n    subtract: subtract$2,\n    transformMat3: transformMat3,\n    transformMat4: transformMat4$1,\n    transformMat4Upper3x3: transformMat4Upper3x3,\n    transformQuat: transformQuat,\n    truncate: truncate$1,\n    zero: zero$1\n};\n\n/**\n * 4x4 Matrix math math functions.\n *\n * Almost all functions take an optional `dst` argument. If it is not passed in the\n * functions will create a new matrix. In other words you can do this\n *\n *     const mat = mat4.translation([1, 2, 3]);  // Creates a new translation matrix\n *\n * or\n *\n *     const mat = mat4.create();\n *     mat4.translation([1, 2, 3], mat);  // Puts translation matrix in mat.\n *\n * The first style is often easier but depending on where it's used it generates garbage where\n * as there is almost never allocation with the second style.\n *\n * It is always save to pass any matrix as the destination. So for example\n *\n *     const mat = mat4.identity();\n *     const trans = mat4.translation([1, 2, 3]);\n *     mat4.multiply(mat, trans, mat);  // Multiplies mat * trans and puts result in mat.\n *\n */\nlet MatType = Float32Array;\n/**\n * Sets the type this library creates for a Mat4\n * @param ctor - the constructor for the type. Either `Float32Array`, `Float64Array`, or `Array`\n * @returns previous constructor for Mat4\n */\nfunction setDefaultType$3(ctor) {\n    const oldType = MatType;\n    MatType = ctor;\n    return oldType;\n}\n/**\n * Create a Mat4 from values\n *\n * Note: Since passing in a raw JavaScript array\n * is valid in all circumstances, if you want to\n * force a JavaScript array into a Mat4's specified type\n * it would be faster to use\n *\n * ```\n * const m = mat4.clone(someJSArray);\n * ```\n *\n * Note: a consequence of the implementation is if your Mat4Type = `Array`\n * instead of `Float32Array` or `Float64Array` then any values you\n * don't pass in will be undefined. Usually this is not an issue since\n * (a) using `Array` is rare and (b) using `mat4.create` is usually used\n * to create a Mat4 to be filled out as in\n *\n * ```\n * const m = mat4.create();\n * mat4.perspective(fov, aspect, near, far, m);\n * ```\n *\n * @param v0 - value for element 0\n * @param v1 - value for element 1\n * @param v2 - value for element 2\n * @param v3 - value for element 3\n * @param v4 - value for element 4\n * @param v5 - value for element 5\n * @param v6 - value for element 6\n * @param v7 - value for element 7\n * @param v8 - value for element 8\n * @param v9 - value for element 9\n * @param v10 - value for element 10\n * @param v11 - value for element 11\n * @param v12 - value for element 12\n * @param v13 - value for element 13\n * @param v14 - value for element 14\n * @param v15 - value for element 15\n * @returns created from values.\n */\nfunction create$2(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15) {\n    const dst = new MatType(16);\n    if (v0 !== undefined) {\n        dst[0] = v0;\n        if (v1 !== undefined) {\n            dst[1] = v1;\n            if (v2 !== undefined) {\n                dst[2] = v2;\n                if (v3 !== undefined) {\n                    dst[3] = v3;\n                    if (v4 !== undefined) {\n                        dst[4] = v4;\n                        if (v5 !== undefined) {\n                            dst[5] = v5;\n                            if (v6 !== undefined) {\n                                dst[6] = v6;\n                                if (v7 !== undefined) {\n                                    dst[7] = v7;\n                                    if (v8 !== undefined) {\n                                        dst[8] = v8;\n                                        if (v9 !== undefined) {\n                                            dst[9] = v9;\n                                            if (v10 !== undefined) {\n                                                dst[10] = v10;\n                                                if (v11 !== undefined) {\n                                                    dst[11] = v11;\n                                                    if (v12 !== undefined) {\n                                                        dst[12] = v12;\n                                                        if (v13 !== undefined) {\n                                                            dst[13] = v13;\n                                                            if (v14 !== undefined) {\n                                                                dst[14] = v14;\n                                                                if (v15 !== undefined) {\n                                                                    dst[15] = v15;\n                                                                }\n                                                            }\n                                                        }\n                                                    }\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return dst;\n}\n/**\n * Sets the values of a Mat4\n * Also see {@link mat4.create} and {@link mat4.copy}\n *\n * @param v0 - value for element 0\n * @param v1 - value for element 1\n * @param v2 - value for element 2\n * @param v3 - value for element 3\n * @param v4 - value for element 4\n * @param v5 - value for element 5\n * @param v6 - value for element 6\n * @param v7 - value for element 7\n * @param v8 - value for element 8\n * @param v9 - value for element 9\n * @param v10 - value for element 10\n * @param v11 - value for element 11\n * @param v12 - value for element 12\n * @param v13 - value for element 13\n * @param v14 - value for element 14\n * @param v15 - value for element 15\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns Mat4 created from values.\n */\nfunction set$2(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, dst) {\n    dst = dst || new MatType(16);\n    dst[0] = v0;\n    dst[1] = v1;\n    dst[2] = v2;\n    dst[3] = v3;\n    dst[4] = v4;\n    dst[5] = v5;\n    dst[6] = v6;\n    dst[7] = v7;\n    dst[8] = v8;\n    dst[9] = v9;\n    dst[10] = v10;\n    dst[11] = v11;\n    dst[12] = v12;\n    dst[13] = v13;\n    dst[14] = v14;\n    dst[15] = v15;\n    return dst;\n}\n/**\n * Creates a Mat4 from a Mat3\n * @param m3 - source matrix\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns Mat4 made from m3\n */\nfunction fromMat3(m3, dst) {\n    dst = dst || new MatType(16);\n    dst[0] = m3[0];\n    dst[1] = m3[1];\n    dst[2] = m3[2];\n    dst[3] = 0;\n    dst[4] = m3[4];\n    dst[5] = m3[5];\n    dst[6] = m3[6];\n    dst[7] = 0;\n    dst[8] = m3[8];\n    dst[9] = m3[9];\n    dst[10] = m3[10];\n    dst[11] = 0;\n    dst[12] = 0;\n    dst[13] = 0;\n    dst[14] = 0;\n    dst[15] = 1;\n    return dst;\n}\n/**\n * Creates a Mat4 rotation matrix from a quaternion\n * @param q - quaternion to create matrix from\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns Mat4 made from q\n */\nfunction fromQuat(q, dst) {\n    dst = dst || new MatType(16);\n    const x = q[0];\n    const y = q[1];\n    const z = q[2];\n    const w = q[3];\n    const x2 = x + x;\n    const y2 = y + y;\n    const z2 = z + z;\n    const xx = x * x2;\n    const yx = y * x2;\n    const yy = y * y2;\n    const zx = z * x2;\n    const zy = z * y2;\n    const zz = z * z2;\n    const wx = w * x2;\n    const wy = w * y2;\n    const wz = w * z2;\n    dst[0] = 1 - yy - zz;\n    dst[1] = yx + wz;\n    dst[2] = zx - wy;\n    dst[3] = 0;\n    dst[4] = yx - wz;\n    dst[5] = 1 - xx - zz;\n    dst[6] = zy + wx;\n    dst[7] = 0;\n    dst[8] = zx + wy;\n    dst[9] = zy - wx;\n    dst[10] = 1 - xx - yy;\n    dst[11] = 0;\n    dst[12] = 0;\n    dst[13] = 0;\n    dst[14] = 0;\n    dst[15] = 1;\n    return dst;\n}\n/**\n * Negates a matrix.\n * @param m - The matrix.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns -m.\n */\nfunction negate$1(m, dst) {\n    dst = dst || new MatType(16);\n    dst[0] = -m[0];\n    dst[1] = -m[1];\n    dst[2] = -m[2];\n    dst[3] = -m[3];\n    dst[4] = -m[4];\n    dst[5] = -m[5];\n    dst[6] = -m[6];\n    dst[7] = -m[7];\n    dst[8] = -m[8];\n    dst[9] = -m[9];\n    dst[10] = -m[10];\n    dst[11] = -m[11];\n    dst[12] = -m[12];\n    dst[13] = -m[13];\n    dst[14] = -m[14];\n    dst[15] = -m[15];\n    return dst;\n}\n/**\n * Copies a matrix. (same as {@link mat4.clone})\n * Also see {@link mat4.create} and {@link mat4.set}\n * @param m - The matrix.\n * @param dst - The matrix. If not passed a new one is created.\n * @returns A copy of m.\n */\nfunction copy$2(m, dst) {\n    dst = dst || new MatType(16);\n    dst[0] = m[0];\n    dst[1] = m[1];\n    dst[2] = m[2];\n    dst[3] = m[3];\n    dst[4] = m[4];\n    dst[5] = m[5];\n    dst[6] = m[6];\n    dst[7] = m[7];\n    dst[8] = m[8];\n    dst[9] = m[9];\n    dst[10] = m[10];\n    dst[11] = m[11];\n    dst[12] = m[12];\n    dst[13] = m[13];\n    dst[14] = m[14];\n    dst[15] = m[15];\n    return dst;\n}\n/**\n * Copies a matrix (same as {@link mat4.copy})\n * Also see {@link mat4.create} and {@link mat4.set}\n * @param m - The matrix.\n * @param dst - The matrix. If not passed a new one is created.\n * @returns A copy of m.\n */\nconst clone$2 = copy$2;\n/**\n * Check if 2 matrices are approximately equal\n * @param a - Operand matrix.\n * @param b - Operand matrix.\n * @returns true if matrices are approximately equal\n */\nfunction equalsApproximately$2(a, b) {\n    return Math.abs(a[0] - b[0]) < EPSILON &&\n        Math.abs(a[1] - b[1]) < EPSILON &&\n        Math.abs(a[2] - b[2]) < EPSILON &&\n        Math.abs(a[3] - b[3]) < EPSILON &&\n        Math.abs(a[4] - b[4]) < EPSILON &&\n        Math.abs(a[5] - b[5]) < EPSILON &&\n        Math.abs(a[6] - b[6]) < EPSILON &&\n        Math.abs(a[7] - b[7]) < EPSILON &&\n        Math.abs(a[8] - b[8]) < EPSILON &&\n        Math.abs(a[9] - b[9]) < EPSILON &&\n        Math.abs(a[10] - b[10]) < EPSILON &&\n        Math.abs(a[11] - b[11]) < EPSILON &&\n        Math.abs(a[12] - b[12]) < EPSILON &&\n        Math.abs(a[13] - b[13]) < EPSILON &&\n        Math.abs(a[14] - b[14]) < EPSILON &&\n        Math.abs(a[15] - b[15]) < EPSILON;\n}\n/**\n * Check if 2 matrices are exactly equal\n * @param a - Operand matrix.\n * @param b - Operand matrix.\n * @returns true if matrices are exactly equal\n */\nfunction equals$2(a, b) {\n    return a[0] === b[0] &&\n        a[1] === b[1] &&\n        a[2] === b[2] &&\n        a[3] === b[3] &&\n        a[4] === b[4] &&\n        a[5] === b[5] &&\n        a[6] === b[6] &&\n        a[7] === b[7] &&\n        a[8] === b[8] &&\n        a[9] === b[9] &&\n        a[10] === b[10] &&\n        a[11] === b[11] &&\n        a[12] === b[12] &&\n        a[13] === b[13] &&\n        a[14] === b[14] &&\n        a[15] === b[15];\n}\n/**\n * Creates a 4-by-4 identity matrix.\n *\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns A 4-by-4 identity matrix.\n */\nfunction identity$1(dst) {\n    dst = dst || new MatType(16);\n    dst[0] = 1;\n    dst[1] = 0;\n    dst[2] = 0;\n    dst[3] = 0;\n    dst[4] = 0;\n    dst[5] = 1;\n    dst[6] = 0;\n    dst[7] = 0;\n    dst[8] = 0;\n    dst[9] = 0;\n    dst[10] = 1;\n    dst[11] = 0;\n    dst[12] = 0;\n    dst[13] = 0;\n    dst[14] = 0;\n    dst[15] = 1;\n    return dst;\n}\n/**\n * Takes the transpose of a matrix.\n * @param m - The matrix.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The transpose of m.\n */\nfunction transpose(m, dst) {\n    dst = dst || new MatType(16);\n    if (dst === m) {\n        let t;\n        t = m[1];\n        m[1] = m[4];\n        m[4] = t;\n        t = m[2];\n        m[2] = m[8];\n        m[8] = t;\n        t = m[3];\n        m[3] = m[12];\n        m[12] = t;\n        t = m[6];\n        m[6] = m[9];\n        m[9] = t;\n        t = m[7];\n        m[7] = m[13];\n        m[13] = t;\n        t = m[11];\n        m[11] = m[14];\n        m[14] = t;\n        return dst;\n    }\n    const m00 = m[0 * 4 + 0];\n    const m01 = m[0 * 4 + 1];\n    const m02 = m[0 * 4 + 2];\n    const m03 = m[0 * 4 + 3];\n    const m10 = m[1 * 4 + 0];\n    const m11 = m[1 * 4 + 1];\n    const m12 = m[1 * 4 + 2];\n    const m13 = m[1 * 4 + 3];\n    const m20 = m[2 * 4 + 0];\n    const m21 = m[2 * 4 + 1];\n    const m22 = m[2 * 4 + 2];\n    const m23 = m[2 * 4 + 3];\n    const m30 = m[3 * 4 + 0];\n    const m31 = m[3 * 4 + 1];\n    const m32 = m[3 * 4 + 2];\n    const m33 = m[3 * 4 + 3];\n    dst[0] = m00;\n    dst[1] = m10;\n    dst[2] = m20;\n    dst[3] = m30;\n    dst[4] = m01;\n    dst[5] = m11;\n    dst[6] = m21;\n    dst[7] = m31;\n    dst[8] = m02;\n    dst[9] = m12;\n    dst[10] = m22;\n    dst[11] = m32;\n    dst[12] = m03;\n    dst[13] = m13;\n    dst[14] = m23;\n    dst[15] = m33;\n    return dst;\n}\n/**\n * Computes the inverse of a 4-by-4 matrix.\n * @param m - The matrix.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The inverse of m.\n */\nfunction inverse$2(m, dst) {\n    dst = dst || new MatType(16);\n    const m00 = m[0 * 4 + 0];\n    const m01 = m[0 * 4 + 1];\n    const m02 = m[0 * 4 + 2];\n    const m03 = m[0 * 4 + 3];\n    const m10 = m[1 * 4 + 0];\n    const m11 = m[1 * 4 + 1];\n    const m12 = m[1 * 4 + 2];\n    const m13 = m[1 * 4 + 3];\n    const m20 = m[2 * 4 + 0];\n    const m21 = m[2 * 4 + 1];\n    const m22 = m[2 * 4 + 2];\n    const m23 = m[2 * 4 + 3];\n    const m30 = m[3 * 4 + 0];\n    const m31 = m[3 * 4 + 1];\n    const m32 = m[3 * 4 + 2];\n    const m33 = m[3 * 4 + 3];\n    const tmp0 = m22 * m33;\n    const tmp1 = m32 * m23;\n    const tmp2 = m12 * m33;\n    const tmp3 = m32 * m13;\n    const tmp4 = m12 * m23;\n    const tmp5 = m22 * m13;\n    const tmp6 = m02 * m33;\n    const tmp7 = m32 * m03;\n    const tmp8 = m02 * m23;\n    const tmp9 = m22 * m03;\n    const tmp10 = m02 * m13;\n    const tmp11 = m12 * m03;\n    const tmp12 = m20 * m31;\n    const tmp13 = m30 * m21;\n    const tmp14 = m10 * m31;\n    const tmp15 = m30 * m11;\n    const tmp16 = m10 * m21;\n    const tmp17 = m20 * m11;\n    const tmp18 = m00 * m31;\n    const tmp19 = m30 * m01;\n    const tmp20 = m00 * m21;\n    const tmp21 = m20 * m01;\n    const tmp22 = m00 * m11;\n    const tmp23 = m10 * m01;\n    const t0 = (tmp0 * m11 + tmp3 * m21 + tmp4 * m31) -\n        (tmp1 * m11 + tmp2 * m21 + tmp5 * m31);\n    const t1 = (tmp1 * m01 + tmp6 * m21 + tmp9 * m31) -\n        (tmp0 * m01 + tmp7 * m21 + tmp8 * m31);\n    const t2 = (tmp2 * m01 + tmp7 * m11 + tmp10 * m31) -\n        (tmp3 * m01 + tmp6 * m11 + tmp11 * m31);\n    const t3 = (tmp5 * m01 + tmp8 * m11 + tmp11 * m21) -\n        (tmp4 * m01 + tmp9 * m11 + tmp10 * m21);\n    const d = 1 / (m00 * t0 + m10 * t1 + m20 * t2 + m30 * t3);\n    dst[0] = d * t0;\n    dst[1] = d * t1;\n    dst[2] = d * t2;\n    dst[3] = d * t3;\n    dst[4] = d * ((tmp1 * m10 + tmp2 * m20 + tmp5 * m30) -\n        (tmp0 * m10 + tmp3 * m20 + tmp4 * m30));\n    dst[5] = d * ((tmp0 * m00 + tmp7 * m20 + tmp8 * m30) -\n        (tmp1 * m00 + tmp6 * m20 + tmp9 * m30));\n    dst[6] = d * ((tmp3 * m00 + tmp6 * m10 + tmp11 * m30) -\n        (tmp2 * m00 + tmp7 * m10 + tmp10 * m30));\n    dst[7] = d * ((tmp4 * m00 + tmp9 * m10 + tmp10 * m20) -\n        (tmp5 * m00 + tmp8 * m10 + tmp11 * m20));\n    dst[8] = d * ((tmp12 * m13 + tmp15 * m23 + tmp16 * m33) -\n        (tmp13 * m13 + tmp14 * m23 + tmp17 * m33));\n    dst[9] = d * ((tmp13 * m03 + tmp18 * m23 + tmp21 * m33) -\n        (tmp12 * m03 + tmp19 * m23 + tmp20 * m33));\n    dst[10] = d * ((tmp14 * m03 + tmp19 * m13 + tmp22 * m33) -\n        (tmp15 * m03 + tmp18 * m13 + tmp23 * m33));\n    dst[11] = d * ((tmp17 * m03 + tmp20 * m13 + tmp23 * m23) -\n        (tmp16 * m03 + tmp21 * m13 + tmp22 * m23));\n    dst[12] = d * ((tmp14 * m22 + tmp17 * m32 + tmp13 * m12) -\n        (tmp16 * m32 + tmp12 * m12 + tmp15 * m22));\n    dst[13] = d * ((tmp20 * m32 + tmp12 * m02 + tmp19 * m22) -\n        (tmp18 * m22 + tmp21 * m32 + tmp13 * m02));\n    dst[14] = d * ((tmp18 * m12 + tmp23 * m32 + tmp15 * m02) -\n        (tmp22 * m32 + tmp14 * m02 + tmp19 * m12));\n    dst[15] = d * ((tmp22 * m22 + tmp16 * m02 + tmp21 * m12) -\n        (tmp20 * m12 + tmp23 * m22 + tmp17 * m02));\n    return dst;\n}\n/**\n * Compute the determinant of a matrix\n * @param m - the matrix\n * @returns the determinant\n */\nfunction determinant(m) {\n    const m00 = m[0 * 4 + 0];\n    const m01 = m[0 * 4 + 1];\n    const m02 = m[0 * 4 + 2];\n    const m03 = m[0 * 4 + 3];\n    const m10 = m[1 * 4 + 0];\n    const m11 = m[1 * 4 + 1];\n    const m12 = m[1 * 4 + 2];\n    const m13 = m[1 * 4 + 3];\n    const m20 = m[2 * 4 + 0];\n    const m21 = m[2 * 4 + 1];\n    const m22 = m[2 * 4 + 2];\n    const m23 = m[2 * 4 + 3];\n    const m30 = m[3 * 4 + 0];\n    const m31 = m[3 * 4 + 1];\n    const m32 = m[3 * 4 + 2];\n    const m33 = m[3 * 4 + 3];\n    const tmp0 = m22 * m33;\n    const tmp1 = m32 * m23;\n    const tmp2 = m12 * m33;\n    const tmp3 = m32 * m13;\n    const tmp4 = m12 * m23;\n    const tmp5 = m22 * m13;\n    const tmp6 = m02 * m33;\n    const tmp7 = m32 * m03;\n    const tmp8 = m02 * m23;\n    const tmp9 = m22 * m03;\n    const tmp10 = m02 * m13;\n    const tmp11 = m12 * m03;\n    const t0 = (tmp0 * m11 + tmp3 * m21 + tmp4 * m31) -\n        (tmp1 * m11 + tmp2 * m21 + tmp5 * m31);\n    const t1 = (tmp1 * m01 + tmp6 * m21 + tmp9 * m31) -\n        (tmp0 * m01 + tmp7 * m21 + tmp8 * m31);\n    const t2 = (tmp2 * m01 + tmp7 * m11 + tmp10 * m31) -\n        (tmp3 * m01 + tmp6 * m11 + tmp11 * m31);\n    const t3 = (tmp5 * m01 + tmp8 * m11 + tmp11 * m21) -\n        (tmp4 * m01 + tmp9 * m11 + tmp10 * m21);\n    return m00 * t0 + m10 * t1 + m20 * t2 + m30 * t3;\n}\n/**\n * Computes the inverse of a 4-by-4 matrix. (same as inverse)\n * @param m - The matrix.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The inverse of m.\n */\nconst invert$1 = inverse$2;\n/**\n * Multiplies two 4-by-4 matrices with a on the left and b on the right\n * @param a - The matrix on the left.\n * @param b - The matrix on the right.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The matrix product of a and b.\n */\nfunction multiply$2(a, b, dst) {\n    dst = dst || new MatType(16);\n    const a00 = a[0];\n    const a01 = a[1];\n    const a02 = a[2];\n    const a03 = a[3];\n    const a10 = a[4 + 0];\n    const a11 = a[4 + 1];\n    const a12 = a[4 + 2];\n    const a13 = a[4 + 3];\n    const a20 = a[8 + 0];\n    const a21 = a[8 + 1];\n    const a22 = a[8 + 2];\n    const a23 = a[8 + 3];\n    const a30 = a[12 + 0];\n    const a31 = a[12 + 1];\n    const a32 = a[12 + 2];\n    const a33 = a[12 + 3];\n    const b00 = b[0];\n    const b01 = b[1];\n    const b02 = b[2];\n    const b03 = b[3];\n    const b10 = b[4 + 0];\n    const b11 = b[4 + 1];\n    const b12 = b[4 + 2];\n    const b13 = b[4 + 3];\n    const b20 = b[8 + 0];\n    const b21 = b[8 + 1];\n    const b22 = b[8 + 2];\n    const b23 = b[8 + 3];\n    const b30 = b[12 + 0];\n    const b31 = b[12 + 1];\n    const b32 = b[12 + 2];\n    const b33 = b[12 + 3];\n    dst[0] = a00 * b00 + a10 * b01 + a20 * b02 + a30 * b03;\n    dst[1] = a01 * b00 + a11 * b01 + a21 * b02 + a31 * b03;\n    dst[2] = a02 * b00 + a12 * b01 + a22 * b02 + a32 * b03;\n    dst[3] = a03 * b00 + a13 * b01 + a23 * b02 + a33 * b03;\n    dst[4] = a00 * b10 + a10 * b11 + a20 * b12 + a30 * b13;\n    dst[5] = a01 * b10 + a11 * b11 + a21 * b12 + a31 * b13;\n    dst[6] = a02 * b10 + a12 * b11 + a22 * b12 + a32 * b13;\n    dst[7] = a03 * b10 + a13 * b11 + a23 * b12 + a33 * b13;\n    dst[8] = a00 * b20 + a10 * b21 + a20 * b22 + a30 * b23;\n    dst[9] = a01 * b20 + a11 * b21 + a21 * b22 + a31 * b23;\n    dst[10] = a02 * b20 + a12 * b21 + a22 * b22 + a32 * b23;\n    dst[11] = a03 * b20 + a13 * b21 + a23 * b22 + a33 * b23;\n    dst[12] = a00 * b30 + a10 * b31 + a20 * b32 + a30 * b33;\n    dst[13] = a01 * b30 + a11 * b31 + a21 * b32 + a31 * b33;\n    dst[14] = a02 * b30 + a12 * b31 + a22 * b32 + a32 * b33;\n    dst[15] = a03 * b30 + a13 * b31 + a23 * b32 + a33 * b33;\n    return dst;\n}\n/**\n * Multiplies two 4-by-4 matrices with a on the left and b on the right (same as multiply)\n * @param a - The matrix on the left.\n * @param b - The matrix on the right.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The matrix product of a and b.\n */\nconst mul$2 = multiply$2;\n/**\n * Sets the translation component of a 4-by-4 matrix to the given\n * vector.\n * @param a - The matrix.\n * @param v - The vector.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The matrix with translation set.\n */\nfunction setTranslation(a, v, dst) {\n    dst = dst || identity$1();\n    if (a !== dst) {\n        dst[0] = a[0];\n        dst[1] = a[1];\n        dst[2] = a[2];\n        dst[3] = a[3];\n        dst[4] = a[4];\n        dst[5] = a[5];\n        dst[6] = a[6];\n        dst[7] = a[7];\n        dst[8] = a[8];\n        dst[9] = a[9];\n        dst[10] = a[10];\n        dst[11] = a[11];\n    }\n    dst[12] = v[0];\n    dst[13] = v[1];\n    dst[14] = v[2];\n    dst[15] = 1;\n    return dst;\n}\n/**\n * Returns the translation component of a 4-by-4 matrix as a vector with 3\n * entries.\n * @param m - The matrix.\n * @param dst - vector to hold result. If not passed a new one is created.\n * @returns The translation component of m.\n */\nfunction getTranslation(m, dst) {\n    dst = dst || create$4();\n    dst[0] = m[12];\n    dst[1] = m[13];\n    dst[2] = m[14];\n    return dst;\n}\n/**\n * Returns an axis of a 4x4 matrix as a vector with 3 entries\n * @param m - The matrix.\n * @param axis - The axis 0 = x, 1 = y, 2 = z;\n * @returns The axis component of m.\n */\nfunction getAxis(m, axis, dst) {\n    dst = dst || create$4();\n    const off = axis * 4;\n    dst[0] = m[off + 0];\n    dst[1] = m[off + 1];\n    dst[2] = m[off + 2];\n    return dst;\n}\n/**\n * Sets an axis of a 4x4 matrix as a vector with 3 entries\n * @param m - The matrix.\n * @param v - the axis vector\n * @param axis - The axis  0 = x, 1 = y, 2 = z;\n * @param dst - The matrix to set. If not passed a new one is created.\n * @returns The matrix with axis set.\n */\nfunction setAxis(m, v, axis, dst) {\n    if (dst !== m) {\n        dst = copy$2(m, dst);\n    }\n    const off = axis * 4;\n    dst[off + 0] = v[0];\n    dst[off + 1] = v[1];\n    dst[off + 2] = v[2];\n    return dst;\n}\n/**\n * Returns the scaling component of the matrix\n * @param m - The Matrix\n * @param dst - The vector to set. If not passed a new one is created.\n */\nfunction getScaling(m, dst) {\n    dst = dst || create$4();\n    const xx = m[0];\n    const xy = m[1];\n    const xz = m[2];\n    const yx = m[4];\n    const yy = m[5];\n    const yz = m[6];\n    const zx = m[8];\n    const zy = m[9];\n    const zz = m[10];\n    dst[0] = Math.sqrt(xx * xx + xy * xy + xz * xz);\n    dst[1] = Math.sqrt(yx * yx + yy * yy + yz * yz);\n    dst[2] = Math.sqrt(zx * zx + zy * zy + zz * zz);\n    return dst;\n}\n/**\n * Computes a 4-by-4 perspective transformation matrix given the angular height\n * of the frustum, the aspect ratio, and the near and far clipping planes.  The\n * arguments define a frustum extending in the negative z direction.  The given\n * angle is the vertical angle of the frustum, and the horizontal angle is\n * determined to produce the given aspect ratio.  The arguments near and far are\n * the distances to the near and far clipping planes.  Note that near and far\n * are not z coordinates, but rather they are distances along the negative\n * z-axis.  The matrix generated sends the viewing frustum to the unit box.\n * We assume a unit box extending from -1 to 1 in the x and y dimensions and\n * from 0 to 1 in the z dimension.\n *\n * Note: If you pass `Infinity` for zFar then it will produce a projection matrix\n * returns -Infinity for Z when transforming coordinates with Z <= 0 and +Infinity for Z\n * otherwise.\n *\n * @param fieldOfViewYInRadians - The camera angle from top to bottom (in radians).\n * @param aspect - The aspect ratio width / height.\n * @param zNear - The depth (negative z coordinate)\n *     of the near clipping plane.\n * @param zFar - The depth (negative z coordinate)\n *     of the far clipping plane.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The perspective matrix.\n */\nfunction perspective(fieldOfViewYInRadians, aspect, zNear, zFar, dst) {\n    dst = dst || new MatType(16);\n    const f = Math.tan(Math.PI * 0.5 - 0.5 * fieldOfViewYInRadians);\n    dst[0] = f / aspect;\n    dst[1] = 0;\n    dst[2] = 0;\n    dst[3] = 0;\n    dst[4] = 0;\n    dst[5] = f;\n    dst[6] = 0;\n    dst[7] = 0;\n    dst[8] = 0;\n    dst[9] = 0;\n    dst[11] = -1;\n    dst[12] = 0;\n    dst[13] = 0;\n    dst[15] = 0;\n    if (Number.isFinite(zFar)) {\n        const rangeInv = 1 / (zNear - zFar);\n        dst[10] = zFar * rangeInv;\n        dst[14] = zFar * zNear * rangeInv;\n    }\n    else {\n        dst[10] = -1;\n        dst[14] = -zNear;\n    }\n    return dst;\n}\n/**\n * Computes a 4-by-4 reverse-z perspective transformation matrix given the angular height\n * of the frustum, the aspect ratio, and the near and far clipping planes.  The\n * arguments define a frustum extending in the negative z direction.  The given\n * angle is the vertical angle of the frustum, and the horizontal angle is\n * determined to produce the given aspect ratio.  The arguments near and far are\n * the distances to the near and far clipping planes.  Note that near and far\n * are not z coordinates, but rather they are distances along the negative\n * z-axis.  The matrix generated sends the viewing frustum to the unit box.\n * We assume a unit box extending from -1 to 1 in the x and y dimensions and\n * from 1 (at -zNear) to 0 (at -zFar) in the z dimension.\n *\n * @param fieldOfViewYInRadians - The camera angle from top to bottom (in radians).\n * @param aspect - The aspect ratio width / height.\n * @param zNear - The depth (negative z coordinate)\n *     of the near clipping plane.\n * @param zFar - The depth (negative z coordinate)\n *     of the far clipping plane. (default = Infinity)\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The perspective matrix.\n */ function perspectiveReverseZ(fieldOfViewYInRadians, aspect, zNear, zFar = Infinity, dst) {\n    dst = dst || new MatType(16);\n    const f = 1 / Math.tan(fieldOfViewYInRadians * 0.5);\n    dst[0] = f / aspect;\n    dst[1] = 0;\n    dst[2] = 0;\n    dst[3] = 0;\n    dst[4] = 0;\n    dst[5] = f;\n    dst[6] = 0;\n    dst[7] = 0;\n    dst[8] = 0;\n    dst[9] = 0;\n    dst[11] = -1;\n    dst[12] = 0;\n    dst[13] = 0;\n    dst[15] = 0;\n    if (zFar === Infinity) {\n        dst[10] = 0;\n        dst[14] = zNear;\n    }\n    else {\n        const rangeInv = 1 / (zFar - zNear);\n        dst[10] = zNear * rangeInv;\n        dst[14] = zFar * zNear * rangeInv;\n    }\n    return dst;\n}\n/**\n * Computes a 4-by-4 orthogonal transformation matrix that transforms from\n * the given the left, right, bottom, and top dimensions to -1 +1 in x, and y\n * and 0 to +1 in z.\n * @param left - Left side of the near clipping plane viewport.\n * @param right - Right side of the near clipping plane viewport.\n * @param bottom - Bottom of the near clipping plane viewport.\n * @param top - Top of the near clipping plane viewport.\n * @param near - The depth (negative z coordinate)\n *     of the near clipping plane.\n * @param far - The depth (negative z coordinate)\n *     of the far clipping plane.\n * @param dst - Output matrix. If not passed a new one is created.\n * @returns The orthographic projection matrix.\n */\nfunction ortho(left, right, bottom, top, near, far, dst) {\n    dst = dst || new MatType(16);\n    dst[0] = 2 / (right - left);\n    dst[1] = 0;\n    dst[2] = 0;\n    dst[3] = 0;\n    dst[4] = 0;\n    dst[5] = 2 / (top - bottom);\n    dst[6] = 0;\n    dst[7] = 0;\n    dst[8] = 0;\n    dst[9] = 0;\n    dst[10] = 1 / (near - far);\n    dst[11] = 0;\n    dst[12] = (right + left) / (left - right);\n    dst[13] = (top + bottom) / (bottom - top);\n    dst[14] = near / (near - far);\n    dst[15] = 1;\n    return dst;\n}\n/**\n * Computes a 4-by-4 perspective transformation matrix given the left, right,\n * top, bottom, near and far clipping planes. The arguments define a frustum\n * extending in the negative z direction. The arguments near and far are the\n * distances to the near and far clipping planes. Note that near and far are not\n * z coordinates, but rather they are distances along the negative z-axis. The\n * matrix generated sends the viewing frustum to the unit box. We assume a unit\n * box extending from -1 to 1 in the x and y dimensions and from 0 to 1 in the z\n * dimension.\n * @param left - The x coordinate of the left plane of the box.\n * @param right - The x coordinate of the right plane of the box.\n * @param bottom - The y coordinate of the bottom plane of the box.\n * @param top - The y coordinate of the right plane of the box.\n * @param near - The negative z coordinate of the near plane of the box.\n * @param far - The negative z coordinate of the far plane of the box.\n * @param dst - Output matrix. If not passed a new one is created.\n * @returns The perspective projection matrix.\n */\nfunction frustum(left, right, bottom, top, near, far, dst) {\n    dst = dst || new MatType(16);\n    const dx = (right - left);\n    const dy = (top - bottom);\n    const dz = (near - far);\n    dst[0] = 2 * near / dx;\n    dst[1] = 0;\n    dst[2] = 0;\n    dst[3] = 0;\n    dst[4] = 0;\n    dst[5] = 2 * near / dy;\n    dst[6] = 0;\n    dst[7] = 0;\n    dst[8] = (left + right) / dx;\n    dst[9] = (top + bottom) / dy;\n    dst[10] = far / dz;\n    dst[11] = -1;\n    dst[12] = 0;\n    dst[13] = 0;\n    dst[14] = near * far / dz;\n    dst[15] = 0;\n    return dst;\n}\n/**\n * Computes a 4-by-4 reverse-z perspective transformation matrix given the left, right,\n * top, bottom, near and far clipping planes. The arguments define a frustum\n * extending in the negative z direction. The arguments near and far are the\n * distances to the near and far clipping planes. Note that near and far are not\n * z coordinates, but rather they are distances along the negative z-axis. The\n * matrix generated sends the viewing frustum to the unit box. We assume a unit\n * box extending from -1 to 1 in the x and y dimensions and from 1 (-near) to 0 (-far) in the z\n * dimension.\n * @param left - The x coordinate of the left plane of the box.\n * @param right - The x coordinate of the right plane of the box.\n * @param bottom - The y coordinate of the bottom plane of the box.\n * @param top - The y coordinate of the right plane of the box.\n * @param near - The negative z coordinate of the near plane of the box.\n * @param far - The negative z coordinate of the far plane of the box.\n * @param dst - Output matrix. If not passed a new one is created.\n * @returns The perspective projection matrix.\n */\nfunction frustumReverseZ(left, right, bottom, top, near, far = Infinity, dst) {\n    dst = dst || new MatType(16);\n    const dx = (right - left);\n    const dy = (top - bottom);\n    dst[0] = 2 * near / dx;\n    dst[1] = 0;\n    dst[2] = 0;\n    dst[3] = 0;\n    dst[4] = 0;\n    dst[5] = 2 * near / dy;\n    dst[6] = 0;\n    dst[7] = 0;\n    dst[8] = (left + right) / dx;\n    dst[9] = (top + bottom) / dy;\n    dst[11] = -1;\n    dst[12] = 0;\n    dst[13] = 0;\n    dst[15] = 0;\n    if (far === Infinity) {\n        dst[10] = 0;\n        dst[14] = near;\n    }\n    else {\n        const rangeInv = 1 / (far - near);\n        dst[10] = near * rangeInv;\n        dst[14] = far * near * rangeInv;\n    }\n    return dst;\n}\nlet xAxis;\nlet yAxis;\nlet zAxis;\n/**\n * Computes a 4-by-4 aim transformation.\n *\n * This is a matrix which positions an object aiming down positive Z.\n * toward the target.\n *\n * Note: this is **NOT** the inverse of lookAt as lookAt looks at negative Z.\n *\n * @param position - The position of the object.\n * @param target - The position meant to be aimed at.\n * @param up - A vector pointing up.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The aim matrix.\n */\nfunction aim(position, target, up, dst) {\n    dst = dst || new MatType(16);\n    xAxis = xAxis || create$4();\n    yAxis = yAxis || create$4();\n    zAxis = zAxis || create$4();\n    normalize$2(subtract$2(target, position, zAxis), zAxis);\n    normalize$2(cross(up, zAxis, xAxis), xAxis);\n    normalize$2(cross(zAxis, xAxis, yAxis), yAxis);\n    dst[0] = xAxis[0];\n    dst[1] = xAxis[1];\n    dst[2] = xAxis[2];\n    dst[3] = 0;\n    dst[4] = yAxis[0];\n    dst[5] = yAxis[1];\n    dst[6] = yAxis[2];\n    dst[7] = 0;\n    dst[8] = zAxis[0];\n    dst[9] = zAxis[1];\n    dst[10] = zAxis[2];\n    dst[11] = 0;\n    dst[12] = position[0];\n    dst[13] = position[1];\n    dst[14] = position[2];\n    dst[15] = 1;\n    return dst;\n}\n/**\n * Computes a 4-by-4 camera aim transformation.\n *\n * This is a matrix which positions an object aiming down negative Z.\n * toward the target.\n *\n * Note: this is the inverse of `lookAt`\n *\n * @param eye - The position of the object.\n * @param target - The position meant to be aimed at.\n * @param up - A vector pointing up.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The aim matrix.\n */\nfunction cameraAim(eye, target, up, dst) {\n    dst = dst || new MatType(16);\n    xAxis = xAxis || create$4();\n    yAxis = yAxis || create$4();\n    zAxis = zAxis || create$4();\n    normalize$2(subtract$2(eye, target, zAxis), zAxis);\n    normalize$2(cross(up, zAxis, xAxis), xAxis);\n    normalize$2(cross(zAxis, xAxis, yAxis), yAxis);\n    dst[0] = xAxis[0];\n    dst[1] = xAxis[1];\n    dst[2] = xAxis[2];\n    dst[3] = 0;\n    dst[4] = yAxis[0];\n    dst[5] = yAxis[1];\n    dst[6] = yAxis[2];\n    dst[7] = 0;\n    dst[8] = zAxis[0];\n    dst[9] = zAxis[1];\n    dst[10] = zAxis[2];\n    dst[11] = 0;\n    dst[12] = eye[0];\n    dst[13] = eye[1];\n    dst[14] = eye[2];\n    dst[15] = 1;\n    return dst;\n}\n/**\n * Computes a 4-by-4 view transformation.\n *\n * This is a view matrix which transforms all other objects\n * to be in the space of the view defined by the parameters.\n *\n * @param eye - The position of the object.\n * @param target - The position meant to be aimed at.\n * @param up - A vector pointing up.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The look-at matrix.\n */\nfunction lookAt(eye, target, up, dst) {\n    dst = dst || new MatType(16);\n    xAxis = xAxis || create$4();\n    yAxis = yAxis || create$4();\n    zAxis = zAxis || create$4();\n    normalize$2(subtract$2(eye, target, zAxis), zAxis);\n    normalize$2(cross(up, zAxis, xAxis), xAxis);\n    normalize$2(cross(zAxis, xAxis, yAxis), yAxis);\n    dst[0] = xAxis[0];\n    dst[1] = yAxis[0];\n    dst[2] = zAxis[0];\n    dst[3] = 0;\n    dst[4] = xAxis[1];\n    dst[5] = yAxis[1];\n    dst[6] = zAxis[1];\n    dst[7] = 0;\n    dst[8] = xAxis[2];\n    dst[9] = yAxis[2];\n    dst[10] = zAxis[2];\n    dst[11] = 0;\n    dst[12] = -(xAxis[0] * eye[0] + xAxis[1] * eye[1] + xAxis[2] * eye[2]);\n    dst[13] = -(yAxis[0] * eye[0] + yAxis[1] * eye[1] + yAxis[2] * eye[2]);\n    dst[14] = -(zAxis[0] * eye[0] + zAxis[1] * eye[1] + zAxis[2] * eye[2]);\n    dst[15] = 1;\n    return dst;\n}\n/**\n * Creates a 4-by-4 matrix which translates by the given vector v.\n * @param v - The vector by\n *     which to translate.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The translation matrix.\n */\nfunction translation(v, dst) {\n    dst = dst || new MatType(16);\n    dst[0] = 1;\n    dst[1] = 0;\n    dst[2] = 0;\n    dst[3] = 0;\n    dst[4] = 0;\n    dst[5] = 1;\n    dst[6] = 0;\n    dst[7] = 0;\n    dst[8] = 0;\n    dst[9] = 0;\n    dst[10] = 1;\n    dst[11] = 0;\n    dst[12] = v[0];\n    dst[13] = v[1];\n    dst[14] = v[2];\n    dst[15] = 1;\n    return dst;\n}\n/**\n * Translates the given 4-by-4 matrix by the given vector v.\n * @param m - The matrix.\n * @param v - The vector by\n *     which to translate.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The translated matrix.\n */\nfunction translate(m, v, dst) {\n    dst = dst || new MatType(16);\n    const v0 = v[0];\n    const v1 = v[1];\n    const v2 = v[2];\n    const m00 = m[0];\n    const m01 = m[1];\n    const m02 = m[2];\n    const m03 = m[3];\n    const m10 = m[1 * 4 + 0];\n    const m11 = m[1 * 4 + 1];\n    const m12 = m[1 * 4 + 2];\n    const m13 = m[1 * 4 + 3];\n    const m20 = m[2 * 4 + 0];\n    const m21 = m[2 * 4 + 1];\n    const m22 = m[2 * 4 + 2];\n    const m23 = m[2 * 4 + 3];\n    const m30 = m[3 * 4 + 0];\n    const m31 = m[3 * 4 + 1];\n    const m32 = m[3 * 4 + 2];\n    const m33 = m[3 * 4 + 3];\n    if (m !== dst) {\n        dst[0] = m00;\n        dst[1] = m01;\n        dst[2] = m02;\n        dst[3] = m03;\n        dst[4] = m10;\n        dst[5] = m11;\n        dst[6] = m12;\n        dst[7] = m13;\n        dst[8] = m20;\n        dst[9] = m21;\n        dst[10] = m22;\n        dst[11] = m23;\n    }\n    dst[12] = m00 * v0 + m10 * v1 + m20 * v2 + m30;\n    dst[13] = m01 * v0 + m11 * v1 + m21 * v2 + m31;\n    dst[14] = m02 * v0 + m12 * v1 + m22 * v2 + m32;\n    dst[15] = m03 * v0 + m13 * v1 + m23 * v2 + m33;\n    return dst;\n}\n/**\n * Creates a 4-by-4 matrix which rotates around the x-axis by the given angle.\n * @param angleInRadians - The angle by which to rotate (in radians).\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The rotation matrix.\n */\nfunction rotationX(angleInRadians, dst) {\n    dst = dst || new MatType(16);\n    const c = Math.cos(angleInRadians);\n    const s = Math.sin(angleInRadians);\n    dst[0] = 1;\n    dst[1] = 0;\n    dst[2] = 0;\n    dst[3] = 0;\n    dst[4] = 0;\n    dst[5] = c;\n    dst[6] = s;\n    dst[7] = 0;\n    dst[8] = 0;\n    dst[9] = -s;\n    dst[10] = c;\n    dst[11] = 0;\n    dst[12] = 0;\n    dst[13] = 0;\n    dst[14] = 0;\n    dst[15] = 1;\n    return dst;\n}\n/**\n * Rotates the given 4-by-4 matrix around the x-axis by the given\n * angle.\n * @param m - The matrix.\n * @param angleInRadians - The angle by which to rotate (in radians).\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The rotated matrix.\n */\nfunction rotateX$1(m, angleInRadians, dst) {\n    dst = dst || new MatType(16);\n    const m10 = m[4];\n    const m11 = m[5];\n    const m12 = m[6];\n    const m13 = m[7];\n    const m20 = m[8];\n    const m21 = m[9];\n    const m22 = m[10];\n    const m23 = m[11];\n    const c = Math.cos(angleInRadians);\n    const s = Math.sin(angleInRadians);\n    dst[4] = c * m10 + s * m20;\n    dst[5] = c * m11 + s * m21;\n    dst[6] = c * m12 + s * m22;\n    dst[7] = c * m13 + s * m23;\n    dst[8] = c * m20 - s * m10;\n    dst[9] = c * m21 - s * m11;\n    dst[10] = c * m22 - s * m12;\n    dst[11] = c * m23 - s * m13;\n    if (m !== dst) {\n        dst[0] = m[0];\n        dst[1] = m[1];\n        dst[2] = m[2];\n        dst[3] = m[3];\n        dst[12] = m[12];\n        dst[13] = m[13];\n        dst[14] = m[14];\n        dst[15] = m[15];\n    }\n    return dst;\n}\n/**\n * Creates a 4-by-4 matrix which rotates around the y-axis by the given angle.\n * @param angleInRadians - The angle by which to rotate (in radians).\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The rotation matrix.\n */\nfunction rotationY(angleInRadians, dst) {\n    dst = dst || new MatType(16);\n    const c = Math.cos(angleInRadians);\n    const s = Math.sin(angleInRadians);\n    dst[0] = c;\n    dst[1] = 0;\n    dst[2] = -s;\n    dst[3] = 0;\n    dst[4] = 0;\n    dst[5] = 1;\n    dst[6] = 0;\n    dst[7] = 0;\n    dst[8] = s;\n    dst[9] = 0;\n    dst[10] = c;\n    dst[11] = 0;\n    dst[12] = 0;\n    dst[13] = 0;\n    dst[14] = 0;\n    dst[15] = 1;\n    return dst;\n}\n/**\n * Rotates the given 4-by-4 matrix around the y-axis by the given\n * angle.\n * @param m - The matrix.\n * @param angleInRadians - The angle by which to rotate (in radians).\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The rotated matrix.\n */\nfunction rotateY$1(m, angleInRadians, dst) {\n    dst = dst || new MatType(16);\n    const m00 = m[0 * 4 + 0];\n    const m01 = m[0 * 4 + 1];\n    const m02 = m[0 * 4 + 2];\n    const m03 = m[0 * 4 + 3];\n    const m20 = m[2 * 4 + 0];\n    const m21 = m[2 * 4 + 1];\n    const m22 = m[2 * 4 + 2];\n    const m23 = m[2 * 4 + 3];\n    const c = Math.cos(angleInRadians);\n    const s = Math.sin(angleInRadians);\n    dst[0] = c * m00 - s * m20;\n    dst[1] = c * m01 - s * m21;\n    dst[2] = c * m02 - s * m22;\n    dst[3] = c * m03 - s * m23;\n    dst[8] = c * m20 + s * m00;\n    dst[9] = c * m21 + s * m01;\n    dst[10] = c * m22 + s * m02;\n    dst[11] = c * m23 + s * m03;\n    if (m !== dst) {\n        dst[4] = m[4];\n        dst[5] = m[5];\n        dst[6] = m[6];\n        dst[7] = m[7];\n        dst[12] = m[12];\n        dst[13] = m[13];\n        dst[14] = m[14];\n        dst[15] = m[15];\n    }\n    return dst;\n}\n/**\n * Creates a 4-by-4 matrix which rotates around the z-axis by the given angle.\n * @param angleInRadians - The angle by which to rotate (in radians).\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The rotation matrix.\n */\nfunction rotationZ(angleInRadians, dst) {\n    dst = dst || new MatType(16);\n    const c = Math.cos(angleInRadians);\n    const s = Math.sin(angleInRadians);\n    dst[0] = c;\n    dst[1] = s;\n    dst[2] = 0;\n    dst[3] = 0;\n    dst[4] = -s;\n    dst[5] = c;\n    dst[6] = 0;\n    dst[7] = 0;\n    dst[8] = 0;\n    dst[9] = 0;\n    dst[10] = 1;\n    dst[11] = 0;\n    dst[12] = 0;\n    dst[13] = 0;\n    dst[14] = 0;\n    dst[15] = 1;\n    return dst;\n}\n/**\n * Rotates the given 4-by-4 matrix around the z-axis by the given\n * angle.\n * @param m - The matrix.\n * @param angleInRadians - The angle by which to rotate (in radians).\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The rotated matrix.\n */\nfunction rotateZ$1(m, angleInRadians, dst) {\n    dst = dst || new MatType(16);\n    const m00 = m[0 * 4 + 0];\n    const m01 = m[0 * 4 + 1];\n    const m02 = m[0 * 4 + 2];\n    const m03 = m[0 * 4 + 3];\n    const m10 = m[1 * 4 + 0];\n    const m11 = m[1 * 4 + 1];\n    const m12 = m[1 * 4 + 2];\n    const m13 = m[1 * 4 + 3];\n    const c = Math.cos(angleInRadians);\n    const s = Math.sin(angleInRadians);\n    dst[0] = c * m00 + s * m10;\n    dst[1] = c * m01 + s * m11;\n    dst[2] = c * m02 + s * m12;\n    dst[3] = c * m03 + s * m13;\n    dst[4] = c * m10 - s * m00;\n    dst[5] = c * m11 - s * m01;\n    dst[6] = c * m12 - s * m02;\n    dst[7] = c * m13 - s * m03;\n    if (m !== dst) {\n        dst[8] = m[8];\n        dst[9] = m[9];\n        dst[10] = m[10];\n        dst[11] = m[11];\n        dst[12] = m[12];\n        dst[13] = m[13];\n        dst[14] = m[14];\n        dst[15] = m[15];\n    }\n    return dst;\n}\n/**\n * Creates a 4-by-4 matrix which rotates around the given axis by the given\n * angle.\n * @param axis - The axis\n *     about which to rotate.\n * @param angleInRadians - The angle by which to rotate (in radians).\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns A matrix which rotates angle radians\n *     around the axis.\n */\nfunction axisRotation(axis, angleInRadians, dst) {\n    dst = dst || new MatType(16);\n    let x = axis[0];\n    let y = axis[1];\n    let z = axis[2];\n    const n = Math.sqrt(x * x + y * y + z * z);\n    x /= n;\n    y /= n;\n    z /= n;\n    const xx = x * x;\n    const yy = y * y;\n    const zz = z * z;\n    const c = Math.cos(angleInRadians);\n    const s = Math.sin(angleInRadians);\n    const oneMinusCosine = 1 - c;\n    dst[0] = xx + (1 - xx) * c;\n    dst[1] = x * y * oneMinusCosine + z * s;\n    dst[2] = x * z * oneMinusCosine - y * s;\n    dst[3] = 0;\n    dst[4] = x * y * oneMinusCosine - z * s;\n    dst[5] = yy + (1 - yy) * c;\n    dst[6] = y * z * oneMinusCosine + x * s;\n    dst[7] = 0;\n    dst[8] = x * z * oneMinusCosine + y * s;\n    dst[9] = y * z * oneMinusCosine - x * s;\n    dst[10] = zz + (1 - zz) * c;\n    dst[11] = 0;\n    dst[12] = 0;\n    dst[13] = 0;\n    dst[14] = 0;\n    dst[15] = 1;\n    return dst;\n}\n/**\n * Creates a 4-by-4 matrix which rotates around the given axis by the given\n * angle. (same as axisRotation)\n * @param axis - The axis\n *     about which to rotate.\n * @param angleInRadians - The angle by which to rotate (in radians).\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns A matrix which rotates angle radians\n *     around the axis.\n */\nconst rotation = axisRotation;\n/**\n * Rotates the given 4-by-4 matrix around the given axis by the\n * given angle.\n * @param m - The matrix.\n * @param axis - The axis\n *     about which to rotate.\n * @param angleInRadians - The angle by which to rotate (in radians).\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The rotated matrix.\n */\nfunction axisRotate(m, axis, angleInRadians, dst) {\n    dst = dst || new MatType(16);\n    let x = axis[0];\n    let y = axis[1];\n    let z = axis[2];\n    const n = Math.sqrt(x * x + y * y + z * z);\n    x /= n;\n    y /= n;\n    z /= n;\n    const xx = x * x;\n    const yy = y * y;\n    const zz = z * z;\n    const c = Math.cos(angleInRadians);\n    const s = Math.sin(angleInRadians);\n    const oneMinusCosine = 1 - c;\n    const r00 = xx + (1 - xx) * c;\n    const r01 = x * y * oneMinusCosine + z * s;\n    const r02 = x * z * oneMinusCosine - y * s;\n    const r10 = x * y * oneMinusCosine - z * s;\n    const r11 = yy + (1 - yy) * c;\n    const r12 = y * z * oneMinusCosine + x * s;\n    const r20 = x * z * oneMinusCosine + y * s;\n    const r21 = y * z * oneMinusCosine - x * s;\n    const r22 = zz + (1 - zz) * c;\n    const m00 = m[0];\n    const m01 = m[1];\n    const m02 = m[2];\n    const m03 = m[3];\n    const m10 = m[4];\n    const m11 = m[5];\n    const m12 = m[6];\n    const m13 = m[7];\n    const m20 = m[8];\n    const m21 = m[9];\n    const m22 = m[10];\n    const m23 = m[11];\n    dst[0] = r00 * m00 + r01 * m10 + r02 * m20;\n    dst[1] = r00 * m01 + r01 * m11 + r02 * m21;\n    dst[2] = r00 * m02 + r01 * m12 + r02 * m22;\n    dst[3] = r00 * m03 + r01 * m13 + r02 * m23;\n    dst[4] = r10 * m00 + r11 * m10 + r12 * m20;\n    dst[5] = r10 * m01 + r11 * m11 + r12 * m21;\n    dst[6] = r10 * m02 + r11 * m12 + r12 * m22;\n    dst[7] = r10 * m03 + r11 * m13 + r12 * m23;\n    dst[8] = r20 * m00 + r21 * m10 + r22 * m20;\n    dst[9] = r20 * m01 + r21 * m11 + r22 * m21;\n    dst[10] = r20 * m02 + r21 * m12 + r22 * m22;\n    dst[11] = r20 * m03 + r21 * m13 + r22 * m23;\n    if (m !== dst) {\n        dst[12] = m[12];\n        dst[13] = m[13];\n        dst[14] = m[14];\n        dst[15] = m[15];\n    }\n    return dst;\n}\n/**\n * Rotates the given 4-by-4 matrix around the given axis by the\n * given angle. (same as rotate)\n * @param m - The matrix.\n * @param axis - The axis\n *     about which to rotate.\n * @param angleInRadians - The angle by which to rotate (in radians).\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The rotated matrix.\n */\nconst rotate = axisRotate;\n/**\n * Creates a 4-by-4 matrix which scales in each dimension by an amount given by\n * the corresponding entry in the given vector; assumes the vector has three\n * entries.\n * @param v - A vector of\n *     three entries specifying the factor by which to scale in each dimension.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The scaling matrix.\n */\nfunction scaling(v, dst) {\n    dst = dst || new MatType(16);\n    dst[0] = v[0];\n    dst[1] = 0;\n    dst[2] = 0;\n    dst[3] = 0;\n    dst[4] = 0;\n    dst[5] = v[1];\n    dst[6] = 0;\n    dst[7] = 0;\n    dst[8] = 0;\n    dst[9] = 0;\n    dst[10] = v[2];\n    dst[11] = 0;\n    dst[12] = 0;\n    dst[13] = 0;\n    dst[14] = 0;\n    dst[15] = 1;\n    return dst;\n}\n/**\n * Scales the given 4-by-4 matrix in each dimension by an amount\n * given by the corresponding entry in the given vector; assumes the vector has\n * three entries.\n * @param m - The matrix to be modified.\n * @param v - A vector of three entries specifying the\n *     factor by which to scale in each dimension.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The scaled matrix.\n */\nfunction scale$2(m, v, dst) {\n    dst = dst || new MatType(16);\n    const v0 = v[0];\n    const v1 = v[1];\n    const v2 = v[2];\n    dst[0] = v0 * m[0 * 4 + 0];\n    dst[1] = v0 * m[0 * 4 + 1];\n    dst[2] = v0 * m[0 * 4 + 2];\n    dst[3] = v0 * m[0 * 4 + 3];\n    dst[4] = v1 * m[1 * 4 + 0];\n    dst[5] = v1 * m[1 * 4 + 1];\n    dst[6] = v1 * m[1 * 4 + 2];\n    dst[7] = v1 * m[1 * 4 + 3];\n    dst[8] = v2 * m[2 * 4 + 0];\n    dst[9] = v2 * m[2 * 4 + 1];\n    dst[10] = v2 * m[2 * 4 + 2];\n    dst[11] = v2 * m[2 * 4 + 3];\n    if (m !== dst) {\n        dst[12] = m[12];\n        dst[13] = m[13];\n        dst[14] = m[14];\n        dst[15] = m[15];\n    }\n    return dst;\n}\n/**\n * Creates a 4-by-4 matrix which scales a uniform amount in each dimension.\n * @param s - the amount to scale\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The scaling matrix.\n */\nfunction uniformScaling(s, dst) {\n    dst = dst || new MatType(16);\n    dst[0] = s;\n    dst[1] = 0;\n    dst[2] = 0;\n    dst[3] = 0;\n    dst[4] = 0;\n    dst[5] = s;\n    dst[6] = 0;\n    dst[7] = 0;\n    dst[8] = 0;\n    dst[9] = 0;\n    dst[10] = s;\n    dst[11] = 0;\n    dst[12] = 0;\n    dst[13] = 0;\n    dst[14] = 0;\n    dst[15] = 1;\n    return dst;\n}\n/**\n * Scales the given 4-by-4 matrix in each dimension by a uniform scale.\n * @param m - The matrix to be modified.\n * @param s - The amount to scale.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The scaled matrix.\n */\nfunction uniformScale(m, s, dst) {\n    dst = dst || new MatType(16);\n    dst[0] = s * m[0 * 4 + 0];\n    dst[1] = s * m[0 * 4 + 1];\n    dst[2] = s * m[0 * 4 + 2];\n    dst[3] = s * m[0 * 4 + 3];\n    dst[4] = s * m[1 * 4 + 0];\n    dst[5] = s * m[1 * 4 + 1];\n    dst[6] = s * m[1 * 4 + 2];\n    dst[7] = s * m[1 * 4 + 3];\n    dst[8] = s * m[2 * 4 + 0];\n    dst[9] = s * m[2 * 4 + 1];\n    dst[10] = s * m[2 * 4 + 2];\n    dst[11] = s * m[2 * 4 + 3];\n    if (m !== dst) {\n        dst[12] = m[12];\n        dst[13] = m[13];\n        dst[14] = m[14];\n        dst[15] = m[15];\n    }\n    return dst;\n}\n\nvar mat4Impl = {\n    __proto__: null,\n    aim: aim,\n    axisRotate: axisRotate,\n    axisRotation: axisRotation,\n    cameraAim: cameraAim,\n    clone: clone$2,\n    copy: copy$2,\n    create: create$2,\n    determinant: determinant,\n    equals: equals$2,\n    equalsApproximately: equalsApproximately$2,\n    fromMat3: fromMat3,\n    fromQuat: fromQuat,\n    frustum: frustum,\n    frustumReverseZ: frustumReverseZ,\n    getAxis: getAxis,\n    getScaling: getScaling,\n    getTranslation: getTranslation,\n    identity: identity$1,\n    inverse: inverse$2,\n    invert: invert$1,\n    lookAt: lookAt,\n    mul: mul$2,\n    multiply: multiply$2,\n    negate: negate$1,\n    ortho: ortho,\n    perspective: perspective,\n    perspectiveReverseZ: perspectiveReverseZ,\n    rotate: rotate,\n    rotateX: rotateX$1,\n    rotateY: rotateY$1,\n    rotateZ: rotateZ$1,\n    rotation: rotation,\n    rotationX: rotationX,\n    rotationY: rotationY,\n    rotationZ: rotationZ,\n    scale: scale$2,\n    scaling: scaling,\n    set: set$2,\n    setAxis: setAxis,\n    setDefaultType: setDefaultType$3,\n    setTranslation: setTranslation,\n    translate: translate,\n    translation: translation,\n    transpose: transpose,\n    uniformScale: uniformScale,\n    uniformScaling: uniformScaling\n};\n\n/*\n * Copyright 2022 Gregg Tavares\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n/**\n *\n * Quat4 math functions.\n *\n * Almost all functions take an optional `dst` argument. If it is not passed in the\n * functions will create a new `Quat4`. In other words you can do this\n *\n *     const v = quat4.cross(v1, v2);  // Creates a new Quat4 with the cross product of v1 x v2.\n *\n * or\n *\n *     const v = quat4.create();\n *     quat4.cross(v1, v2, v);  // Puts the cross product of v1 x v2 in v\n *\n * The first style is often easier but depending on where it's used it generates garbage where\n * as there is almost never allocation with the second style.\n *\n * It is always safe to pass any vector as the destination. So for example\n *\n *     quat4.cross(v1, v2, v1);  // Puts the cross product of v1 x v2 in v1\n *\n */\nlet QuatType = Float32Array;\n/**\n * Sets the type this library creates for a Quat4\n * @param ctor - the constructor for the type. Either `Float32Array`, `Float64Array`, or `Array`\n * @returns previous constructor for Quat4\n */\nfunction setDefaultType$2(ctor) {\n    const oldType = QuatType;\n    QuatType = ctor;\n    return oldType;\n}\n/**\n * Creates a quat4; may be called with x, y, z to set initial values.\n * @param x - Initial x value.\n * @param y - Initial y value.\n * @param z - Initial z value.\n * @param w - Initial w value.\n * @returns the created vector\n */\nfunction create$1(x, y, z, w) {\n    const dst = new QuatType(4);\n    if (x !== undefined) {\n        dst[0] = x;\n        if (y !== undefined) {\n            dst[1] = y;\n            if (z !== undefined) {\n                dst[2] = z;\n                if (w !== undefined) {\n                    dst[3] = w;\n                }\n            }\n        }\n    }\n    return dst;\n}\n\n/*\n * Copyright 2022 Gregg Tavares\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n/**\n * Creates a Quat; may be called with x, y, z to set initial values. (same as create)\n * @param x - Initial x value.\n * @param y - Initial y value.\n * @param z - Initial z value.\n * @param z - Initial w value.\n * @returns the created vector\n */\nconst fromValues$1 = create$1;\n/**\n * Sets the values of a Quat\n * Also see {@link quat.create} and {@link quat.copy}\n *\n * @param x first value\n * @param y second value\n * @param z third value\n * @param w fourth value\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector with its elements set.\n */\nfunction set$1(x, y, z, w, dst) {\n    dst = dst || new QuatType(4);\n    dst[0] = x;\n    dst[1] = y;\n    dst[2] = z;\n    dst[3] = w;\n    return dst;\n}\n/**\n * Sets a quaternion from the given angle and  axis,\n * then returns it.\n *\n * @param axis - the axis to rotate around\n * @param angleInRadians - the angle\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns The quaternion that represents the given axis and angle\n **/\nfunction fromAxisAngle(axis, angleInRadians, dst) {\n    dst = dst || new QuatType(4);\n    const halfAngle = angleInRadians * 0.5;\n    const s = Math.sin(halfAngle);\n    dst[0] = s * axis[0];\n    dst[1] = s * axis[1];\n    dst[2] = s * axis[2];\n    dst[3] = Math.cos(halfAngle);\n    return dst;\n}\n/**\n * Gets the rotation axis and angle\n * @param q - quaternion to compute from\n * @param dst - Vec3 to hold result. If not passed in a new one is created.\n * @return angle and axis\n */\nfunction toAxisAngle(q, dst) {\n    dst = dst || create$4(4);\n    const angle = Math.acos(q[3]) * 2;\n    const s = Math.sin(angle * 0.5);\n    if (s > EPSILON) {\n        dst[0] = q[0] / s;\n        dst[1] = q[1] / s;\n        dst[2] = q[2] / s;\n    }\n    else {\n        dst[0] = 1;\n        dst[1] = 0;\n        dst[2] = 0;\n    }\n    return { angle, axis: dst };\n}\n/**\n * Returns the angle in degrees between two rotations a and b.\n * @param a - quaternion a\n * @param b - quaternion b\n * @return angle in radians between the two quaternions\n */\nfunction angle(a, b) {\n    const d = dot$1(a, b);\n    return Math.acos(2 * d * d - 1);\n}\n/**\n * Multiplies two quaternions\n *\n * @param a - the first quaternion\n * @param b - the second quaternion\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns A quaternion that is the result of a * b\n */\nfunction multiply$1(a, b, dst) {\n    dst = dst || new QuatType(4);\n    const ax = a[0];\n    const ay = a[1];\n    const az = a[2];\n    const aw = a[3];\n    const bx = b[0];\n    const by = b[1];\n    const bz = b[2];\n    const bw = b[3];\n    dst[0] = ax * bw + aw * bx + ay * bz - az * by;\n    dst[1] = ay * bw + aw * by + az * bx - ax * bz;\n    dst[2] = az * bw + aw * bz + ax * by - ay * bx;\n    dst[3] = aw * bw - ax * bx - ay * by - az * bz;\n    return dst;\n}\n/**\n * Multiplies two quaternions\n *\n * @param a - the first quaternion\n * @param b - the second quaternion\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns A quaternion that is the result of a * b\n */\nconst mul$1 = multiply$1;\n/**\n * Rotates the given quaternion around the X axis by the given angle.\n * @param q - quaternion to rotate\n * @param angleInRadians - The angle by which to rotate\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns A quaternion that is the result of a * b\n */\nfunction rotateX(q, angleInRadians, dst) {\n    dst = dst || new QuatType(4);\n    const halfAngle = angleInRadians * 0.5;\n    const qx = q[0];\n    const qy = q[1];\n    const qz = q[2];\n    const qw = q[3];\n    const bx = Math.sin(halfAngle);\n    const bw = Math.cos(halfAngle);\n    dst[0] = qx * bw + qw * bx;\n    dst[1] = qy * bw + qz * bx;\n    dst[2] = qz * bw - qy * bx;\n    dst[3] = qw * bw - qx * bx;\n    return dst;\n}\n/**\n * Rotates the given quaternion around the Y axis by the given angle.\n * @param q - quaternion to rotate\n * @param angleInRadians - The angle by which to rotate\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns A quaternion that is the result of a * b\n */\nfunction rotateY(q, angleInRadians, dst) {\n    dst = dst || new QuatType(4);\n    const halfAngle = angleInRadians * 0.5;\n    const qx = q[0];\n    const qy = q[1];\n    const qz = q[2];\n    const qw = q[3];\n    const by = Math.sin(halfAngle);\n    const bw = Math.cos(halfAngle);\n    dst[0] = qx * bw - qz * by;\n    dst[1] = qy * bw + qw * by;\n    dst[2] = qz * bw + qx * by;\n    dst[3] = qw * bw - qy * by;\n    return dst;\n}\n/**\n * Rotates the given quaternion around the Z axis by the given angle.\n * @param q - quaternion to rotate\n * @param angleInRadians - The angle by which to rotate\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns A quaternion that is the result of a * b\n */\nfunction rotateZ(q, angleInRadians, dst) {\n    dst = dst || new QuatType(4);\n    const halfAngle = angleInRadians * 0.5;\n    const qx = q[0];\n    const qy = q[1];\n    const qz = q[2];\n    const qw = q[3];\n    const bz = Math.sin(halfAngle);\n    const bw = Math.cos(halfAngle);\n    dst[0] = qx * bw + qy * bz;\n    dst[1] = qy * bw - qx * bz;\n    dst[2] = qz * bw + qw * bz;\n    dst[3] = qw * bw - qz * bz;\n    return dst;\n}\n/**\n * Spherically linear interpolate between two quaternions\n *\n * @param a - starting value\n * @param b - ending value\n * @param t - value where 0 = a and 1 = b\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns A quaternion that is the result of a * b\n */\nfunction slerp(a, b, t, dst) {\n    dst = dst || new QuatType(4);\n    const ax = a[0];\n    const ay = a[1];\n    const az = a[2];\n    const aw = a[3];\n    let bx = b[0];\n    let by = b[1];\n    let bz = b[2];\n    let bw = b[3];\n    let cosOmega = ax * bx + ay * by + az * bz + aw * bw;\n    if (cosOmega < 0) {\n        cosOmega = -cosOmega;\n        bx = -bx;\n        by = -by;\n        bz = -bz;\n        bw = -bw;\n    }\n    let scale0;\n    let scale1;\n    if (1.0 - cosOmega > EPSILON) {\n        const omega = Math.acos(cosOmega);\n        const sinOmega = Math.sin(omega);\n        scale0 = Math.sin((1 - t) * omega) / sinOmega;\n        scale1 = Math.sin(t * omega) / sinOmega;\n    }\n    else {\n        scale0 = 1.0 - t;\n        scale1 = t;\n    }\n    dst[0] = scale0 * ax + scale1 * bx;\n    dst[1] = scale0 * ay + scale1 * by;\n    dst[2] = scale0 * az + scale1 * bz;\n    dst[3] = scale0 * aw + scale1 * bw;\n    return dst;\n}\n/**\n * Compute the inverse of a quaternion\n *\n * @param q - quaternion to compute the inverse of\n * @returns A quaternion that is the result of a * b\n */\nfunction inverse$1(q, dst) {\n    dst = dst || new QuatType(4);\n    const a0 = q[0];\n    const a1 = q[1];\n    const a2 = q[2];\n    const a3 = q[3];\n    const dot = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;\n    const invDot = dot ? 1 / dot : 0;\n    dst[0] = -a0 * invDot;\n    dst[1] = -a1 * invDot;\n    dst[2] = -a2 * invDot;\n    dst[3] = a3 * invDot;\n    return dst;\n}\n/**\n * Compute the conjugate of a quaternion\n * For quaternions with a magnitude of 1 (a unit quaternion)\n * this returns the same as the inverse but is faster to calculate.\n *\n * @param q - quaternion to compute the conjugate of.\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns The conjugate of q\n */\nfunction conjugate(q, dst) {\n    dst = dst || new QuatType(4);\n    dst[0] = -q[0];\n    dst[1] = -q[1];\n    dst[2] = -q[2];\n    dst[3] = q[3];\n    return dst;\n}\n/**\n * Creates a quaternion from the given rotation matrix.\n *\n * The created quaternion is not normalized.\n *\n * @param m - rotation matrix\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns the result\n */\nfunction fromMat(m, dst) {\n    dst = dst || new QuatType(4);\n    /*\n    0 1 2\n    3 4 5\n    6 7 8\n  \n    0 1 2\n    4 5 6\n    8 9 10\n     */\n    // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes\n    // article \"Quaternion Calculus and Fast Animation\".\n    const trace = m[0] + m[5] + m[10];\n    if (trace > 0.0) {\n        // |w| > 1/2, may as well choose w > 1/2\n        const root = Math.sqrt(trace + 1); // 2w\n        dst[3] = 0.5 * root;\n        const invRoot = 0.5 / root; // 1/(4w)\n        dst[0] = (m[6] - m[9]) * invRoot;\n        dst[1] = (m[8] - m[2]) * invRoot;\n        dst[2] = (m[1] - m[4]) * invRoot;\n    }\n    else {\n        // |w| <= 1/2\n        let i = 0;\n        if (m[5] > m[0]) {\n            i = 1;\n        }\n        if (m[10] > m[i * 4 + i]) {\n            i = 2;\n        }\n        const j = (i + 1) % 3;\n        const k = (i + 2) % 3;\n        const root = Math.sqrt(m[i * 4 + i] - m[j * 4 + j] - m[k * 4 + k] + 1.0);\n        dst[i] = 0.5 * root;\n        const invRoot = 0.5 / root;\n        dst[3] = (m[j * 4 + k] - m[k * 4 + j]) * invRoot;\n        dst[j] = (m[j * 4 + i] + m[i * 4 + j]) * invRoot;\n        dst[k] = (m[k * 4 + i] + m[i * 4 + k]) * invRoot;\n    }\n    return dst;\n}\n/**\n * Creates a quaternion from the given euler angle x, y, z using the provided intrinsic order for the conversion.\n *\n * @param xAngleInRadians - angle to rotate around X axis in radians.\n * @param yAngleInRadians - angle to rotate around Y axis in radians.\n * @param zAngleInRadians - angle to rotate around Z axis in radians.\n * @param order - order to apply euler angles\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns A quaternion representing the same rotation as the euler angles applied in the given order\n */\nfunction fromEuler(xAngleInRadians, yAngleInRadians, zAngleInRadians, order, dst) {\n    dst = dst || new QuatType(4);\n    const xHalfAngle = xAngleInRadians * 0.5;\n    const yHalfAngle = yAngleInRadians * 0.5;\n    const zHalfAngle = zAngleInRadians * 0.5;\n    const sx = Math.sin(xHalfAngle);\n    const cx = Math.cos(xHalfAngle);\n    const sy = Math.sin(yHalfAngle);\n    const cy = Math.cos(yHalfAngle);\n    const sz = Math.sin(zHalfAngle);\n    const cz = Math.cos(zHalfAngle);\n    switch (order) {\n        case 'xyz':\n            dst[0] = sx * cy * cz + cx * sy * sz;\n            dst[1] = cx * sy * cz - sx * cy * sz;\n            dst[2] = cx * cy * sz + sx * sy * cz;\n            dst[3] = cx * cy * cz - sx * sy * sz;\n            break;\n        case 'xzy':\n            dst[0] = sx * cy * cz - cx * sy * sz;\n            dst[1] = cx * sy * cz - sx * cy * sz;\n            dst[2] = cx * cy * sz + sx * sy * cz;\n            dst[3] = cx * cy * cz + sx * sy * sz;\n            break;\n        case 'yxz':\n            dst[0] = sx * cy * cz + cx * sy * sz;\n            dst[1] = cx * sy * cz - sx * cy * sz;\n            dst[2] = cx * cy * sz - sx * sy * cz;\n            dst[3] = cx * cy * cz + sx * sy * sz;\n            break;\n        case 'yzx':\n            dst[0] = sx * cy * cz + cx * sy * sz;\n            dst[1] = cx * sy * cz + sx * cy * sz;\n            dst[2] = cx * cy * sz - sx * sy * cz;\n            dst[3] = cx * cy * cz - sx * sy * sz;\n            break;\n        case 'zxy':\n            dst[0] = sx * cy * cz - cx * sy * sz;\n            dst[1] = cx * sy * cz + sx * cy * sz;\n            dst[2] = cx * cy * sz + sx * sy * cz;\n            dst[3] = cx * cy * cz - sx * sy * sz;\n            break;\n        case 'zyx':\n            dst[0] = sx * cy * cz - cx * sy * sz;\n            dst[1] = cx * sy * cz + sx * cy * sz;\n            dst[2] = cx * cy * sz - sx * sy * cz;\n            dst[3] = cx * cy * cz + sx * sy * sz;\n            break;\n        default:\n            throw new Error(`Unknown rotation order: ${order}`);\n    }\n    return dst;\n}\n/**\n * Copies a quaternion. (same as {@link quat.clone})\n * Also see {@link quat.create} and {@link quat.set}\n * @param q - The quaternion.\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns A quaternion that is a copy of q\n */\nfunction copy$1(q, dst) {\n    dst = dst || new QuatType(4);\n    dst[0] = q[0];\n    dst[1] = q[1];\n    dst[2] = q[2];\n    dst[3] = q[3];\n    return dst;\n}\n/**\n * Clones a quaternion. (same as {@link quat.copy})\n * Also see {@link quat.create} and {@link quat.set}\n * @param q - The quaternion.\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns A copy of q.\n */\nconst clone$1 = copy$1;\n/**\n * Adds two quaternions; assumes a and b have the same dimension.\n * @param a - Operand quaternion.\n * @param b - Operand quaternion.\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns A quaternion that is the sum of a and b.\n */\nfunction add$1(a, b, dst) {\n    dst = dst || new QuatType(4);\n    dst[0] = a[0] + b[0];\n    dst[1] = a[1] + b[1];\n    dst[2] = a[2] + b[2];\n    dst[3] = a[3] + b[3];\n    return dst;\n}\n/**\n * Subtracts two quaternions.\n * @param a - Operand quaternion.\n * @param b - Operand quaternion.\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns A quaternion that is the difference of a and b.\n */\nfunction subtract$1(a, b, dst) {\n    dst = dst || new QuatType(4);\n    dst[0] = a[0] - b[0];\n    dst[1] = a[1] - b[1];\n    dst[2] = a[2] - b[2];\n    dst[3] = a[3] - b[3];\n    return dst;\n}\n/**\n * Subtracts two quaternions.\n * @param a - Operand quaternion.\n * @param b - Operand quaternion.\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns A quaternion that is the difference of a and b.\n */\nconst sub$1 = subtract$1;\n/**\n * Multiplies a quaternion by a scalar.\n * @param v - The quaternion.\n * @param k - The scalar.\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns The scaled quaternion.\n */\nfunction mulScalar$1(v, k, dst) {\n    dst = dst || new QuatType(4);\n    dst[0] = v[0] * k;\n    dst[1] = v[1] * k;\n    dst[2] = v[2] * k;\n    dst[3] = v[3] * k;\n    return dst;\n}\n/**\n * Multiplies a quaternion by a scalar. (same as mulScalar)\n * @param v - The quaternion.\n * @param k - The scalar.\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns The scaled quaternion.\n */\nconst scale$1 = mulScalar$1;\n/**\n * Divides a vector by a scalar.\n * @param v - The vector.\n * @param k - The scalar.\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns The scaled quaternion.\n */\nfunction divScalar$1(v, k, dst) {\n    dst = dst || new QuatType(4);\n    dst[0] = v[0] / k;\n    dst[1] = v[1] / k;\n    dst[2] = v[2] / k;\n    dst[3] = v[3] / k;\n    return dst;\n}\n/**\n * Computes the dot product of two quaternions\n * @param a - Operand quaternion.\n * @param b - Operand quaternion.\n * @returns dot product\n */\nfunction dot$1(a, b) {\n    return (a[0] * b[0]) + (a[1] * b[1]) + (a[2] * b[2]) + (a[3] * b[3]);\n}\n/**\n * Performs linear interpolation on two quaternions.\n * Given quaternions a and b and interpolation coefficient t, returns\n * a + t * (b - a).\n * @param a - Operand quaternion.\n * @param b - Operand quaternion.\n * @param t - Interpolation coefficient.\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns The linear interpolated result.\n */\nfunction lerp$1(a, b, t, dst) {\n    dst = dst || new QuatType(4);\n    dst[0] = a[0] + t * (b[0] - a[0]);\n    dst[1] = a[1] + t * (b[1] - a[1]);\n    dst[2] = a[2] + t * (b[2] - a[2]);\n    dst[3] = a[3] + t * (b[3] - a[3]);\n    return dst;\n}\n/**\n * Computes the length of quaternion\n * @param v - quaternion.\n * @returns length of quaternion.\n */\nfunction length$1(v) {\n    const v0 = v[0];\n    const v1 = v[1];\n    const v2 = v[2];\n    const v3 = v[3];\n    return Math.sqrt(v0 * v0 + v1 * v1 + v2 * v2 + v3 * v3);\n}\n/**\n * Computes the length of quaternion (same as length)\n * @param v - quaternion.\n * @returns length of quaternion.\n */\nconst len$1 = length$1;\n/**\n * Computes the square of the length of quaternion\n * @param v - quaternion.\n * @returns square of the length of quaternion.\n */\nfunction lengthSq$1(v) {\n    const v0 = v[0];\n    const v1 = v[1];\n    const v2 = v[2];\n    const v3 = v[3];\n    return v0 * v0 + v1 * v1 + v2 * v2 + v3 * v3;\n}\n/**\n * Computes the square of the length of quaternion (same as lengthSq)\n * @param v - quaternion.\n * @returns square of the length of quaternion.\n */\nconst lenSq$1 = lengthSq$1;\n/**\n * Divides a quaternion by its Euclidean length and returns the quotient.\n * @param v - The quaternion.\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns The normalized quaternion.\n */\nfunction normalize$1(v, dst) {\n    dst = dst || new QuatType(4);\n    const v0 = v[0];\n    const v1 = v[1];\n    const v2 = v[2];\n    const v3 = v[3];\n    const len = Math.sqrt(v0 * v0 + v1 * v1 + v2 * v2 + v3 * v3);\n    if (len > 0.00001) {\n        dst[0] = v0 / len;\n        dst[1] = v1 / len;\n        dst[2] = v2 / len;\n        dst[3] = v3 / len;\n    }\n    else {\n        dst[0] = 0;\n        dst[1] = 0;\n        dst[2] = 0;\n        dst[3] = 0;\n    }\n    return dst;\n}\n/**\n * Check if 2 quaternions are approximately equal\n * @param a - Operand quaternion.\n * @param b - Operand quaternion.\n * @returns true if quaternions are approximately equal\n */\nfunction equalsApproximately$1(a, b) {\n    return Math.abs(a[0] - b[0]) < EPSILON &&\n        Math.abs(a[1] - b[1]) < EPSILON &&\n        Math.abs(a[2] - b[2]) < EPSILON &&\n        Math.abs(a[3] - b[3]) < EPSILON;\n}\n/**\n * Check if 2 quaternions are exactly equal\n * @param a - Operand quaternion.\n * @param b - Operand quaternion.\n * @returns true if quaternions are exactly equal\n */\nfunction equals$1(a, b) {\n    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];\n}\n/**\n * Creates an identity quaternion\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns an identity quaternion\n */\nfunction identity(dst) {\n    dst = dst || new QuatType(4);\n    dst[0] = 0;\n    dst[1] = 0;\n    dst[2] = 0;\n    dst[3] = 1;\n    return dst;\n}\nlet tempVec3;\nlet xUnitVec3;\nlet yUnitVec3;\n/**\n * Computes a quaternion to represent the shortest rotation from one vector to another.\n *\n * @param aUnit - the start vector\n * @param bUnit - the end vector\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns the result\n */\nfunction rotationTo(aUnit, bUnit, dst) {\n    dst = dst || new QuatType(4);\n    tempVec3 = tempVec3 || create$4();\n    xUnitVec3 = xUnitVec3 || create$4(1, 0, 0);\n    yUnitVec3 = yUnitVec3 || create$4(0, 1, 0);\n    const dot = dot$2(aUnit, bUnit);\n    if (dot < -0.999999) {\n        cross(xUnitVec3, aUnit, tempVec3);\n        if (len$2(tempVec3) < 0.000001) {\n            cross(yUnitVec3, aUnit, tempVec3);\n        }\n        normalize$2(tempVec3, tempVec3);\n        fromAxisAngle(tempVec3, Math.PI, dst);\n        return dst;\n    }\n    else if (dot > 0.999999) {\n        dst[0] = 0;\n        dst[1] = 0;\n        dst[2] = 0;\n        dst[3] = 1;\n        return dst;\n    }\n    else {\n        cross(aUnit, bUnit, tempVec3);\n        dst[0] = tempVec3[0];\n        dst[1] = tempVec3[1];\n        dst[2] = tempVec3[2];\n        dst[3] = 1 + dot;\n        return normalize$1(dst, dst);\n    }\n}\nlet tempQuat1;\nlet tempQuat2;\n/**\n * Performs a spherical linear interpolation with two control points\n *\n * @param a - the first quaternion\n * @param b - the second quaternion\n * @param c - the third quaternion\n * @param d - the fourth quaternion\n * @param t - Interpolation coefficient 0 to 1\n * @returns result\n */\nfunction sqlerp(a, b, c, d, t, dst) {\n    dst = dst || new QuatType(4);\n    tempQuat1 = tempQuat1 || new QuatType(4);\n    tempQuat2 = tempQuat2 || new QuatType(4);\n    slerp(a, d, t, tempQuat1);\n    slerp(b, c, t, tempQuat2);\n    slerp(tempQuat1, tempQuat2, 2 * t * (1 - t), dst);\n    return dst;\n}\n\nvar quatImpl = {\n    __proto__: null,\n    add: add$1,\n    angle: angle,\n    clone: clone$1,\n    conjugate: conjugate,\n    copy: copy$1,\n    create: create$1,\n    divScalar: divScalar$1,\n    dot: dot$1,\n    equals: equals$1,\n    equalsApproximately: equalsApproximately$1,\n    fromAxisAngle: fromAxisAngle,\n    fromEuler: fromEuler,\n    fromMat: fromMat,\n    fromValues: fromValues$1,\n    identity: identity,\n    inverse: inverse$1,\n    len: len$1,\n    lenSq: lenSq$1,\n    length: length$1,\n    lengthSq: lengthSq$1,\n    lerp: lerp$1,\n    mul: mul$1,\n    mulScalar: mulScalar$1,\n    multiply: multiply$1,\n    normalize: normalize$1,\n    rotateX: rotateX,\n    rotateY: rotateY,\n    rotateZ: rotateZ,\n    rotationTo: rotationTo,\n    scale: scale$1,\n    set: set$1,\n    setDefaultType: setDefaultType$2,\n    slerp: slerp,\n    sqlerp: sqlerp,\n    sub: sub$1,\n    subtract: subtract$1,\n    toAxisAngle: toAxisAngle\n};\n\n/*\n * Copyright 2022 Gregg Tavares\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n/**\n *\n * Vec4 math functions.\n *\n * Almost all functions take an optional `dst` argument. If it is not passed in the\n * functions will create a new `Vec4`. In other words you can do this\n *\n *     const v = vec4.cross(v1, v2);  // Creates a new Vec4 with the cross product of v1 x v2.\n *\n * or\n *\n *     const v = vec4.create();\n *     vec4.cross(v1, v2, v);  // Puts the cross product of v1 x v2 in v\n *\n * The first style is often easier but depending on where it's used it generates garbage where\n * as there is almost never allocation with the second style.\n *\n * It is always safe to pass any vector as the destination. So for example\n *\n *     vec4.cross(v1, v2, v1);  // Puts the cross product of v1 x v2 in v1\n *\n */\nlet VecType = Float32Array;\n/**\n * Sets the type this library creates for a Vec4\n * @param ctor - the constructor for the type. Either `Float32Array`, `Float64Array`, or `Array`\n * @returns previous constructor for Vec4\n */\nfunction setDefaultType$1(ctor) {\n    const oldType = VecType;\n    VecType = ctor;\n    return oldType;\n}\n/**\n * Creates a vec4; may be called with x, y, z to set initial values.\n * @param x - Initial x value.\n * @param y - Initial y value.\n * @param z - Initial z value.\n * @param w - Initial w value.\n * @returns the created vector\n */\nfunction create(x, y, z, w) {\n    const dst = new VecType(4);\n    if (x !== undefined) {\n        dst[0] = x;\n        if (y !== undefined) {\n            dst[1] = y;\n            if (z !== undefined) {\n                dst[2] = z;\n                if (w !== undefined) {\n                    dst[3] = w;\n                }\n            }\n        }\n    }\n    return dst;\n}\n\n/*\n * Copyright 2022 Gregg Tavares\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n/**\n * Creates a vec4; may be called with x, y, z to set initial values. (same as create)\n * @param x - Initial x value.\n * @param y - Initial y value.\n * @param z - Initial z value.\n * @param z - Initial w value.\n * @returns the created vector\n */\nconst fromValues = create;\n/**\n * Sets the values of a Vec4\n * Also see {@link vec4.create} and {@link vec4.copy}\n *\n * @param x first value\n * @param y second value\n * @param z third value\n * @param w fourth value\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector with its elements set.\n */\nfunction set(x, y, z, w, dst) {\n    dst = dst || new VecType(4);\n    dst[0] = x;\n    dst[1] = y;\n    dst[2] = z;\n    dst[3] = w;\n    return dst;\n}\n/**\n * Applies Math.ceil to each element of vector\n * @param v - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the ceil of each element of v.\n */\nfunction ceil(v, dst) {\n    dst = dst || new VecType(4);\n    dst[0] = Math.ceil(v[0]);\n    dst[1] = Math.ceil(v[1]);\n    dst[2] = Math.ceil(v[2]);\n    dst[3] = Math.ceil(v[3]);\n    return dst;\n}\n/**\n * Applies Math.floor to each element of vector\n * @param v - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the floor of each element of v.\n */\nfunction floor(v, dst) {\n    dst = dst || new VecType(4);\n    dst[0] = Math.floor(v[0]);\n    dst[1] = Math.floor(v[1]);\n    dst[2] = Math.floor(v[2]);\n    dst[3] = Math.floor(v[3]);\n    return dst;\n}\n/**\n * Applies Math.round to each element of vector\n * @param v - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the round of each element of v.\n */\nfunction round(v, dst) {\n    dst = dst || new VecType(4);\n    dst[0] = Math.round(v[0]);\n    dst[1] = Math.round(v[1]);\n    dst[2] = Math.round(v[2]);\n    dst[3] = Math.round(v[3]);\n    return dst;\n}\n/**\n * Clamp each element of vector between min and max\n * @param v - Operand vector.\n * @param max - Min value, default 0\n * @param min - Max value, default 1\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that the clamped value of each element of v.\n */\nfunction clamp(v, min = 0, max = 1, dst) {\n    dst = dst || new VecType(4);\n    dst[0] = Math.min(max, Math.max(min, v[0]));\n    dst[1] = Math.min(max, Math.max(min, v[1]));\n    dst[2] = Math.min(max, Math.max(min, v[2]));\n    dst[3] = Math.min(max, Math.max(min, v[3]));\n    return dst;\n}\n/**\n * Adds two vectors; assumes a and b have the same dimension.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the sum of a and b.\n */\nfunction add(a, b, dst) {\n    dst = dst || new VecType(4);\n    dst[0] = a[0] + b[0];\n    dst[1] = a[1] + b[1];\n    dst[2] = a[2] + b[2];\n    dst[3] = a[3] + b[3];\n    return dst;\n}\n/**\n * Adds two vectors, scaling the 2nd; assumes a and b have the same dimension.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param scale - Amount to scale b\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the sum of a + b * scale.\n */\nfunction addScaled(a, b, scale, dst) {\n    dst = dst || new VecType(4);\n    dst[0] = a[0] + b[0] * scale;\n    dst[1] = a[1] + b[1] * scale;\n    dst[2] = a[2] + b[2] * scale;\n    dst[3] = a[3] + b[3] * scale;\n    return dst;\n}\n/**\n * Subtracts two vectors.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the difference of a and b.\n */\nfunction subtract(a, b, dst) {\n    dst = dst || new VecType(4);\n    dst[0] = a[0] - b[0];\n    dst[1] = a[1] - b[1];\n    dst[2] = a[2] - b[2];\n    dst[3] = a[3] - b[3];\n    return dst;\n}\n/**\n * Subtracts two vectors.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the difference of a and b.\n */\nconst sub = subtract;\n/**\n * Check if 2 vectors are approximately equal\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @returns true if vectors are approximately equal\n */\nfunction equalsApproximately(a, b) {\n    return Math.abs(a[0] - b[0]) < EPSILON &&\n        Math.abs(a[1] - b[1]) < EPSILON &&\n        Math.abs(a[2] - b[2]) < EPSILON &&\n        Math.abs(a[3] - b[3]) < EPSILON;\n}\n/**\n * Check if 2 vectors are exactly equal\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @returns true if vectors are exactly equal\n */\nfunction equals(a, b) {\n    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];\n}\n/**\n * Performs linear interpolation on two vectors.\n * Given vectors a and b and interpolation coefficient t, returns\n * a + t * (b - a).\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param t - Interpolation coefficient.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The linear interpolated result.\n */\nfunction lerp(a, b, t, dst) {\n    dst = dst || new VecType(4);\n    dst[0] = a[0] + t * (b[0] - a[0]);\n    dst[1] = a[1] + t * (b[1] - a[1]);\n    dst[2] = a[2] + t * (b[2] - a[2]);\n    dst[3] = a[3] + t * (b[3] - a[3]);\n    return dst;\n}\n/**\n * Performs linear interpolation on two vectors.\n * Given vectors a and b and interpolation coefficient vector t, returns\n * a + t * (b - a).\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param t - Interpolation coefficients vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns the linear interpolated result.\n */\nfunction lerpV(a, b, t, dst) {\n    dst = dst || new VecType(4);\n    dst[0] = a[0] + t[0] * (b[0] - a[0]);\n    dst[1] = a[1] + t[1] * (b[1] - a[1]);\n    dst[2] = a[2] + t[2] * (b[2] - a[2]);\n    dst[3] = a[3] + t[3] * (b[3] - a[3]);\n    return dst;\n}\n/**\n * Return max values of two vectors.\n * Given vectors a and b returns\n * [max(a[0], b[0]), max(a[1], b[1]), max(a[2], b[2])].\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The max components vector.\n */\nfunction max(a, b, dst) {\n    dst = dst || new VecType(4);\n    dst[0] = Math.max(a[0], b[0]);\n    dst[1] = Math.max(a[1], b[1]);\n    dst[2] = Math.max(a[2], b[2]);\n    dst[3] = Math.max(a[3], b[3]);\n    return dst;\n}\n/**\n * Return min values of two vectors.\n * Given vectors a and b returns\n * [min(a[0], b[0]), min(a[1], b[1]), min(a[2], b[2])].\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The min components vector.\n */\nfunction min(a, b, dst) {\n    dst = dst || new VecType(4);\n    dst[0] = Math.min(a[0], b[0]);\n    dst[1] = Math.min(a[1], b[1]);\n    dst[2] = Math.min(a[2], b[2]);\n    dst[3] = Math.min(a[3], b[3]);\n    return dst;\n}\n/**\n * Multiplies a vector by a scalar.\n * @param v - The vector.\n * @param k - The scalar.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The scaled vector.\n */\nfunction mulScalar(v, k, dst) {\n    dst = dst || new VecType(4);\n    dst[0] = v[0] * k;\n    dst[1] = v[1] * k;\n    dst[2] = v[2] * k;\n    dst[3] = v[3] * k;\n    return dst;\n}\n/**\n * Multiplies a vector by a scalar. (same as mulScalar)\n * @param v - The vector.\n * @param k - The scalar.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The scaled vector.\n */\nconst scale = mulScalar;\n/**\n * Divides a vector by a scalar.\n * @param v - The vector.\n * @param k - The scalar.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The scaled vector.\n */\nfunction divScalar(v, k, dst) {\n    dst = dst || new VecType(4);\n    dst[0] = v[0] / k;\n    dst[1] = v[1] / k;\n    dst[2] = v[2] / k;\n    dst[3] = v[3] / k;\n    return dst;\n}\n/**\n * Inverse a vector.\n * @param v - The vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The inverted vector.\n */\nfunction inverse(v, dst) {\n    dst = dst || new VecType(4);\n    dst[0] = 1 / v[0];\n    dst[1] = 1 / v[1];\n    dst[2] = 1 / v[2];\n    dst[3] = 1 / v[3];\n    return dst;\n}\n/**\n * Invert a vector. (same as inverse)\n * @param v - The vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The inverted vector.\n */\nconst invert = inverse;\n/**\n * Computes the dot product of two vectors\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @returns dot product\n */\nfunction dot(a, b) {\n    return (a[0] * b[0]) + (a[1] * b[1]) + (a[2] * b[2]) + (a[3] * b[3]);\n}\n/**\n * Computes the length of vector\n * @param v - vector.\n * @returns length of vector.\n */\nfunction length(v) {\n    const v0 = v[0];\n    const v1 = v[1];\n    const v2 = v[2];\n    const v3 = v[3];\n    return Math.sqrt(v0 * v0 + v1 * v1 + v2 * v2 + v3 * v3);\n}\n/**\n * Computes the length of vector (same as length)\n * @param v - vector.\n * @returns length of vector.\n */\nconst len = length;\n/**\n * Computes the square of the length of vector\n * @param v - vector.\n * @returns square of the length of vector.\n */\nfunction lengthSq(v) {\n    const v0 = v[0];\n    const v1 = v[1];\n    const v2 = v[2];\n    const v3 = v[3];\n    return v0 * v0 + v1 * v1 + v2 * v2 + v3 * v3;\n}\n/**\n * Computes the square of the length of vector (same as lengthSq)\n * @param v - vector.\n * @returns square of the length of vector.\n */\nconst lenSq = lengthSq;\n/**\n * Computes the distance between 2 points\n * @param a - vector.\n * @param b - vector.\n * @returns distance between a and b\n */\nfunction distance(a, b) {\n    const dx = a[0] - b[0];\n    const dy = a[1] - b[1];\n    const dz = a[2] - b[2];\n    const dw = a[3] - b[3];\n    return Math.sqrt(dx * dx + dy * dy + dz * dz + dw * dw);\n}\n/**\n * Computes the distance between 2 points (same as distance)\n * @param a - vector.\n * @param b - vector.\n * @returns distance between a and b\n */\nconst dist = distance;\n/**\n * Computes the square of the distance between 2 points\n * @param a - vector.\n * @param b - vector.\n * @returns square of the distance between a and b\n */\nfunction distanceSq(a, b) {\n    const dx = a[0] - b[0];\n    const dy = a[1] - b[1];\n    const dz = a[2] - b[2];\n    const dw = a[3] - b[3];\n    return dx * dx + dy * dy + dz * dz + dw * dw;\n}\n/**\n * Computes the square of the distance between 2 points (same as distanceSq)\n * @param a - vector.\n * @param b - vector.\n * @returns square of the distance between a and b\n */\nconst distSq = distanceSq;\n/**\n * Divides a vector by its Euclidean length and returns the quotient.\n * @param v - The vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The normalized vector.\n */\nfunction normalize(v, dst) {\n    dst = dst || new VecType(4);\n    const v0 = v[0];\n    const v1 = v[1];\n    const v2 = v[2];\n    const v3 = v[3];\n    const len = Math.sqrt(v0 * v0 + v1 * v1 + v2 * v2 + v3 * v3);\n    if (len > 0.00001) {\n        dst[0] = v0 / len;\n        dst[1] = v1 / len;\n        dst[2] = v2 / len;\n        dst[3] = v3 / len;\n    }\n    else {\n        dst[0] = 0;\n        dst[1] = 0;\n        dst[2] = 0;\n        dst[3] = 0;\n    }\n    return dst;\n}\n/**\n * Negates a vector.\n * @param v - The vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns -v.\n */\nfunction negate(v, dst) {\n    dst = dst || new VecType(4);\n    dst[0] = -v[0];\n    dst[1] = -v[1];\n    dst[2] = -v[2];\n    dst[3] = -v[3];\n    return dst;\n}\n/**\n * Copies a vector. (same as {@link vec4.clone})\n * Also see {@link vec4.create} and {@link vec4.set}\n * @param v - The vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A copy of v.\n */\nfunction copy(v, dst) {\n    dst = dst || new VecType(4);\n    dst[0] = v[0];\n    dst[1] = v[1];\n    dst[2] = v[2];\n    dst[3] = v[3];\n    return dst;\n}\n/**\n * Clones a vector. (same as {@link vec4.copy})\n * Also see {@link vec4.create} and {@link vec4.set}\n * @param v - The vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A copy of v.\n */\nconst clone = copy;\n/**\n * Multiplies a vector by another vector (component-wise); assumes a and\n * b have the same length.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The vector of products of entries of a and b.\n */\nfunction multiply(a, b, dst) {\n    dst = dst || new VecType(4);\n    dst[0] = a[0] * b[0];\n    dst[1] = a[1] * b[1];\n    dst[2] = a[2] * b[2];\n    dst[3] = a[3] * b[3];\n    return dst;\n}\n/**\n * Multiplies a vector by another vector (component-wise); assumes a and\n * b have the same length. (same as mul)\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The vector of products of entries of a and b.\n */\nconst mul = multiply;\n/**\n * Divides a vector by another vector (component-wise); assumes a and\n * b have the same length.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The vector of quotients of entries of a and b.\n */\nfunction divide(a, b, dst) {\n    dst = dst || new VecType(4);\n    dst[0] = a[0] / b[0];\n    dst[1] = a[1] / b[1];\n    dst[2] = a[2] / b[2];\n    dst[3] = a[3] / b[3];\n    return dst;\n}\n/**\n * Divides a vector by another vector (component-wise); assumes a and\n * b have the same length. (same as divide)\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The vector of quotients of entries of a and b.\n */\nconst div = divide;\n/**\n * Zero's a vector\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The zeroed vector.\n */\nfunction zero(dst) {\n    dst = dst || new VecType(4);\n    dst[0] = 0;\n    dst[1] = 0;\n    dst[2] = 0;\n    dst[3] = 0;\n    return dst;\n}\n/**\n * transform vec4 by 4x4 matrix\n * @param v - the vector\n * @param m - The matrix.\n * @param dst - optional vec4 to store result. If not passed a new one is created.\n * @returns the transformed vector\n */\nfunction transformMat4(v, m, dst) {\n    dst = dst || new VecType(4);\n    const x = v[0];\n    const y = v[1];\n    const z = v[2];\n    const w = v[3];\n    dst[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;\n    dst[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;\n    dst[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;\n    dst[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;\n    return dst;\n}\n/**\n * Treat a 4D vector as a direction and set it's length\n *\n * @param a The vec4 to lengthen\n * @param len The length of the resulting vector\n * @returns The lengthened vector\n */\nfunction setLength(a, len, dst) {\n    dst = dst || new VecType(4);\n    normalize(a, dst);\n    return mulScalar(dst, len, dst);\n}\n/**\n * Ensure a vector is not longer than a max length\n *\n * @param a The vec4 to limit\n * @param maxLen The longest length of the resulting vector\n * @returns The vector, shortened to maxLen if it's too long\n */\nfunction truncate(a, maxLen, dst) {\n    dst = dst || new VecType(4);\n    if (length(a) > maxLen) {\n        return setLength(a, maxLen, dst);\n    }\n    return copy(a, dst);\n}\n/**\n * Return the vector exactly between 2 endpoint vectors\n *\n * @param a Endpoint 1\n * @param b Endpoint 2\n * @returns The vector exactly residing between endpoints 1 and 2\n */\nfunction midpoint(a, b, dst) {\n    dst = dst || new VecType(4);\n    return lerp(a, b, 0.5, dst);\n}\n\nvar vec4Impl = {\n    __proto__: null,\n    add: add,\n    addScaled: addScaled,\n    ceil: ceil,\n    clamp: clamp,\n    clone: clone,\n    copy: copy,\n    create: create,\n    dist: dist,\n    distSq: distSq,\n    distance: distance,\n    distanceSq: distanceSq,\n    div: div,\n    divScalar: divScalar,\n    divide: divide,\n    dot: dot,\n    equals: equals,\n    equalsApproximately: equalsApproximately,\n    floor: floor,\n    fromValues: fromValues,\n    inverse: inverse,\n    invert: invert,\n    len: len,\n    lenSq: lenSq,\n    length: length,\n    lengthSq: lengthSq,\n    lerp: lerp,\n    lerpV: lerpV,\n    max: max,\n    midpoint: midpoint,\n    min: min,\n    mul: mul,\n    mulScalar: mulScalar,\n    multiply: multiply,\n    negate: negate,\n    normalize: normalize,\n    round: round,\n    scale: scale,\n    set: set,\n    setDefaultType: setDefaultType$1,\n    setLength: setLength,\n    sub: sub,\n    subtract: subtract,\n    transformMat4: transformMat4,\n    truncate: truncate,\n    zero: zero\n};\n\n/**\n * Sets the type this library creates for all types\n *\n * example:\n *\n * ```\n * setDefaultType(Float64Array);\n * ```\n *\n * @param ctor - the constructor for the type. Either `Float32Array`, `Float64Array`, or `Array`\n */\nfunction setDefaultType(ctor) {\n    setDefaultType$4(ctor);\n    setDefaultType$3(ctor);\n    setDefaultType$2(ctor);\n    setDefaultType$6(ctor);\n    setDefaultType$5(ctor);\n    setDefaultType$1(ctor);\n}\n\nexport { mat3Impl as mat3, mat4Impl as mat4, quatImpl as quat, setDefaultType, utils, vec2Impl as vec2, vec3Impl as vec3, vec4Impl as vec4 };\n//# sourceMappingURL=wgpu-matrix.module.js.map\n","import { mat4, vec3, mat3 } from 'wgpu-matrix';\n// for some reason this needs to be a bit different than the one in wgpu-matrix\nfunction getProjectionMatrix(znear, zfar, fovX, fovY) {\n    const tanHalfFovY = Math.tan(fovY / 2);\n    const tanHalfFovX = Math.tan(fovX / 2);\n    const top = tanHalfFovY * znear;\n    const bottom = -top;\n    const right = tanHalfFovX * znear;\n    const left = -right;\n    const P = mat4.create();\n    const z_sign = 1.0;\n    P[0] = (2.0 * znear) / (right - left);\n    P[5] = (2.0 * znear) / (top - bottom);\n    P[8] = (right + left) / (right - left);\n    P[9] = (top + bottom) / (top - bottom);\n    P[10] = z_sign * zfar / (zfar - znear);\n    P[11] = -(zfar * znear) / (zfar - znear);\n    P[14] = z_sign;\n    P[15] = 0.0;\n    return mat4.transpose(P);\n}\n// useful for coordinate flips\nfunction diagonal4x4(x, y, z, w) {\n    const m = mat4.create();\n    m[0] = x;\n    m[5] = y;\n    m[10] = z;\n    m[15] = w;\n    return m;\n}\n// A camera as used by the renderer. Interactivity is handled by InteractiveCamera.\nexport class Camera {\n    constructor(height, width, viewMatrix, perspective, focalX, focalY, scaleModifier) {\n        this.height = height;\n        this.width = width;\n        this.viewMatrix = viewMatrix;\n        this.perspective = perspective;\n        //this.perspective = mat4.transpose( perspective);\n        this.focalX = focalX;\n        this.focalY = focalY;\n        this.scaleModifier = scaleModifier;\n    }\n    static default() {\n        return new Camera(window.innerHeight, window.innerWidth, mat4.lookAt([0, 0, -2], [0, 0, 0], [0, 1, 0]), mat4.perspective(1.04719755, 1, 0.03, 1000), 600, 600, 1);\n    }\n    // computes the depth of a point in camera space, for sorting\n    dotZ() {\n        const depthAxis = this.depthAxis();\n        return (v) => {\n            return vec3.dot(depthAxis, v);\n        };\n    }\n    // gets the camera position in world space, for evaluating the spherical harmonics\n    getPosition() {\n        const inverseViewMatrix = mat4.inverse(this.viewMatrix);\n        return mat4.getTranslation(inverseViewMatrix);\n    }\n    getProjMatrix() {\n        var flippedY = mat4.clone(this.perspective);\n        flippedY = mat4.mul(flippedY, diagonal4x4(1, -1, 1, 1));\n        return mat4.multiply(flippedY, this.viewMatrix);\n    }\n    // for camera interactions\n    translate(x, y, z) {\n        const viewInv = mat4.inverse(this.viewMatrix);\n        mat4.translate(viewInv, [x, y, z], viewInv);\n        mat4.inverse(viewInv, this.viewMatrix);\n    }\n    // for camera interactions\n    rotate(x, y, z) {\n        const viewInv = mat4.inverse(this.viewMatrix);\n        mat4.rotateX(viewInv, y, viewInv);\n        mat4.rotateY(viewInv, x, viewInv);\n        mat4.rotateZ(viewInv, z, viewInv);\n        mat4.inverse(viewInv, this.viewMatrix);\n    }\n    // the depth axis is the third column of the transposed view matrix\n    depthAxis() {\n        return mat4.getAxis(mat4.transpose(this.viewMatrix), 2);\n    }\n}\n// Adds interactivity to a camera. The camera is modified by the user's mouse and keyboard input.\nexport class InteractiveCamera {\n    constructor(camera, canvas) {\n        this.drag = false;\n        this.oldX = 0;\n        this.oldY = 0;\n        this.dRX = 0;\n        this.dRY = 0;\n        this.dRZ = 0;\n        this.dTX = 0;\n        this.dTY = 0;\n        this.dTZ = 0;\n        this.dirty = true;\n        this.camera = camera;\n        this.canvas = canvas;\n        this.createCallbacks();\n    }\n    static default(canvas) {\n        return new InteractiveCamera(Camera.default(), canvas);\n    }\n    createCallbacks() {\n        this.canvas.addEventListener('mousedown', (e) => {\n            this.drag = true;\n            this.oldX = e.pageX;\n            this.oldY = e.pageY;\n            this.setDirty();\n            e.preventDefault();\n        }, false);\n        this.canvas.addEventListener('mouseup', (e) => {\n            this.drag = false;\n        }, false);\n        this.canvas.addEventListener('mousemove', (e) => {\n            if (!this.drag)\n                return false;\n            this.dRX = (e.pageX - this.oldX) * 2 * Math.PI / this.canvas.width;\n            this.dRY = -(e.pageY - this.oldY) * 2 * Math.PI / this.canvas.height;\n            this.oldX = e.pageX;\n            this.oldY = e.pageY;\n            this.setDirty();\n            e.preventDefault();\n        }, false);\n        this.canvas.addEventListener('wheel', (e) => {\n            this.dTZ = e.deltaY * 0.1;\n            this.setDirty();\n            e.preventDefault();\n        }, false);\n        window.addEventListener('keydown', (e) => {\n            const keyMap = {\n                // translation\n                'w': () => { this.dTY -= 0.1; },\n                's': () => { this.dTY += 0.1; },\n                'a': () => { this.dTX -= 0.1; },\n                'd': () => { this.dTX += 0.1; },\n                'q': () => { this.dTZ += 0.1; },\n                'e': () => { this.dTZ -= 0.1; },\n                // rotation\n                'j': () => { this.dRX += 0.1; },\n                'l': () => { this.dRX -= 0.1; },\n                'i': () => { this.dRY += 0.1; },\n                'k': () => { this.dRY -= 0.1; },\n                'u': () => { this.dRZ += 0.1; },\n                'o': () => { this.dRZ -= 0.1; },\n            };\n            if (!keyMap[e.key]) {\n                return;\n            }\n            else {\n                keyMap[e.key]();\n                this.setDirty();\n                e.preventDefault();\n            }\n        }, false);\n    }\n    setNewCamera(newCamera) {\n        console.log(\"set camera\" + newCamera);\n        this.camera = newCamera;\n        this.setDirty();\n    }\n    setDirty() {\n        this.dirty = true;\n    }\n    setClean() {\n        this.dirty = false;\n    }\n    isDirty() {\n        return this.dirty;\n    }\n    getCamera() {\n        if (this.isDirty()) {\n            this.camera.translate(this.dTX, this.dTY, this.dTZ);\n            this.camera.rotate(this.dRX, this.dRY, this.dRZ);\n            this.dTX = this.dTY = this.dTZ = this.dRX = this.dRY = this.dRZ = 0;\n            this.setClean();\n        }\n        return this.camera;\n    }\n}\nfunction focal2fov(focal, pixels) {\n    return 2 * Math.atan(pixels / (2 * focal));\n}\nfunction worldToCamFromRT(R, t) {\n    const R_ = R;\n    const camToWorld = mat4.fromMat3(R_);\n    const minusT = vec3.mulScalar(t, -1);\n    mat4.translate(camToWorld, minusT, camToWorld);\n    return camToWorld;\n}\n// converting camera coordinate systems is always black magic :(\nfunction cameraFromJSON(rawCamera, canvasW, canvasH) {\n    //const fovX = focal2fov(rawCamera.fx, rawCamera.width);\n    //const fovY = focal2fov(rawCamera.fy, rawCamera.height);\n    //const asp = canvasW /  canvasH;    \n    //const fovX = focal2fov(rawCamera.fx, window.innerWidth);\n    //const fovY = focal2fov(rawCamera.fy, window.innerHeight);\n    const fovX = focal2fov(rawCamera.fx, canvasW);\n    const fovY = focal2fov(rawCamera.fy, canvasH);\n    const projectionMatrix = getProjectionMatrix(0.2, 100, fovX, fovY);\n    //const projectionMatrix = mat4.perspective(1.04719755, 1, 0.03, 10000);\n    //const projectionMatrix = mat4.perspective(1.04719755, window.innerWidth/window.innerHeight, 0.03, 10000);\n    const R = mat3.create(...rawCamera.rotation.flat());\n    const T = rawCamera.position;\n    const viewMatrix = worldToCamFromRT(R, T);\n    //const viewMatrix =  mat4.lookAt([0, 0 , -20], [0, 0, 0], [0, 1, 0]);\n    return new Camera(canvasH, canvasW, viewMatrix, projectionMatrix, canvasH, //rawCamera.fx,\n    canvasW, //rawCamera.fy,\n    1);\n    console.log(canvasH + \" \" + canvasW);\n    console.log(rawCamera.fx + \" \" + rawCamera.fy);\n}\n// A UI component that parses a JSON file containing a list of cameras and displays them as a list,\n// allowing the user to choose from presets.\nexport class CameraFileParser {\n    constructor(fileInput, listElement, canvas, cameraSetCallback) {\n        this.currentLineId = 0;\n        this.handleFileInputChange = (event) => {\n            var _a;\n            const file = (_a = this.fileInput.files) === null || _a === void 0 ? void 0 : _a[0];\n            if (file) {\n                const reader = new FileReader();\n                reader.onload = this.handleFileLoad;\n                reader.readAsText(file);\n            }\n        };\n        this.handleFileLoad = (event) => {\n            if (!event.target)\n                return;\n            const contents = event.target.result;\n            const jsonData = JSON.parse(contents);\n            this.currentLineId = 0;\n            this.listElement.innerHTML = '';\n            this.handleJsonData(jsonData);\n            /*\n            jsonData.forEach((cameraJSON: any) => {\n                this.currentLineId++;\n                const listItem = document.createElement('li');\n                const camera = cameraFromJSON(cameraJSON, this.canvas.width, this.canvas.height);\n                listItem.textContent = cameraJSON.img_name;\n                listItem.addEventListener('click', this.createCallbackForLine(camera));\n                this.listElement.appendChild(listItem);\n            });\n            */\n        };\n        this.createCallbackForLine = (camera) => {\n            return () => {\n                this.cameraSetCallback(camera);\n            };\n        };\n        this.fileInput = fileInput;\n        this.listElement = listElement;\n        this.canvas = canvas;\n        this.cameraSetCallback = cameraSetCallback;\n        this.fileInput.addEventListener('change', this.handleFileInputChange);\n    }\n    handleJsonData(json) {\n        //const jsonData = JSON.parse(json);\n        json.forEach((cameraJSON) => {\n            this.currentLineId++;\n            const listItem = document.createElement('li');\n            const camera = cameraFromJSON(cameraJSON, this.canvas.width, this.canvas.height);\n            listItem.textContent = cameraJSON.img_name;\n            listItem.addEventListener('click', this.createCallbackForLine(camera));\n            this.listElement.appendChild(listItem);\n        });\n    }\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nexport class GpuContext {\n    constructor(gpu, adapter, device) {\n        this.gpu = gpu;\n        this.adapter = adapter;\n        this.device = device;\n    }\n    static create() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const gpu = navigator.gpu;\n            if (!gpu) {\n                return Promise.reject(\"WebGPU not supported on this browser! (navigator.gpu is null)\");\n            }\n            const adapter = yield gpu.requestAdapter();\n            if (!adapter) {\n                return Promise.reject(\"WebGPU not supported on this browser! (gpu.adapter is null)\");\n            }\n            const device = yield adapter.requestDevice({ label: \"GPUDevice\" });\n            return new GpuContext(gpu, adapter, device);\n        });\n    }\n    destroy() {\n        this.device.destroy();\n        this.adapter = null;\n        this.device = null;\n    }\n}\n","const screen_size = 600.0; //this is only for debug, do not use it\nconst shDeg3Code = `\r\n    // spherical harmonic coefficients\r\n    const SH_C0 = 0.28209479177387814f;\r\n    const SH_C1 = 0.4886025119029199f;\r\n    const SH_C2 = array(\r\n        1.0925484305920792f,\r\n        -1.0925484305920792f,\r\n        0.31539156525252005f,\r\n        -1.0925484305920792f,\r\n        0.5462742152960396f\r\n    );\r\n    const SH_C3 = array(\r\n        -0.5900435899266435f,\r\n        2.890611442640554f,\r\n        -0.4570457994644658f,\r\n        0.3731763325901154f,\r\n        -0.4570457994644658f,\r\n        1.445305721320277f,\r\n        -0.5900435899266435f\r\n    );\r\n\r\n    fn compute_color_from_sh(position: vec3<f32>, sh: array<vec3<f32>, 16>) -> vec3<f32> {\r\n        let dir = normalize(position - uniforms.camera_position);\r\n        var result = SH_C0 * sh[0];\r\n\r\n        // if deg > 0\r\n        let x = dir.x;\r\n        let y = dir.y;\r\n        let z = dir.z;\r\n\r\n        result = result + SH_C1 * (-y * sh[1] + z * sh[2] - x * sh[3]);\r\n\r\n        let xx = x * x;\r\n        let yy = y * y;\r\n        let zz = z * z;\r\n        let xy = x * y;\r\n        let xz = x * z;\r\n        let yz = y * z;\r\n\r\n        // if (sh_degree > 1) {\r\n        result = result +\r\n            SH_C2[0] * xy * sh[4] +\r\n            SH_C2[1] * yz * sh[5] +\r\n            SH_C2[2] * (2. * zz - xx - yy) * sh[6] +\r\n            SH_C2[3] * xz * sh[7] +\r\n            SH_C2[4] * (xx - yy) * sh[8];\r\n        \r\n        // if (sh_degree > 2) {\r\n        result = result +\r\n            SH_C3[0] * y * (3. * xx - yy) * sh[9] +\r\n            SH_C3[1] * xy * z * sh[10] +\r\n            SH_C3[2] * y * (4. * zz - xx - yy) * sh[11] +\r\n            SH_C3[3] * z * (2. * zz - 3. * xx - 3. * yy) * sh[12] +\r\n            SH_C3[4] * x * (4. * zz - xx - yy) * sh[13] +\r\n            SH_C3[5] * z * (xx - yy) * sh[14] +\r\n            SH_C3[6] * x * (xx - 3. * yy) * sh[15];\r\n\r\n        // unconditional\r\n        result = result + 0.5;\r\n\r\n        return max(result, vec3<f32>(0.));\r\n    }\r\n`;\nfunction get_simple_shader(width, height) {\n    return `\r\n\t${shDeg3Code}\r\n\tconst n_sh_coeffs = 16;\t\r\n\r\n\tstruct PointInput {\r\n            @location(0) position: vec3<f32>,\r\n            @location(1) log_scale: vec3<f32>,\r\n            @location(2) rot: vec4<f32>,\r\n            @location(3) opacity_logit: f32,\r\n            sh: array<vec3<f32>, n_sh_coeffs>,\r\n        };\r\n\tstruct Uniforms {\r\n            viewMatrix: mat4x4<f32>,\r\n            projMatrix: mat4x4<f32>,\r\n            camera_position: vec3<f32>,\r\n            tan_fovx: f32,\r\n            tan_fovy: f32,\r\n            focal_x: f32,\r\n            focal_y: f32,\r\n            scale_modifier: f32,\r\n        };\r\n\tstruct PointOutput {\r\n\t\t@builtin(position) position: vec4<f32>,\r\n\t\t@location(0) color: vec3<f32>,\r\n\t\t@location(1) uv: vec2<f32>,\r\n\t\t@location(2) conic_and_opacity: vec4<f32>,\r\n\t};\r\n\r\n\tfn CalcMatrixFromRotationScale(rot: vec4<f32>, scale: vec3<f32>) -> mat3x3<f32> {\r\n\t\tlet modifier = uniforms.scale_modifier;\r\n\t\t\tlet ms = mat3x3<f32>(\r\n\t\t\t\tscale.x  * modifier, 0.0, 0.0,\r\n\t\t\t\t0.0, scale.y  * modifier, 0.0,\r\n\t\t\t\t0.0, 0.0, scale.z  * modifier\r\n\t\t\t);\r\n\r\n\t\t\tlet x = rot.x;\r\n\t\t\tlet y = rot.y;\r\n\t\t\tlet z = rot.z;\r\n\t\t\tlet w = rot.w;\r\n\r\n\t\t\tlet mr = mat3x3<f32>(\r\n\t\t\t\t1.0 - 2.0 * (y * y + z * z), 2.0 * (x * y - w * z), 2.0 * (x * z + w * y),\r\n\t\t\t\t2.0 * (x * y + w * z), 1.0 - 2.0 * (x * x + z * z), 2.0 * (y * z - w * x),\r\n\t\t\t\t2.0 * (x * z - w * y), 2.0 * (y * z + w * x), 1.0 - 2.0 * (x * x + y * y)\r\n\t\t\t);\r\n\r\n\t\t\treturn mr * ms;\r\n\t\t}\r\n\tfn sigmoid(x: f32) -> f32 {\r\n\t\tif (x >= 0.) {\r\n\t\t\treturn 1. / (1. + exp(-x));\r\n\t\t} else {\r\n\t\t\tlet z = exp(x);\r\n\t\t\treturn z / (1. + z);\r\n\t\t}\r\n\t}\r\n\r\n\tfn compute_cov3d(log_scale: vec3<f32>, rot: vec4<f32>) -> array<f32, 6> {\r\n\t\t// ------------ CalcMatrixFromRotationScale ----------------\r\n\t\tlet modifier = uniforms.scale_modifier;\r\n\t\t\r\n\t\tlet S = mat3x3<f32>(\r\n\t\t\t(log_scale.x) * modifier, 0., 0.,\r\n\t\t\t0., (log_scale.y) * modifier, 0.,\r\n\t\t\t0., 0., (log_scale.z) * modifier,\r\n\t\t);\r\n\t\t\r\n\t\tlet x = rot.x;\r\n\t\tlet y = rot.y;\r\n\t\tlet z = rot.z;\r\n\t\tlet w = rot.w;\r\n\r\n\t\tlet R = mat3x3<f32>(\r\n\t\t\t1-2*(y*y + z*z),   2*(x*y - w*z),   2*(x*z + w*y),\r\n          \t2*(x*y + w*z), 1-2*(x*x + z*z),   2*(y*z - w*x),\r\n          \t2*(x*z - w*y),   2*(y*z + w*x), 1-2*(x*x + y*y)\r\n\t\t);\r\n\r\n\t\tlet M =  R * S;\r\n\r\n\t\t// ------------ CalcCovariance3D ----------------\r\n\t\tlet Sigma = M * transpose(M) ;\t\t\r\n\t\treturn array<f32, 6>(\r\n\t\t\t/*\r\n\t\t\t*/\r\n\t\t\tSigma[0][0],\r\n\t\t\tSigma[0][1],\r\n\t\t\tSigma[0][2],\r\n\t\t\tSigma[1][1],\r\n\t\t\tSigma[1][2],\t\t\t\r\n\t\t\tSigma[2][2],\t\t\t\r\n\t\t);\r\n\t} \r\n\r\n\t@group(0) @binding(0) var<storage, read> points: array<PointInput>;\r\n\t@group(0) @binding(1) var<uniform> \t\t\t\tuniforms: Uniforms;\r\n\t@group(0) @binding(2)  var<storage, read> sorted_idx: array<u32>;\r\n\t@group(0) @binding(3)  var<storage, read_write> debug_arr: array<u32>;\r\n\t\t\r\n\t@fragment\r\n\tfn fs_main(input: PointOutput) ->@location(0) vec4f  {\r\n\t\tlet selectedColor : vec3<f32> = vec3<f32> (1,0,1);\r\n\t\tvar opacity = input.conic_and_opacity.w;   \r\n\t\tvar color : vec4<f32> = vec4<f32> (input.color ,opacity);\r\n\t\tlet power :f32 = -dot(input.uv, input.uv);\r\n\t\tvar alpha :f32 = exp(power);\r\n\t\tif(opacity>=0){\r\n\t\t\talpha = saturate(alpha * opacity );\r\n\t\t}\r\n\t\t/*\r\n\t\t*/\r\n\t\telse{\r\n\t\t\tif(alpha > 7.0/255.0){\r\n\t\t\t\tif(alpha < 10.0 /255.0){\r\n\t\t\t\t\talpha = 1;\r\n\t\t\t\t\tcolor = vec4<f32> (selectedColor , color.a);\r\n\t\t\t\t}\r\n\t\t\t\talpha = saturate(alpha +0.3);\r\n\t\t\t}\r\n\t\t\tcolor = vec4<f32> ( mix(input.color.rgb , selectedColor , 0.5 ) , color.a);\r\n\t\t}\r\n\t\tif(alpha < 1.0/255.0){\r\n\t\t\tdiscard;\r\n\t\t}\r\n\t\t\r\n\t\t\r\n\t\treturn vec4<f32>(input.color * alpha, alpha);\r\n\t\t//return vec4<f32>(alpha,alpha,alpha, 1);\r\n\t\t//return vec4<f32>(color.rgb, 1);\r\n\t\t//return color;\r\n\t\t}\r\n\tfn asfloat(hex: u32) -> f32 {\r\n\t\tlet float_value = bitcast<f32>(hex);\r\n\t\treturn float_value;\r\n\t}\r\n\tfn safe_normalize_v2(v: vec2<f32>) -> vec2<f32> {\r\n\t\tlet epsilon = 1e-10;\r\n\t\tvar x = v.x;\r\n\t\tvar y = v.y;\r\n\t\tif(v.x !=0){\r\n\t\t\tx= x +epsilon;\r\n\t\t}\r\n\t\tif(v.y!=0){\r\n\t\t\ty= y +epsilon;\r\n\t\t}\r\n\t\treturn normalize( vec2f(x,y));\r\n\t}\r\n\t@vertex\r\n\tfn vs_points(\r\n\t\t@builtin(vertex_index) vtxID: u32,\r\n    \t@builtin(instance_index) instID: u32,\r\n\t\t@location(0) pos: vec3f ) -> PointOutput {\r\n\t\t\r\n\t\tvar output: PointOutput;\r\n\t\tlet p_idx = sorted_idx[instID];\r\n\t\tvar point = points[p_idx] ;\t\t\t\t\r\n\t\tlet idx = vtxID;\r\n\r\n\t\tvar clipPos =  uniforms.projMatrix * uniforms.viewMatrix  * vec4f( point.position , 1);\t\r\n\r\n\t\tif(clipPos.w<=0){\r\n\t\t\tlet nanfloat = asfloat(0x7fc00000);\r\n\t\t\toutput.position = vec4<f32>(nanfloat , nanfloat , nanfloat,nanfloat); // NaN discards the primitive\r\n\t\t}\r\n\t\telse{\r\n\t\t\r\n\t\t\tvar quadPos = vec2<f32>(\r\n\t\t\t\tf32(idx&1), \r\n\t\t\t\tf32((idx>>1)&1)\r\n\t\t\t\t) * 2.0 -1 ;\r\n\t\t\tquadPos *=2;\r\n\t\t\toutput.uv  = quadPos;\r\n\t\t\toutput.position  = clipPos  ;\r\n\t\t\t\t\t\t\t\t\r\n\r\n\t\t\tlet splatRotScaleMat : mat3x3<f32> = CalcMatrixFromRotationScale(point.rot, point.log_scale);\r\n\r\n\t\t\tlet sig :  mat3x3<f32> = splatRotScaleMat * transpose(splatRotScaleMat);\r\n\t\t\tvar cov3d0 : vec3f = vec3f (sig[0][0] , sig[0][1] , sig[0][2]  );\r\n\t\t\tvar cov3d1 : vec3f = vec3f (sig[1][1] , sig[1][2] , sig[2][2]  );\r\n\t\t\t\r\n\t\t\t//output.uv *= cov3d1.yz;   // Why it broke?\r\n\t\t\tlet splatScale = 1.0;\r\n        \tlet splatScale2 = splatScale * splatScale;\r\n\t\t\tcov3d0 *= splatScale2;\r\n\t\t\tcov3d1 *= splatScale2;\r\n\t\t\t\r\n\t\t\tlet _VecScreenParams = vec4f(${width},${height},0,0);\r\n\r\n\t\t\tvar viewPos:vec3f = (uniforms.viewMatrix * vec4<f32>(point.position, 1.0)).xyz;\r\n\t\t\tlet aspect = uniforms.projMatrix[0][0] / uniforms.projMatrix[1][1] ;  \t\t\t\r\n\r\n\t\t\tlet tanFovX: f32 = 1.0 / uniforms.projMatrix[0][0];\r\n\t\t\tlet tanFovY: f32 = 1.0 / (uniforms.projMatrix[1][1] * aspect);\r\n\r\n\t\t\tlet limx = 1.3 * tanFovX;\r\n\t\t\tlet limy = 1.3 * tanFovY;\r\n\t\t\tlet txtz = viewPos.x / viewPos.z;\r\n\t\t\tlet tytz = viewPos.y / viewPos.z;\r\n\r\n\t\t\tviewPos.x = min(limx, max(-limx, txtz)) * viewPos.z;\r\n\t\t\tviewPos.y = min(limy, max(-limy, tytz)) * viewPos.z;\r\n\r\n\t\t\tlet focal = _VecScreenParams.x * uniforms.projMatrix[0][0] / 2;\r\n\t\t\tlet J = mat3x3(\r\n\t\t\t\tfocal / viewPos.z, 0., -(focal * viewPos.x) / (viewPos.z * viewPos.z),\r\n\t\t\t\t0., focal / viewPos.z, -(focal * viewPos.y) / (viewPos.z * viewPos.z),\r\n\t\t\t\t0., 0., 0., \r\n\t\t\t);\r\n\r\n\t\t\tlet W = mat3x3<f32>(\r\n\t\t\t\tuniforms.viewMatrix[0].xyz,\r\n\t\t\t\tuniforms.viewMatrix[1].xyz,\r\n\t\t\t\tuniforms.viewMatrix[2].xyz\r\n\t\t\t);\r\n\t\t\t\r\n\t\t\tlet T = J * W;\r\n\r\n\t\t\tlet Vrk = mat3x3(\r\n\t\t\t\tcov3d0.x, cov3d0.y, cov3d0.z,\r\n\t\t\t\tcov3d0.y, cov3d1.x, cov3d1.y,\r\n\t\t\t\tcov3d0.z, cov3d1.y, cov3d1.z\t\r\n\t\t\t);\r\n\r\n\t\t\tvar cov2d_mat = T * ((Vrk) * transpose(T));\r\n\t\t\tcov2d_mat[0][0] += 0.3;\r\n\t\t\tcov2d_mat[1][1] += 0.3;\r\n\r\n\t\t\tlet cov2d :vec3f  = vec3f(cov2d_mat[0][0] , -cov2d_mat[0][1] , cov2d_mat[1][1]);\r\n\t\t\t\r\n\r\n\t\t\tlet diag1 =  cov2d.x;\r\n\t\t\tlet diag2 =  cov2d.z;\r\n\t\t\tlet offDiag =  cov2d.y;\t\t\t\t\t\r\n\t\t\t\r\n\t\t\tvar mid =  0.5 *  (diag1 + diag2);\r\n\t\t\tvar radius = length(vec2<f32>((diag1 - diag2) /2.0  , offDiag));\r\n\t\t\tvar lambda1 = mid + radius;\r\n\t\t\tvar lambda2 = max(mid - radius , 0.1);\r\n\t\t\tvar diagVec : vec2<f32> = safe_normalize_v2(vec2<f32>(offDiag , lambda1 - diag1));\r\n\t\t\tdiagVec.y = -diagVec.y;\r\n\t\t\t\r\n\t\t\tlet maxSize :f32 = 4096.0;\r\n\t\t\tlet v1 : vec2<f32> = min(sqrt(2.0 * lambda1) , maxSize) * diagVec;        \r\n\t\t\tlet v2 : vec2<f32> = min(sqrt(2.0 * lambda2) , maxSize) * vec2<f32>(diagVec.y , -diagVec.x);\r\n\t\t\r\n\t\tlet _ScreenParams : vec2<f32> = vec2<f32>(${width},${height});       \t\t\r\n\t\tlet deltaScreenPos :vec2<f32> = vec2<f32>(quadPos.x * v1 + quadPos.y * v2) * 2 /_ScreenParams.xy;\t\t\r\n\r\n        output.position  .x += deltaScreenPos.x * clipPos.w;\r\n        output.position  .y += deltaScreenPos.y * clipPos.w;\r\n\t\toutput.color = compute_color_from_sh(point.position, point.sh);\r\n\t\t\r\n\t\t//================= Other ======================\r\n\t\tlet det = cov2d.x * cov2d.z - cov2d.y * cov2d.y;\t\r\n        let det_inv = 1.0 / det;\r\n\t\t\r\n        let conic = vec3<f32>(cov2d.z * det_inv, -cov2d.y * det_inv, cov2d.x * det_inv);\r\n        \toutput.conic_and_opacity = vec4<f32>(conic, sigmoid(point.opacity_logit));\r\n\t\t}\r\n\t\treturn output;\r\n\r\n\t}\r\n\t`;\n}\nconst screenPar_w = 600;\nfunction get_calcViewData_Shader(WORKGROUP_SIZE, count) {\n    return `\r\n\t\tstruct PointInput {\r\n            @location(0) position: vec3<f32>,\r\n            @location(1) log_scale: vec3<f32>,\r\n            @location(2) rot: vec4<f32>,\r\n            @location(3) opacity_logit: f32,\r\n            sh: array<vec3<f32>, 16>,\r\n        };\r\n\t\tstruct Uniforms {\r\n            viewMatrix: mat4x4<f32>,\r\n            projMatrix: mat4x4<f32>,\r\n            camera_position: vec3<f32>,\r\n            tan_fovx: f32,\r\n            tan_fovy: f32,\r\n            focal_x: f32,\r\n            focal_y: f32,\r\n            scale_modifier: f32,\r\n        };\r\n\r\n\t\tfn CalcMatrixFromRotationScale(rot: vec4<f32>, scale: vec3<f32>) -> mat3x3<f32> {\r\n\t\t\tlet ms = mat3x3<f32>(\r\n\t\t\t\tscale.x, 0.0, 0.0,\r\n\t\t\t\t0.0, scale.y, 0.0,\r\n\t\t\t\t0.0, 0.0, scale.z\r\n\t\t\t);\r\n\r\n\t\t\tlet x = rot.x;\r\n\t\t\tlet y = rot.y;\r\n\t\t\tlet z = rot.z;\r\n\t\t\tlet w = rot.w;\r\n\r\n\t\t\tlet mr = mat3x3<f32>(\r\n\t\t\t\t1.0 - 2.0 * (y * y + z * z), 2.0 * (x * y - w * z), 2.0 * (x * z + w * y),\r\n\t\t\t\t2.0 * (x * y + w * z), 1.0 - 2.0 * (x * x + z * z), 2.0 * (y * z - w * x),\r\n\t\t\t\t2.0 * (x * z - w * y), 2.0 * (y * z + w * x), 1.0 - 2.0 * (x * x + y * y)\r\n\t\t\t);\r\n\r\n\t\t\treturn mr * ms;\r\n\t\t}\r\n\t\tfn safe_normalize_v2(v: vec2<f32>) -> vec2<f32> {\r\n\t\t\tlet epsilon = 1e-10;\r\n\t\t\tvar x = v.x;\r\n\t\t\tvar y = v.y;\r\n\t\t\tif(v.x !=0){\r\n\t\t\t\tx= x +epsilon;\r\n\t\t\t}\r\n\t\t\tif(v.y!=0){\r\n\t\t\t\ty= y +epsilon;\r\n\t\t\t}\r\n\t\t\treturn normalize( vec2f(x,y));\r\n\t\t}\r\n\r\n\r\n\t \t@group(0) @binding(0) var<storage,read_write> \tsplat_pos\t\t: array<vec4f>;\r\n\t\t@group(0) @binding(1) var<storage,read_write> \tsplat_axis\t: array<vec4f>; \t\t\t\t\r\n\t\t@group(0) @binding(2) var<storage, read> points: array<PointInput>;\r\n\t\t@group(0) @binding(3) var<uniform> \t\t\t\tuniforms: Uniforms;\r\n\r\n\t\t@compute\r\n\t\t@workgroup_size(  ${WORKGROUP_SIZE}, 1,1 )\r\n\t\tfn main(\r\n\t\t\t@builtin(workgroup_id) workgroup_id : vec3<u32>,\r\n\t\t\t@builtin(local_invocation_id) local_invocation_id : vec3<u32>,\r\n\t\t\t@builtin(global_invocation_id) global_invocation_id : vec3<u32>,\r\n\t\t\t@builtin(local_invocation_index) local_invocation_index: u32,\r\n\t\t\t@builtin(num_workgroups) num_workgroups: vec3<u32>) {\r\n\t\t\tlet workgroup_index =  \r\n\t\t\t\tworkgroup_id.x +\r\n\t\t\t\tworkgroup_id.y * num_workgroups.x +\r\n\t\t\t\tworkgroup_id.z * num_workgroups.x * num_workgroups.y;\r\n\t\t\tlet idx =\r\n\t\t\t\tworkgroup_index * ${WORKGROUP_SIZE} +\r\n\t\t\t\tlocal_invocation_index;\r\n                \r\n            if(idx >= ${count}){\r\n                return;\r\n            }\r\n\r\n\t\t\tvar point = points[idx] ;\t\t\t\t\r\n\t\t\tvar clipPos =  uniforms.projMatrix * uniforms.viewMatrix  * vec4f( point.position , 1);\r\n\t\t\tsplat_pos[idx] = clipPos ;\r\n\r\n\r\n\t\t\tlet splatRotScaleMat : mat3x3<f32> = CalcMatrixFromRotationScale(point.rot, point.log_scale);\t\t\t\r\n\t\t\t\r\n\t\t\tlet sig :  mat3x3<f32> = splatRotScaleMat * transpose(splatRotScaleMat);\r\n\t\t\tvar cov3d0 : vec3f = vec3f (sig[0][0] , sig[0][1] , sig[0][2]  );\r\n\t\t\tvar cov3d1 : vec3f = vec3f (sig[1][1] , sig[1][2] , sig[2][2]  );\r\n\t\t\t\r\n\t\t\tlet _VecScreenParams = vec4f(${screen_size},${screen_size},0,0);\r\n\r\n\t\t\t// Cov2d:\t\t\t\r\n\t\t\tvar viewPos:vec3f = (uniforms.viewMatrix * vec4<f32>(point.position, 1.0)).xyz;\r\n\t\t\tlet aspect = uniforms.projMatrix[0][0] / uniforms.projMatrix[1][1] ;  // = 1\r\n\r\n\t\t\tlet tanFovX: f32 = 1.0 / uniforms.projMatrix[0][0];\r\n\t\t\tlet tanFovY: f32 = 1.0 / (uniforms.projMatrix[1][1] * aspect);\r\n\r\n\t\t\tlet limx = 1.3 * tanFovX;\r\n\t\t\tlet limy = 1.3 * tanFovY;\r\n\t\t\tlet txtz = viewPos.x / viewPos.z;\r\n\t\t\tlet tytz = viewPos.y / viewPos.z;\r\n\r\n\t\t\tviewPos.x = min(limx, max(-limx, txtz)) * viewPos.z;\r\n\t\t\tviewPos.y = min(limy, max(-limy, tytz)) * viewPos.z;\r\n\r\n\t\t\tlet focal = _VecScreenParams.x * uniforms.projMatrix[0][0] / 2;\r\n\t\t\tlet J = mat3x3(\r\n\t\t\t\tfocal / viewPos.z, 0., -(focal * viewPos.x) / (viewPos.z * viewPos.z),\r\n\t\t\t\t0., focal / viewPos.z, -(focal * viewPos.y) / (viewPos.z * viewPos.z),\r\n\t\t\t\t0., 0., 0., \r\n\t\t\t);\r\n\r\n\t\t\tlet W = mat3x3<f32>(\r\n\t\t\t\tuniforms.viewMatrix[0].xyz,\r\n\t\t\t\tuniforms.viewMatrix[1].xyz,\r\n\t\t\t\tuniforms.viewMatrix[2].xyz\r\n\t\t\t);\r\n\t\t\t\r\n\t\t\tlet T = J * W;\r\n\r\n\t\t\tlet Vrk = mat3x3(\r\n\t\t\t\tcov3d0.x, cov3d0.y, cov3d0.z,\r\n\t\t\t\tcov3d0.y, cov3d1.x, cov3d1.y,\r\n\t\t\t\tcov3d0.z, cov3d1.y, cov3d1.z\t\r\n\t\t\t);\r\n\r\n\t\t\t//var cov2d_mat = transpose(T) * transpose(Vrk) * T;\r\n\t\t\tvar cov2d_mat = T * ((Vrk) * transpose(T));\r\n\t\t\tcov2d_mat[0][0] += 0.3;\r\n\t\t\tcov2d_mat[1][1] += 0.3;\r\n\r\n\t\t\tlet cov2d :vec3f  = vec3f(cov2d_mat[0][0] , -cov2d_mat[0][1] , cov2d_mat[1][1]);\r\n\r\n\t\t\tlet diag1 =  cov2d.x;\r\n\t\t\tlet diag2 =  cov2d.z;\r\n\t\t\tvar offDiag =  cov2d.y;\t\t\t\t\t\t\r\n\t\t\t\r\n\t\t\tvar mid =  0.5 *  (diag1 + diag2);\r\n\t\t\tvar radius = length(vec2<f32>((diag1 - diag2) /2.0  , offDiag));\r\n\t\t\tvar lambda1 = mid + radius;\r\n\t\t\tvar lambda2 = max(mid - radius , 0.1);\r\n\r\n\t\t\t\r\n\t\t\t//var diagVec : vec2<f32> = normalize(vec2<f32>(offDiag , lambda1 - diag1));\r\n\t\t\tvar diagVec : vec2<f32> = safe_normalize_v2(vec2<f32>(offDiag , lambda1 - diag1));\r\n\t\t\tdiagVec.y = -diagVec.y;\r\n\t\t\t\r\n\t\t\tlet maxSize :f32 = 4096.0;\r\n\t\t\tlet v1 : vec2<f32> = min(sqrt(2.0 * lambda1) , maxSize) * diagVec;        \r\n\t\t\tlet v2 : vec2<f32> = min(sqrt(2.0 * lambda2) , maxSize) * vec2<f32>(diagVec.y , -diagVec.x);\r\n\t\t\t\r\n\t\t\t//splat_pos[idx] = vec4f(diagVec,offDiag , lambda1 - diag1 );\r\n\t\t\t//splat_pos[idx] = vec4f(point.rot);\r\n\t\t\t//splat_pos[idx] = vec4f(v1 , v2);\r\n\t\t\t//splat_pos[idx] = vec4f(splatRotScaleMat[idx].xyz ,0);\r\n\t\t\t//splat_pos[idx] = vec4f( cov2d_mat[idx] , f32(idx));\r\n\t\t\t//splat_pos[idx] = vec4f( focal, tanFovX, tanFovY, tytz);\r\n\t\t\t//splat_pos[idx] = vec4f( diag1 , diag2 , offDiag,0);\r\n\t\t\tsplat_pos[idx] = vec4f( viewPos,0);\r\n\r\n\t\t\tsplat_axis[idx] = vec4f(v1 , v2);\r\n\t\t\r\n\t\t}\r\n\t`;\n}\nexport class SimpleRender {\n    constructor(_contex, _canvas, _pointBuffer, _uniformBuffer, _sortIdxBuffer) {\n        const presentationFormat = \"rgba16float\";\n        const contextGpu = _canvas.getContext(\"webgpu\");\n        if (!contextGpu) {\n            throw new Error(\"WebGPU context not found!\");\n        }\n        this.contextGpu = contextGpu;\n        this.context = _contex;\n        // Dummy data:\n        const vertices = new Float32Array([\n            0.0, 0.5, 0.0,\n            -0.5, -0.5, 0.0,\n            0.5, -0.5, 0.0,\n        ]);\n        this.vertexBuffer = this.context.device.createBuffer({\n            size: vertices.byteLength,\n            usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC,\n        });\n        this.context.device.queue.writeBuffer(this.vertexBuffer, 0, vertices);\n        const vertexBufferLayout = {\n            arrayStride: 12,\n            attributes: [{\n                    format: \"float32x3\",\n                    offset: 0,\n                    shaderLocation: 0, // Position, \n                }],\n        };\n        const draw_bindinglayout = this.context.device.createBindGroupLayout({\n            entries: [\n                {\n                    binding: 0,\n                    visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT,\n                    buffer: { type: 'read-only-storage', },\n                },\n                {\n                    binding: 1,\n                    visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT,\n                    buffer: { type: 'uniform', },\n                },\n                {\n                    binding: 2,\n                    visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT,\n                    buffer: { type: 'read-only-storage', },\n                },\n            ],\n        });\n        this.pointBindGroup = this.context.device.createBindGroup({\n            layout: draw_bindinglayout,\n            entries: [\n                {\n                    binding: 0,\n                    resource: { buffer: _pointBuffer, },\n                },\n                {\n                    binding: 1,\n                    resource: { buffer: _uniformBuffer, },\n                },\n                {\n                    binding: 2,\n                    resource: { buffer: _sortIdxBuffer, },\n                },\n            ]\n        });\n        const draw_pipeline_layout = this.context.device.createPipelineLayout({\n            label: \"Simple draw layout \",\n            bindGroupLayouts: [draw_bindinglayout],\n        });\n        let shader_code = get_simple_shader(_canvas.width, _canvas.height);\n        console.log(\"canvas w,h\" + +_canvas.width + \" \" + _canvas.height);\n        this.pipeline = this.context.device.createRenderPipeline({\n            vertex: {\n                module: this.context.device.createShaderModule({\n                    code: shader_code,\n                }),\n                entryPoint: 'vs_points',\n                buffers: [vertexBufferLayout]\n            },\n            fragment: {\n                module: this.context.device.createShaderModule({\n                    code: shader_code,\n                }),\n                entryPoint: 'fs_main',\n                targets: [{\n                        format: presentationFormat,\n                        blend: {\n                            //one-minus-dst-alpha\n                            color: {\n                                srcFactor: \"one-minus-dst-alpha\",\n                                //srcFactor: \"src-alpha\" as GPUBlendFactor,\n                                dstFactor: \"one\",\n                                operation: \"add\",\n                            },\n                            alpha: {\n                                srcFactor: \"one-minus-dst-alpha\",\n                                //srcFactor: \"src-alpha\" as GPUBlendFactor,\n                                dstFactor: \"one\",\n                                operation: \"add\",\n                            },\n                        }\n                    }],\n            },\n            primitive: {\n                topology: 'triangle-list',\n                //topology: 'point-list',\n                //topology: 'line-list',\n                stripIndexFormat: undefined,\n                cullMode: undefined,\n            },\n            layout: draw_pipeline_layout\n            //layout: \"auto\"\n        });\n        const indices = new Uint32Array([0, 1, 2, 1, 3, 2,]);\n        this.drawIndexBuffer = this.context.device.createBuffer({\n            size: indices.byteLength,\n            usage: GPUBufferUsage.INDEX | GPUBufferUsage.COPY_DST,\n            mappedAtCreation: true,\n        });\n        new Uint32Array(this.drawIndexBuffer.getMappedRange()).set(indices);\n        this.drawIndexBuffer.unmap();\n        //========================================================\n        //\t\t\t\t\tDebug pipeline\n        //========================================================\n        let point_number = 100;\n        this.pp_splat_pos_Buffer = this.context.device.createBuffer({\n            size: point_number * 4 * 4,\n            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC,\n        });\n        this.context.device.queue.writeBuffer(this.pp_splat_pos_Buffer, 0, new Float32Array(point_number * 4));\n        this.pp_splat_axis_Buffer = this.context.device.createBuffer({\n            size: point_number * 4 * 4,\n            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC,\n        });\n        this.context.device.queue.writeBuffer(this.pp_splat_axis_Buffer, 0, new Float32Array(point_number * 4));\n        const preprocess_bindinglayout = this.context.device.createBindGroupLayout({\n            entries: [\n                {\n                    binding: 0,\n                    visibility: GPUShaderStage.COMPUTE,\n                    buffer: {\n                        type: 'storage',\n                    },\n                },\n                {\n                    binding: 1,\n                    visibility: GPUShaderStage.COMPUTE,\n                    buffer: {\n                        type: 'storage',\n                    },\n                },\n                {\n                    binding: 2,\n                    visibility: GPUShaderStage.COMPUTE,\n                    buffer: { type: 'read-only-storage', },\n                },\n                {\n                    binding: 3,\n                    visibility: GPUShaderStage.COMPUTE,\n                    buffer: { type: 'uniform', },\n                },\n            ],\n        });\n        this.preprocess_BindGroup = this.context.device.createBindGroup({\n            layout: preprocess_bindinglayout,\n            label: \"pre_process BindGroup\",\n            entries: [{\n                    binding: 0,\n                    resource: {\n                        buffer: this.pp_splat_pos_Buffer,\n                    },\n                }, {\n                    binding: 1,\n                    resource: {\n                        buffer: this.pp_splat_axis_Buffer,\n                    },\n                }, {\n                    binding: 2,\n                    resource: { buffer: _pointBuffer, },\n                },\n                {\n                    binding: 3,\n                    resource: { buffer: _uniformBuffer, },\n                },\n            ],\n        });\n        const preprocess_pipeline_layout = this.context.device.createPipelineLayout({\n            bindGroupLayouts: [preprocess_bindinglayout],\n        });\n        this.pre_processPipeline = this.context.device.createComputePipeline({\n            layout: preprocess_pipeline_layout,\n            compute: {\n                module: this.context.device.createShaderModule({\n                    code: get_calcViewData_Shader(8, point_number),\n                }),\n                entryPoint: \"main\",\n            }\n        });\n        //=========================\n        //\t\t\tTexture view\n        //=========================\n        const textureDescriptor = {\n            size: [_canvas.width, _canvas.height, 1],\n            format: presentationFormat,\n            usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING,\n        };\n        const framebufferTexture = this.context.device.createTexture(textureDescriptor);\n        this.framebuffer = framebufferTexture;\n    }\n    draw(gs_number) {\n        const commandEncoder = this.context.device.createCommandEncoder();\n        //const textureView = this.contextGpu.getCurrentTexture().createView();\n        const textureView = this.framebuffer.createView();\n        const renderPassDescriptor = {\n            colorAttachments: [{\n                    //view: textureView,\n                    view: textureView,\n                    clearValue: { r: 0, g: 0, b: 0, a: 0 },\n                    storeOp: \"store\",\n                    loadOp: \"clear\",\n                }],\n        };\n        //============ Preprocess =============\n        /*\n        const pp_encoder = this.context.device.createCommandEncoder();\n        const cs_ppr_pass = pp_encoder.beginComputePass();\n        cs_ppr_pass.setPipeline(this.pre_processPipeline);\n        cs_ppr_pass.setBindGroup(0 , this.preprocess_BindGroup);\n        cs_ppr_pass.dispatchWorkgroups(Math.max(gs_number/8 ,8) , 1,1);\n        cs_ppr_pass.end();\n        this.context.device.queue.submit([pp_encoder.finish()])\n\n        // paste data\n        const debug_size = Math.min(gs_number,100);\n        const _data_size = 4*4;\n        const _buffer_size = debug_size * _data_size;\n        const buffer = this.pp_splat_pos_Buffer;\n\n        const readBuffer = this.context.device.createBuffer({\n            size: _buffer_size,\n            usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST,\n            mappedAtCreation: false,\n            label: \"read back buffer\"\n        });\n        const _cmdPass = this.context.device.createCommandEncoder();\n        \n        _cmdPass.copyBufferToBuffer(buffer, 0, readBuffer, 0, _buffer_size);\n        this.context.device.queue.submit([ _cmdPass.finish()]);\n                \n        readBuffer.mapAsync(GPUMapMode.READ).then(() => {\n            const result = new Float32Array(readBuffer.getMappedRange());\n            console.log(\"=============== Read Back =================\");\n            console.log(result);\n            \n            readBuffer.unmap();\n        });\n        */\n        //============ Draw =============\n        const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);\n        passEncoder.setPipeline(this.pipeline);\n        passEncoder.setVertexBuffer(0, this.vertexBuffer);\n        passEncoder.setBindGroup(0, this.pointBindGroup);\n        //passEncoder.draw(3);\n        passEncoder.setIndexBuffer(this.drawIndexBuffer, \"uint32\");\n        passEncoder.drawIndexed(6, gs_number);\n        passEncoder.end();\n        this.context.device.queue.submit([commandEncoder.finish()]);\n        //console.log(\"draw\");\n    }\n}\n","export class PostProcessRenderer {\n    constructor(_context, _canvas, texture) {\n        this.context = _context;\n        this.canvas = _canvas;\n        this.texture = texture;\n        const contextGpu = _canvas.getContext(\"webgpu\");\n        if (!contextGpu) {\n            throw new Error(\"WebGPU context not found!\");\n        }\n        this.contextGpu = contextGpu;\n        const canvasFormat = 'rgba16float';\n        const vertices = new Float32Array([\n            //   X,    Y,\n            -1, -1,\n            1, -1,\n            1, 1,\n            -1, 1,\n            1, 1,\n            -1, -1,\n        ]);\n        this.vbo = this.context.device.createBuffer({\n            label: \"Cell vertices\",\n            size: vertices.byteLength,\n            usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,\n        });\n        this.context.device.queue.writeBuffer(this.vbo, /*bufferOffset=*/ 0, vertices);\n        const vertexBufferLayout = {\n            arrayStride: 8,\n            attributes: [{\n                    format: \"float32x2\", // vec2 = 8 bytes\n                    offset: 0,\n                    shaderLocation: 0, // Position, see vertex shader , between [0,15]\n                }],\n        };\n        const cellShaderModule = this.context.device.createShaderModule({\n            label: \"Cell shader\",\n            code: `\r\n\t\t\t@vertex\r\n\t\t\tfn vertexMain(@location(0) pos: vec2f) -> @builtin(position) vec4f {\r\n\t\t\t\treturn vec4f(pos.x, pos.y, 0, 1);\r\n\t\t\t}\r\n\r\n\t\t\t@group(0) @binding(0) var myTexture: texture_2d<f32>;\r\n\t\t\t@group(0) @binding(1) var mySampler: sampler;\r\n\t\t\t@fragment\r\n\t\t\tfn fragmentMain(@builtin(position) fragCoord: vec4<f32>) -> @location(0) vec4f {\r\n\t\t\t    var uv = fragCoord.xy / vec2<f32>(${this.canvas.width}, ${this.canvas.height});\r\n\t\t\t\tuv.y = 1-uv.y;\t\t\t\t\r\n\t\t\t\tvar color:vec4f = textureSample(myTexture, mySampler, uv)  ;\r\n\t\t\t\t\r\n\t\t\t\tcolor.a = saturate(color.a * 1.5);\r\n\r\n\t\t\t\tif(color.a <0.99){\r\n\t\t\t\t\t//discard;\r\n\t\t\t\t\tcolor.a = pow(color.a , 4);\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\treturn color;\r\n\t\t\t}\r\n\t\t\t`\n        });\n        const bindGroupLayout = this.context.device.createBindGroupLayout({\n            entries: [\n                {\n                    binding: 0,\n                    visibility: GPUShaderStage.FRAGMENT,\n                    texture: {\n                        sampleType: 'float',\n                    },\n                },\n                {\n                    binding: 1,\n                    visibility: GPUShaderStage.FRAGMENT,\n                    sampler: {\n                        type: 'filtering',\n                    },\n                },\n            ],\n        });\n        const pipeline_layout = this.context.device.createPipelineLayout({\n            label: \"Simple draw layout \",\n            bindGroupLayouts: [bindGroupLayout],\n        });\n        this.post_process_pipeline = this.context.device.createRenderPipeline({\n            label: \"post_process_pipeline\",\n            layout: pipeline_layout,\n            vertex: {\n                module: cellShaderModule,\n                entryPoint: \"vertexMain\",\n                buffers: [vertexBufferLayout]\n            },\n            fragment: {\n                module: cellShaderModule,\n                entryPoint: \"fragmentMain\",\n                targets: [{\n                        format: canvasFormat\n                    }]\n            }\n        });\n        const sampler = this.context.device.createSampler({\n            label: \"mip\",\n            magFilter: \"linear\",\n            minFilter: \"linear\",\n        });\n        // Step 3: Create a bind group\n        this.bindGroup = this.context.device.createBindGroup({\n            layout: bindGroupLayout,\n            entries: [\n                {\n                    binding: 0,\n                    resource: this.texture.createView(),\n                },\n                {\n                    binding: 1,\n                    resource: sampler,\n                },\n            ],\n        });\n    }\n    draw() {\n        const textureView = this.contextGpu.getCurrentTexture().createView();\n        const renderPassDescriptor = {\n            colorAttachments: [{\n                    view: textureView,\n                    clearValue: { r: 0, g: 0, b: 0, a: 0 },\n                    storeOp: \"store\",\n                    loadOp: \"clear\",\n                }],\n        };\n        const commandEncoder = this.context.device.createCommandEncoder();\n        const pass = commandEncoder.beginRenderPass(renderPassDescriptor);\n        pass.setPipeline(this.post_process_pipeline);\n        pass.setVertexBuffer(0, this.vbo);\n        pass.setBindGroup(0, this.bindGroup);\n        pass.draw(6, 2);\n        pass.end();\n        this.context.device.queue.submit([commandEncoder.finish()]);\n    }\n}\n","// This file contains the main rendering code. Unlike the official implementation,\n// instead of using compute shaders and iterating through (possibly) all gaussians,\n// we instead use a vertex shader to turn each gaussian into a quad facing the camera\n// and then use the fragment shader to paint the gaussian on the quad.\n// If we draw the quads in order of depth, with well chosen blending settings we can\n// get the same color accumulation rule as in the original paper.\n// This approach is faster than the original implementation on webGPU but still substantially\n// slow compared to the CUDA impl. The main bottleneck is the sorting of the quads by depth,\n// which is done on the CPU but could presumably be replaced by a compute shader sort.\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { f32, Struct, vec3, mat4x4 } from './packing';\nimport { getShaderCode, getInitSortBufferCode } from './shaders';\nimport { GpuContext } from './gpu_context';\nimport { RadixSortKernel } from 'webgpu-radix-sort';\nimport { SimpleRender } from './simple_render';\nimport { PostProcessRenderer } from './post_process_render';\nconst uniformLayout = new Struct([\n    ['viewMatrix', new mat4x4(f32)],\n    ['projMatrix', new mat4x4(f32)],\n    ['cameraPosition', new vec3(f32)],\n    ['tanHalfFovX', f32],\n    ['tanHalfFovY', f32],\n    ['focalX', f32],\n    ['focalY', f32],\n    ['scaleModifier', f32],\n]);\nfunction mat4toArrayOfArrays(m) {\n    return [\n        [m[0], m[1], m[2], m[3]],\n        [m[4], m[5], m[6], m[7]],\n        [m[8], m[9], m[10], m[11]],\n        [m[12], m[13], m[14], m[15]],\n    ];\n}\nexport class Renderer {\n    static requestContext(gaussians) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const gpu = navigator.gpu;\n            if (!gpu) {\n                return Promise.reject(\"WebGPU not supported on this browser! (navigator.gpu is null)\");\n            }\n            const adapter = yield gpu.requestAdapter();\n            if (!adapter) {\n                return Promise.reject(\"WebGPU not supported on this browser! (gpu.adapter is null)\");\n            }\n            // for good measure, we request 1.5 times the amount of memory we need\n            const byteLength = gaussians.gaussiansBuffer.byteLength;\n            const device = yield adapter.requestDevice({\n                requiredLimits: {\n                    maxStorageBufferBindingSize: 1.5 * byteLength,\n                    maxBufferSize: 1.5 * byteLength,\n                }\n            });\n            return new GpuContext(gpu, adapter, device);\n        });\n    }\n    // destroy the renderer and return a promise that resolves when it's done (after the next frame)\n    destroy() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return new Promise((resolve, reject) => {\n                this.destroyCallback = resolve;\n            });\n        });\n    }\n    constructor(canvas, interactiveCamera, gaussians, context, fpsCounter) {\n        this.destroyCallback = null;\n        this.canvas = canvas;\n        this.interactiveCamera = interactiveCamera;\n        this.context = context;\n        const contextGpu = canvas.getContext(\"webgpu\");\n        if (!contextGpu) {\n            throw new Error(\"WebGPU context not found!\");\n        }\n        this.contextGpu = contextGpu;\n        this.fpsCounter = fpsCounter;\n        this.lastDraw = performance.now();\n        this.numGaussians = gaussians.numGaussians;\n        const presentationFormat = \"rgba16float\";\n        this.contextGpu.configure({\n            device: this.context.device,\n            format: presentationFormat,\n            alphaMode: 'premultiplied',\n        });\n        //===========================================\n        //             Point Buffer\n        //===========================================\n        this.pointDataBuffer = this.context.device.createBuffer({\n            size: gaussians.gaussianArrayLayout.size,\n            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\n            mappedAtCreation: true,\n            label: \"renderer.pointDataBuffer\",\n        });\n        new Uint8Array(this.pointDataBuffer.getMappedRange()).set(new Uint8Array(gaussians.gaussiansBuffer));\n        this.pointDataBuffer.unmap();\n        // Create a GPU buffer for the uniform data.\n        this.uniformBuffer = this.context.device.createBuffer({\n            size: uniformLayout.size,\n            usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n            label: \"renderer.uniformBuffer\",\n        });\n        const shaderCode = getShaderCode(canvas, gaussians.sphericalHarmonicsDegree, gaussians.nShCoeffs, this.canvas.width, this.canvas.height);\n        console.log(this.interactiveCamera.getCamera());\n        const shaderModule = this.context.device.createShaderModule({ code: shaderCode });\n        //===========================================\n        //              Pipeline\n        //===========================================\n        const draw_uniform_bindinglayout = this.context.device.createBindGroupLayout({\n            entries: [\n                {\n                    binding: 0,\n                    visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT,\n                    buffer: {\n                        type: 'uniform',\n                    },\n                },\n            ],\n        });\n        const draw_data_bindinglayout = this.context.device.createBindGroupLayout({\n            label: \"draw_data_bindinglayout\",\n            entries: [\n                {\n                    binding: 1,\n                    visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT,\n                    buffer: {\n                        type: 'read-only-storage',\n                    },\n                },\n                {\n                    binding: 2,\n                    visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT,\n                    buffer: {\n                        type: 'read-only-storage',\n                    },\n                },\n            ],\n        });\n        const draw_pipeline_layout = this.context.device.createPipelineLayout({\n            label: \"draw_pipeline_layout \",\n            bindGroupLayouts: [draw_uniform_bindinglayout, draw_data_bindinglayout],\n        });\n        this.drawPipeline = this.context.device.createRenderPipeline({\n            //layout: \"auto\",            \n            layout: draw_pipeline_layout,\n            vertex: {\n                module: shaderModule,\n                entryPoint: \"vs_points\",\n            },\n            fragment: {\n                module: shaderModule,\n                entryPoint: \"fs_main\",\n                targets: [\n                    {\n                        format: presentationFormat,\n                        // with one-minus-dst alpha we can set the src to src.alpha * src.color and\n                        // we get that color_new = src.color * src.alpha + dst.color * (1 - src.alpha)\n                        // which is the same as the accumulation rule in the paper\n                        blend: {\n                            color: {\n                                srcFactor: \"one-minus-dst-alpha\",\n                                dstFactor: \"one\",\n                                operation: \"add\",\n                            },\n                            alpha: {\n                                srcFactor: \"one-minus-dst-alpha\",\n                                dstFactor: \"one\",\n                                operation: \"add\",\n                            },\n                        }\n                    },\n                ],\n            },\n            primitive: {\n                topology: \"triangle-list\",\n                //topology: \"point-list\",\n                //topology: \"line-list\",\n                stripIndexFormat: undefined,\n                cullMode: undefined,\n            },\n        });\n        //===========================================\n        //              Binding group\n        //===========================================\n        // key_buffer , value buffer\n        this.sort_key_buffer = this.context.device.createBuffer({\n            size: this.numGaussians * 4,\n            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC,\n            mappedAtCreation: false,\n        });\n        this.sort_value_buffer = this.context.device.createBuffer({\n            size: this.numGaussians * 4,\n            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC,\n            mappedAtCreation: false,\n        });\n        // Drawing pass\n        this.uniformsBindGroup = this.context.device.createBindGroup({\n            //layout: this.drawPipeline.getBindGroupLayout(0),\n            layout: draw_uniform_bindinglayout,\n            entries: [{\n                    binding: 0,\n                    resource: {\n                        buffer: this.uniformBuffer,\n                    },\n                }],\n        });\n        this.pointDataBindGroup = this.context.device.createBindGroup({\n            //layout: this.drawPipeline.getBindGroupLayout(1),\n            layout: draw_data_bindinglayout,\n            entries: [{\n                    binding: 1,\n                    resource: {\n                        buffer: this.pointDataBuffer,\n                    },\n                }, {\n                    binding: 2,\n                    resource: {\n                        buffer: this.sort_key_buffer,\n                    },\n                }],\n        });\n        /*\n        this.depthSorter = new DepthSorter(this.context, gaussians);\n        this.drawIndexBuffer = this.context.device.createBuffer({\n           size: 6 * 4 * gaussians.numGaussians,\n           usage: GPUBufferUsage.INDEX | GPUBufferUsage.COPY_DST,\n           mappedAtCreation: false,\n           label: \"renderer.drawIndexBuffer\",\n        });\n        */\n        //===========================================\n        //             Radix Sorter\n        //===========================================\n        this.radixSortKernel = new RadixSortKernel({\n            device: this.context.device, // GPUDevice to use\n            keys: this.sort_value_buffer, // GPUBuffer containing the keys to sort\n            values: this.sort_key_buffer, // (optional) GPUBuffer containing the associated values\n            count: this.numGaussians, // Number of elements to sort\n            check_order: true, // Whether to check if the input is already sorted to exit early\n            bit_count: 32, // Number of bits per element. Must be a multiple of 4 (default: 32)\n            workgroup_size: { x: 16, y: 16 }, // Workgroup size in x and y dimensions. (x * y) must be a power of two\n        });\n        console.log(this.radixSortKernel);\n        // Init rasix sort pipeline\n        const sort_shaderModule = this.context.device.createShaderModule({\n            code: getInitSortBufferCode(this.numGaussians, gaussians.nShCoeffs),\n        });\n        const init_sort_bindinglayout = this.context.device.createBindGroupLayout({\n            entries: [\n                {\n                    binding: 0,\n                    visibility: GPUShaderStage.COMPUTE,\n                    buffer: {\n                        type: 'storage',\n                    },\n                },\n                {\n                    binding: 1,\n                    visibility: GPUShaderStage.COMPUTE,\n                    buffer: {\n                        type: 'storage',\n                    },\n                },\n                {\n                    binding: 2,\n                    visibility: GPUShaderStage.COMPUTE,\n                    buffer: {\n                        type: 'uniform',\n                    },\n                },\n                {\n                    binding: 3,\n                    visibility: GPUShaderStage.COMPUTE,\n                    buffer: {\n                        type: 'storage',\n                    },\n                },\n            ],\n        });\n        this.initSortBindGroup = this.context.device.createBindGroup({\n            layout: init_sort_bindinglayout,\n            label: \"initSortBindGroup\",\n            entries: [{\n                    binding: 0,\n                    resource: {\n                        buffer: this.sort_key_buffer,\n                    },\n                }, {\n                    binding: 1,\n                    resource: {\n                        buffer: this.sort_value_buffer,\n                    },\n                }, {\n                    binding: 2,\n                    resource: {\n                        buffer: this.uniformBuffer,\n                    },\n                }, {\n                    binding: 3,\n                    resource: {\n                        buffer: this.pointDataBuffer,\n                    },\n                }],\n        });\n        const init_sort_pipeline_layout = this.context.device.createPipelineLayout({\n            bindGroupLayouts: [init_sort_bindinglayout],\n        });\n        this.init_sort_pipeline = this.context.device.createComputePipeline({\n            layout: init_sort_pipeline_layout,\n            compute: {\n                module: sort_shaderModule,\n                entryPoint: \"main\",\n            }\n        });\n        const indices = new Uint32Array([0, 1, 2, 1, 3, 2,]);\n        this.drawIndexBuffer = this.context.device.createBuffer({\n            size: indices.byteLength,\n            usage: GPUBufferUsage.INDEX | GPUBufferUsage.COPY_DST,\n            mappedAtCreation: true,\n        });\n        new Uint32Array(this.drawIndexBuffer.getMappedRange()).set(indices);\n        this.drawIndexBuffer.unmap();\n        this.simple_render = new SimpleRender(context, canvas, this.pointDataBuffer, this.uniformBuffer, this.sort_key_buffer); //dummy \n        this.post_renderer = new PostProcessRenderer(context, canvas, this.simple_render.framebuffer);\n        // start the animation loop\n        requestAnimationFrame(() => this.animate(true));\n    }\n    destroyImpl() {\n        if (this.destroyCallback === null) {\n            throw new Error(\"destroyImpl called without destroyCallback set!\");\n        }\n        this.uniformBuffer.destroy();\n        this.pointDataBuffer.destroy();\n        this.drawIndexBuffer.destroy();\n        //this.depthSorter.destroy();\n        this.context.destroy();\n        this.destroyCallback();\n    }\n    resize() {\n        this.simple_render = new SimpleRender(this.context, this.canvas, this.pointDataBuffer, this.uniformBuffer, this.sort_key_buffer); //dummy \n        this.post_renderer = new PostProcessRenderer(this.context, this.canvas, this.simple_render.framebuffer);\n    }\n    draw(nextFrameCallback) {\n        const init_encoder = this.context.device.createCommandEncoder();\n        const cs_initSortBuffer_pass = init_encoder.beginComputePass();\n        cs_initSortBuffer_pass.setPipeline(this.init_sort_pipeline);\n        cs_initSortBuffer_pass.setBindGroup(0, this.initSortBindGroup);\n        cs_initSortBuffer_pass.dispatchWorkgroups(Math.max(this.numGaussians / 8, 8), 1, 1);\n        cs_initSortBuffer_pass.end();\n        this.context.device.queue.submit([init_encoder.finish()]);\n        const commandEncoder = this.context.device.createCommandEncoder();\n        const sort_pass = commandEncoder.beginComputePass();\n        this.radixSortKernel.dispatch(sort_pass); // Sort keysBuffer and valuesBuffer in-place on the GPU\n        sort_pass.end();\n        this.context.device.queue.submit([commandEncoder.finish()]);\n        //==========\n        //     Test        \n        //==========\n        /*\n        const _data_size = 4;\n        const _buffer_size = this.numGaussians * _data_size;\n        //const buffer = this.simple_render.vertexBuffer;\n        const buffer = this.sort_key_buffer;\n\n        const readBuffer = this.context.device.createBuffer({\n            size: _buffer_size,\n            usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST,\n            mappedAtCreation: false,\n            label: \"read back buffer\"\n        });\n        const _cmdPass = this.context.device.createCommandEncoder();\n        \n        _cmdPass.copyBufferToBuffer(buffer, 0, readBuffer, 0, _buffer_size);\n        this.context.device.queue.submit([ _cmdPass.finish()]);\n                \n        readBuffer.mapAsync(GPUMapMode.READ).then(() => {\n            const result = new Uint32Array(readBuffer.getMappedRange());\n            \n            console.log(result);\n            readBuffer.unmap();\n        });\n\n        */\n        this.simple_render.draw(this.numGaussians);\n        this.post_renderer.draw();\n        /*\n       \n        const RenderEncoder = this.context.device.createCommandEncoder();\n        \n        const textureView = this.contextGpu.getCurrentTexture().createView();\n        const renderPassDescriptor: GPURenderPassDescriptor = {\n             colorAttachments: [{\n                 view: textureView,\n                 clearValue: { r: 0, g: 0, b: 0, a: 0 },\n                 storeOp: \"store\" as GPUStoreOp,\n                 loadOp: \"clear\" as GPULoadOp,\n             }],\n                 };\n                 \n                 const passEncoder = RenderEncoder.beginRenderPass(renderPassDescriptor);\n                 passEncoder.setPipeline(this.drawPipeline);\n                 \n                 passEncoder.setBindGroup(0, this.uniformsBindGroup);\n                 passEncoder.setBindGroup(1, this.pointDataBindGroup);\n                 \n                 passEncoder.setIndexBuffer(this.drawIndexBuffer, \"uint32\" as GPUIndexFormat)\n                 //passEncoder.drawIndexed(this.numGaussians * 6, 1, 0, 0, 0);\n                 passEncoder.drawIndexed( 6, this.numGaussians);\n                 \n                 passEncoder.end();\n                 this.context.device.queue.submit([RenderEncoder.finish()]);\n                 \n         */\n        // fps counter\n        const now = performance.now();\n        const fps = 1000 / (now - this.lastDraw);\n        this.lastDraw = now;\n        this.fpsCounter.innerText = 'FPS: ' + fps.toFixed(2);\n        this.fpsCounter.style.display = 'block';\n        requestAnimationFrame(nextFrameCallback);\n    }\n    animate(forceDraw) {\n        if (this.destroyCallback !== null) {\n            this.destroyImpl();\n            return;\n        }\n        if (!this.interactiveCamera.isDirty() && !forceDraw) {\n            requestAnimationFrame(() => this.animate());\n            return;\n        }\n        const camera = this.interactiveCamera.getCamera();\n        const position = camera.getPosition();\n        const tanHalfFovX = 0.5 * this.canvas.width / camera.focalX;\n        const tanHalfFovY = 0.5 * this.canvas.height / camera.focalY;\n        this.depthSortMatrix = mat4toArrayOfArrays(camera.viewMatrix);\n        console.log(camera);\n        let uniformsMatrixBuffer = new ArrayBuffer(this.uniformBuffer.size);\n        let viewMat = mat4toArrayOfArrays((camera.viewMatrix));\n        let projMat = mat4toArrayOfArrays((camera.perspective));\n        console.log(camera.perspective);\n        /*\n       viewMat= [\n           [-0.77, 0.05, -0.62, 0],\n           [0.08459874242544174, 0.9963161945343018, -0.014019007794559002, 0],\n           [0.625243604183197, -0.06403473764657974, -0.7777983546257019, 0],\n           [-0.6592757105827332, -0.3823312222957611, 0.2661628723144531, 1],\n       ]\n       // Hand-cord coordinate:\n\n       viewMat= [\n               [0.9940837025642395, -0.012986889109015465, 0.10784024745225906, 0],\n               [0.10758581012487411, 0.25437676906585693, -0.9611029624938965, 0],\n               [-0.014950355514883995, 0.9670181274414062, 0.25426870584487915, 0],\n               [-0.022199857980012894, -1.4709339141845703, -1.2800326347351074, 1],\n           ]\n          \n       viewMat= [\n           [1, 0, 0, 0],\n           [0, 1, 0, 0],\n           [0, 0, -1, 0],\n           [0, 0, -20,1],\n       ]\n      \n       viewMat= [\n           [1, 0, 0, 0],\n           [0, 1, 0, 0],\n           [0, 0, -1, 0],\n           [-0.2712317, 1.554028, 2.063166, 1],\n       ]\n       projMat =\n       [\n           [1.73205, 0, 0, 0],\n           [0, -1.73205, 0, 0],\n           [0, 0, 0.00030, -1],\n           [0, 0, 0.30009, 0],\n       ]\n       */\n        //console.log( viewMat);        \n        //console.log( projMat);\n        let uniforms = {\n            viewMatrix: viewMat,\n            projMatrix: projMat,\n            cameraPosition: Array.from(position),\n            tanHalfFovX: tanHalfFovX,\n            tanHalfFovY: tanHalfFovY,\n            focalX: camera.focalX,\n            focalY: camera.focalY,\n            scaleModifier: camera.scaleModifier,\n        };\n        uniformLayout.pack(0, uniforms, new DataView(uniformsMatrixBuffer));\n        this.context.device.queue.writeBuffer(this.uniformBuffer, 0, uniformsMatrixBuffer, 0, uniformsMatrixBuffer.byteLength);\n        this.draw(() => this.animate());\n    }\n}\n","const shDeg3Code = `\r\n    // spherical harmonic coefficients\r\n    const SH_C0 = 0.28209479177387814f;\r\n    const SH_C1 = 0.4886025119029199f;\r\n    const SH_C2 = array(\r\n        1.0925484305920792f,\r\n        -1.0925484305920792f,\r\n        0.31539156525252005f,\r\n        -1.0925484305920792f,\r\n        0.5462742152960396f\r\n    );\r\n    const SH_C3 = array(\r\n        -0.5900435899266435f,\r\n        2.890611442640554f,\r\n        -0.4570457994644658f,\r\n        0.3731763325901154f,\r\n        -0.4570457994644658f,\r\n        1.445305721320277f,\r\n        -0.5900435899266435f\r\n    );\r\n\r\n    fn compute_color_from_sh(position: vec3<f32>, sh: array<vec3<f32>, 16>) -> vec3<f32> {\r\n        let dir = normalize(position - uniforms.camera_position);\r\n        var result = SH_C0 * sh[0];\r\n\r\n        // if deg > 0\r\n        let x = dir.x;\r\n        let y = dir.y;\r\n        let z = dir.z;\r\n\r\n        result = result + SH_C1 * (-y * sh[1] + z * sh[2] - x * sh[3]);\r\n\r\n        let xx = x * x;\r\n        let yy = y * y;\r\n        let zz = z * z;\r\n        let xy = x * y;\r\n        let xz = x * z;\r\n        let yz = y * z;\r\n\r\n        // if (sh_degree > 1) {\r\n        result = result +\r\n            SH_C2[0] * xy * sh[4] +\r\n            SH_C2[1] * yz * sh[5] +\r\n            SH_C2[2] * (2. * zz - xx - yy) * sh[6] +\r\n            SH_C2[3] * xz * sh[7] +\r\n            SH_C2[4] * (xx - yy) * sh[8];\r\n        \r\n        // if (sh_degree > 2) {\r\n        result = result +\r\n            SH_C3[0] * y * (3. * xx - yy) * sh[9] +\r\n            SH_C3[1] * xy * z * sh[10] +\r\n            SH_C3[2] * y * (4. * zz - xx - yy) * sh[11] +\r\n            SH_C3[3] * z * (2. * zz - 3. * xx - 3. * yy) * sh[12] +\r\n            SH_C3[4] * x * (4. * zz - xx - yy) * sh[13] +\r\n            SH_C3[5] * z * (xx - yy) * sh[14] +\r\n            SH_C3[6] * x * (xx - 3. * yy) * sh[15];\r\n\r\n        // unconditional\r\n        result = result + 0.5;\r\n\r\n        return max(result, vec3<f32>(0.));\r\n    }\r\n`;\nconst shDeg2Code = `\r\n    // spherical harmonic coefficients\r\n    const SH_C0 = 0.28209479177387814f;\r\n    const SH_C1 = 0.4886025119029199f;\r\n    const SH_C2 = array(\r\n        1.0925484305920792f,\r\n        -1.0925484305920792f,\r\n        0.31539156525252005f,\r\n        -1.0925484305920792f,\r\n        0.5462742152960396f\r\n    );\r\n\r\n    fn compute_color_from_sh(position: vec3<f32>, sh: array<vec3<f32>, 9>) -> vec3<f32> {\r\n        let dir = normalize(position - uniforms.camera_position);\r\n        var result = SH_C0 * sh[0];\r\n\r\n        // if deg > 0\r\n        let x = dir.x;\r\n        let y = dir.y;\r\n        let z = dir.z;\r\n\r\n        result = result + SH_C1 * (-y * sh[1] + z * sh[2] - x * sh[3]);\r\n\r\n        let xx = x * x;\r\n        let yy = y * y;\r\n        let zz = z * z;\r\n        let xy = x * y;\r\n        let xz = x * z;\r\n        let yz = y * z;\r\n\r\n        // if (sh_degree > 1) {\r\n        result = result +\r\n            SH_C2[0] * xy * sh[4] +\r\n            SH_C2[1] * yz * sh[5] +\r\n            SH_C2[2] * (2. * zz - xx - yy) * sh[6] +\r\n            SH_C2[3] * xz * sh[7] +\r\n            SH_C2[4] * (xx - yy) * sh[8];\r\n        \r\n        // unconditional\r\n        result = result + 0.5;\r\n\r\n        return max(result, vec3<f32>(0.));\r\n    }\r\n`;\nconst shDeg1Code = `\r\n    // spherical harmonic coefficients\r\n    const SH_C0 = 0.28209479177387814f;\r\n    const SH_C1 = 0.4886025119029199f;\r\n\r\n    fn compute_color_from_sh(position: vec3<f32>, sh: array<vec3<f32>, 4>) -> vec3<f32> {\r\n        let dir = normalize(position - uniforms.camera_position);\r\n        var result = SH_C0 * sh[0];\r\n\r\n        // if deg > 0\r\n        let x = dir.x;\r\n        let y = dir.y;\r\n        let z = dir.z;\r\n\r\n        result = result + SH_C1 * (-y * sh[1] + z * sh[2] - x * sh[3]);\r\n\r\n        // unconditional\r\n        result = result + 0.5;\r\n\r\n        return max(result, vec3<f32>(0.));\r\n    }\r\n`;\nexport function getShaderCode(canvas, shDegree, nShCoeffs, screenPar_w, screenPar_h) {\n    const shComputeCode = {\n        1: shDeg1Code,\n        2: shDeg2Code,\n        3: shDeg3Code,\n    }[shDegree];\n    const shaderCode = `\r\n// for some reason passing these as uniform is broken\r\nconst canvas_height = ${canvas.height};\r\nconst canvas_width = ${canvas.width};\r\nconst sh_degree = ${shDegree};\r\nconst n_sh_coeffs = ${nShCoeffs};\r\n\r\nstruct PointInput {\r\n    @location(0) position: vec3<f32>,\r\n    @location(1) log_scale: vec3<f32>,\r\n    @location(2) rot: vec4<f32>,\r\n    @location(3) opacity_logit: f32,\r\n    sh: array<vec3<f32>, n_sh_coeffs>,\r\n};\r\n\r\nstruct PointOutput {\r\n    @builtin(position) position: vec4<f32>,\r\n    @location(0) color: vec3<f32>,\r\n    @location(1) uv: vec2<f32>,\r\n    @location(2) conic_and_opacity: vec4<f32>,\r\n};\r\n\r\nstruct Uniforms {\r\n    viewMatrix: mat4x4<f32>,\r\n    projMatrix: mat4x4<f32>,\r\n    camera_position: vec3<f32>,\r\n    tan_fovx: f32,\r\n    tan_fovy: f32,\r\n    focal_x: f32,\r\n    focal_y: f32,\r\n    scale_modifier: f32,\r\n};\r\n\r\n${shComputeCode}\r\n\r\nfn sigmoid(x: f32) -> f32 {\r\n    if (x >= 0.) {\r\n        return 1. / (1. + exp(-x));\r\n    } else {\r\n        let z = exp(x);\r\n        return z / (1. + z);\r\n    }\r\n}\r\nfn CalcMatrixFromRotationScale(rot: vec4<f32>, scale: vec3<f32>) -> mat3x3<f32> {\r\n\t\t\tlet ms = mat3x3<f32>(\r\n\t\t\t\tscale.x, 0.0, 0.0,\r\n\t\t\t\t0.0, scale.y, 0.0,\r\n\t\t\t\t0.0, 0.0, scale.z\r\n\t\t\t);\r\n\r\n\t\t\tlet x = rot.x;\r\n\t\t\tlet y = rot.y;\r\n\t\t\tlet z = rot.z;\r\n\t\t\tlet w = rot.w;\r\n\r\n\t\t\tlet mr = mat3x3<f32>(\r\n\t\t\t\t1.0 - 2.0 * (y * y + z * z), 2.0 * (x * y - w * z), 2.0 * (x * z + w * y),\r\n\t\t\t\t2.0 * (x * y + w * z), 1.0 - 2.0 * (x * x + z * z), 2.0 * (y * z - w * x),\r\n\t\t\t\t2.0 * (x * z - w * y), 2.0 * (y * z + w * x), 1.0 - 2.0 * (x * x + y * y)\r\n\t\t\t);\r\n\r\n\t\t\treturn mr * ms;\r\n\t\t}\r\nfn compute_cov3d(log_scale: vec3<f32>, rot: vec4<f32>) -> array<f32, 6> {\r\n\t\tlet modifier = uniforms.scale_modifier;\r\n\t\t\r\n\t\tlet S = mat3x3<f32>(\r\n\t\t\t(log_scale.x) * modifier, 0., 0.,\r\n\t\t\t0., (log_scale.y) * modifier, 0.,\r\n\t\t\t0., 0., (log_scale.z) * modifier,\r\n\t\t);\r\n\t\t\r\n\t\tlet x = rot.x;\r\n\t\tlet y = rot.y;\r\n\t\tlet z = rot.z;\r\n\t\tlet w = rot.w;\r\n\r\n\t\tlet R = mat3x3<f32>(\r\n\t\t\t1-2*(y*y + z*z),   2*(x*y - w*z),   2*(x*z + w*y),\r\n          \t2*(x*y + w*z), 1-2*(x*x + z*z),   2*(y*z - w*x),\r\n          \t2*(x*z - w*y),   2*(y*z + w*x), 1-2*(x*x + y*y)\r\n\t\t);\r\n\r\n\t\tlet M =  R * S;\r\n\r\n\t\t// ------------ CalcCovariance3D ----------------\r\n\t\tlet Sigma = M * transpose(M) ;\t\t\r\n\t\treturn array<f32, 6>(\r\n\t\t\t/*\r\n\t\t\t*/\r\n\t\t\tSigma[0][0],\r\n\t\t\tSigma[0][1],\r\n\t\t\tSigma[0][2],\r\n\t\t\tSigma[1][1],\r\n\t\t\tSigma[1][2],\t\t\t\r\n\t\t\tSigma[2][2],\t\t\t\r\n\t\t);\r\n\t} \r\n\r\n\tfn compute_cov2d(position: vec3<f32>, log_scale: vec3<f32>, rot: vec4<f32>) -> vec3<f32> {\r\n\t\t//let cov3d = compute_cov3d(log_scale, rot);\t\t\r\n        let splatRotScaleMat : mat3x3<f32> = CalcMatrixFromRotationScale(rot, log_scale);\t\t\t\r\n\t\t\t\r\n\t\tlet sig :  mat3x3<f32> = splatRotScaleMat * transpose(splatRotScaleMat);\r\n\t\tvar cov3d0 : vec3f = vec3f (sig[0][0] , sig[0][1] , sig[0][2]  );\r\n\t\tvar cov3d1 : vec3f = vec3f (sig[1][1] , sig[1][2] , sig[2][2]  );\r\n\t\t\t\r\n\t\tlet _VecScreenParams = vec4f(${600},${600},0,0);\r\n\r\n        // Cov2d:\t\t\t\r\n        var viewPos:vec3f = (uniforms.viewMatrix * vec4<f32>(position, 1.0)).xyz;\r\n        let aspect = uniforms.projMatrix[0][0] / uniforms.projMatrix[1][1] ;  // = 1\r\n\r\n        let tanFovX: f32 = 1.0 / uniforms.projMatrix[0][0];\r\n        let tanFovY: f32 = 1.0 / (uniforms.projMatrix[1][1] * aspect);\r\n\r\n        let limx = 1.3 * tanFovX;\r\n        let limy = 1.3 * tanFovY;\r\n        let txtz = viewPos.x / viewPos.z;\r\n        let tytz = viewPos.y / viewPos.z;\r\n\r\n        viewPos.x = min(limx, max(-limx, txtz)) * viewPos.z;\r\n        viewPos.y = min(limy, max(-limy, tytz)) * viewPos.z;\r\n\r\n        let focal = _VecScreenParams.x * uniforms.projMatrix[0][0] / 2;\r\n        let J = mat3x3(\r\n            focal / viewPos.z, 0., -(focal * viewPos.x) / (viewPos.z * viewPos.z),\r\n            0., focal / viewPos.z, -(focal * viewPos.y) / (viewPos.z * viewPos.z),\r\n            0., 0., 0., \r\n        );\r\n\r\n        let W = mat3x3<f32>(\r\n            uniforms.viewMatrix[0].xyz,\r\n            uniforms.viewMatrix[1].xyz,\r\n            uniforms.viewMatrix[2].xyz\r\n        );\r\n        \r\n        let T = J * W;\r\n\r\n        let Vrk = mat3x3(\r\n            cov3d0.x, cov3d0.y, cov3d0.z,\r\n            cov3d0.y, cov3d1.x, cov3d1.y,\r\n            cov3d0.z, cov3d1.y, cov3d1.z\t\r\n        );\r\n\r\n        //var cov2d_mat = transpose(T) * transpose(Vrk) * T;\r\n        var cov2d_mat = T * ((Vrk) * transpose(T));\r\n        cov2d_mat[0][0] += 0.3;\r\n        cov2d_mat[1][1] += 0.3;\r\n\r\n        let cov2d :vec3f  = vec3f(cov2d_mat[0][0] , -cov2d_mat[0][1] , cov2d_mat[1][1]);\r\n\r\n\t\t//return vec3<f32>(cov[0][0], cov[0][1], cov[1][1]);\r\n        return cov2d;\r\n\t}\r\n\r\n\r\n@binding(0) @group(0) var<uniform> uniforms: Uniforms;\r\n@binding(1) @group(1) var<storage, read> points: array<PointInput>;\r\n@binding(2) @group(1) var<storage, read> sorted_idx: array<u32>;\r\n\r\nfn asfloat(hex: u32) -> f32 {\r\n    let float_value = bitcast<f32>(hex);\r\n    return float_value;\r\n}\r\n@vertex\r\nfn vs_points(\r\n    //@builtin(vertex_index) vertex_index: u32\r\n    @builtin(vertex_index) vtxID: u32,\r\n    @builtin(instance_index) instID: u32\r\n    ) -> PointOutput {\r\n\r\n    var output: PointOutput;\r\n    let p_idx = sorted_idx[instID];\r\n    let point = points[p_idx];\r\n    let idx = vtxID;\r\n\r\n    var clipPos = uniforms.projMatrix  * uniforms.viewMatrix *  vec4<f32>(point.position, 1.0);    \r\n    //var clipPos = uniforms.projMatrix  *  vec4<f32>(point.position, 1.0);    \r\n\r\n    if(clipPos.w<=0){\r\n        let nanfloat = asfloat(0x7fc00000);\r\n        output.position = vec4<f32>(nanfloat , nanfloat , nanfloat,nanfloat); // NaN discards the primitive\r\n    }\r\n    else{\r\n\r\n        var quadPos = vec2<f32>(\r\n            f32(idx&1), \r\n            f32((idx>>1)&1)\r\n            ) * 2.0 -1 ;\r\n        quadPos *=2;\r\n        output.uv  = quadPos;\r\n        output.position  = clipPos  ;\r\n        \r\n\r\n        // cov3d:\r\n        let splatRotScaleMat : mat3x3<f32> = CalcMatrixFromRotationScale(point.rot, point.log_scale);\t\t\t\r\n\t\t\t\r\n\t\tlet sig :  mat3x3<f32> = splatRotScaleMat * transpose(splatRotScaleMat);\r\n\t\tvar cov3d0 : vec3f = vec3f (sig[0][0] , sig[0][1] , sig[0][2]  );\r\n\t\tvar cov3d1 : vec3f = vec3f (sig[1][1] , sig[1][2] , sig[2][2]  );\r\n\t\tlet _VecScreenParams = vec4f(${600},${600},0,0);\r\n\r\n\t\toutput.uv *= cov3d1.yz;\r\n        let splatScale = 1.0;\r\n        let splatScale2 = splatScale * splatScale;\r\n\t\tcov3d0 *= splatScale2;\r\n\t\tcov3d1 *= splatScale2;\r\n\r\n        // Cov2d:\t\t\t\r\n        var viewPos:vec3f = (uniforms.viewMatrix * vec4<f32>(point.position, 1.0)).xyz;\r\n        let aspect = uniforms.projMatrix[0][0] / uniforms.projMatrix[1][1] ;  // = 1\r\n\r\n        let tanFovX: f32 = 1.0 / uniforms.projMatrix[0][0];\r\n        let tanFovY: f32 = 1.0 / (uniforms.projMatrix[1][1] * aspect);\r\n\r\n        let limx = 1.3 * tanFovX;\r\n        let limy = 1.3 * tanFovY;\r\n        let txtz = viewPos.x / viewPos.z;\r\n        let tytz = viewPos.y / viewPos.z;\r\n\r\n        viewPos.x = min(limx, max(-limx, txtz)) * viewPos.z;\r\n        viewPos.y = min(limy, max(-limy, tytz)) * viewPos.z;\r\n\r\n        let focal = _VecScreenParams.x * uniforms.projMatrix[0][0] / 2;\r\n        let J = mat3x3(\r\n            focal / viewPos.z, 0., -(focal * viewPos.x) / (viewPos.z * viewPos.z),\r\n            0., focal / viewPos.z, -(focal * viewPos.y) / (viewPos.z * viewPos.z),\r\n            0., 0., 0., \r\n        );\r\n\r\n        let W = mat3x3<f32>(\r\n            uniforms.viewMatrix[0].xyz,\r\n            uniforms.viewMatrix[1].xyz,\r\n            uniforms.viewMatrix[2].xyz\r\n        );\r\n        \r\n        let T = J * W;\r\n\r\n        let Vrk = mat3x3(\r\n            cov3d0.x, cov3d0.y, cov3d0.z,\r\n            cov3d0.y, cov3d1.x, cov3d1.y,\r\n            cov3d0.z, cov3d1.y, cov3d1.z\t\r\n        );\r\n\r\n        //var cov2d_mat = transpose(T) * transpose(Vrk) * T;\r\n        var cov2d_mat = T * ((Vrk) * transpose(T));\r\n        cov2d_mat[0][0] += 0.3;\r\n        cov2d_mat[1][1] += 0.3;\r\n\r\n        let cov2d :vec3f  = vec3f(cov2d_mat[0][0] , -cov2d_mat[0][1] , cov2d_mat[1][1]);\r\n        //let cov2d = compute_cov2d(point.position, point.log_scale, point.rot);\r\n\r\n        let det = cov2d.x * cov2d.z - cov2d.y * cov2d.y;\r\n        let det_inv = 1.0 / det;\r\n        let conic = vec3<f32>(cov2d.z * det_inv, -cov2d.y * det_inv, cov2d.x * det_inv);\r\n        output.conic_and_opacity = vec4<f32>(conic, sigmoid(point.opacity_logit));\r\n        \r\n        let diag1 =  cov2d.x;\r\n\t\tlet diag2 =  cov2d.z;\r\n\t\tlet offDiag =  cov2d.y;\t\r\n        var mid =  0.5 *  (diag1 + diag2);\r\n        var radius = length(vec2<f32>((diag1 - diag2) /2.0  , offDiag));\r\n        var lambda1 = mid + radius;\r\n        var lambda2 = max(mid - radius , 0.1);\r\n        var diagVec : vec2<f32> = normalize(vec2<f32>(offDiag , lambda1 - diag1));\r\n        diagVec.y = -diagVec.y;\r\n\r\n        let maxSize :f32 = 4096.0;\r\n\t\tlet v1 : vec2<f32> = min(sqrt(2.0 * lambda1) , maxSize) * diagVec;        \r\n\t\tlet v2 : vec2<f32> = min(sqrt(2.0 * lambda2) , maxSize) * vec2<f32>(diagVec.y , -diagVec.x);\r\n        \r\n        let _ScreenParams : vec2<f32> = vec2<f32>(${screenPar_w} , ${screenPar_h});       \r\n        \r\n        let deltaScreenPos :vec2<f32> = (quadPos.x * v1 + quadPos.y * v2) * 2 / _ScreenParams.xy;\r\n        \r\n        output.position  .x += deltaScreenPos.x * clipPos.w;\r\n        output.position  .y += deltaScreenPos.y * clipPos.w;\r\n        \r\n        output.color = compute_color_from_sh(point.position, point.sh);\r\n    }\r\n\r\n\r\n\t\r\n    /*\r\n    let cov2d = compute_cov2d(point.position, point.log_scale, point.rot);\r\n    let det = cov2d.x * cov2d.z - cov2d.y * cov2d.y;\r\n    let det_inv = 1.0 / det;\r\n    let conic = vec3<f32>(cov2d.z * det_inv, -cov2d.y * det_inv, cov2d.x * det_inv);\r\n    output.conic_and_opacity = vec4<f32>(conic, sigmoid(point.opacity_logit));\r\n\r\n    var projPosition = uniforms.projMatrix * vec4<f32>(point.position, 1.0);   \r\n    if(projPosition.w <=0){\r\n        //behind camera\r\n        output.uv = vec2f(-99,-99);\r\n        return output;\r\n    }\r\n    var mid =  0.5 * (cov2d.x + cov2d.z);\r\n\tvar radius = length(vec2<f32>((cov2d.x - cov2d.z) /2.0  , cov2d.y));\r\n\tvar lambda1 = mid + radius;\r\n\tvar lambda2 = max(mid - radius , 0.1);\r\n\tvar diagVec : vec2<f32> = normalize(vec2<f32>(cov2d.y , lambda1 - lambda2));\r\n\tdiagVec.y = -diagVec.y;\r\n\t\t\r\n\tlet maxSize :f32 = 4096.0;\r\n\tlet v1 : vec2<f32> = min(sqrt(2.0 * lambda1) , maxSize) * diagVec;\r\n\tlet v2 : vec2<f32> = min(sqrt(2.0 * lambda2) , maxSize) * vec2<f32>(diagVec.y , -diagVec.x);\r\n\r\n    let _ScreenParams : vec2<f32> = vec2<f32>(${screenPar_w} , ${screenPar_h});\r\n    \r\n    output.uv  = quadPos;\r\n    output.position  = projPosition;\r\n    let deltaScreenPos :vec2<f32> = (quadPos.x * v1 + quadPos.y * v2) * 2 / _ScreenParams.xy;\r\n\r\n\toutput.position  .x += deltaScreenPos.x * projPosition.w;\r\n\toutput.position  .y += deltaScreenPos.y * projPosition.w;\r\n\r\n    output.color = compute_color_from_sh(point.position, point.sh);\r\n    */\r\n\r\n    return output;\r\n}\r\n\r\n@fragment\r\nfn fs_main(input: PointOutput) -> @location(0) vec4<f32> {\r\n   \r\n    let selectedColor : vec3<f32> = vec3<f32> (1,0,1);\r\n    var opacity = input.conic_and_opacity.w;   \r\n    var color : vec4<f32> = vec4<f32> (input.color ,opacity);\r\n    let power :f32 = -dot(input.uv, input.uv);\r\n    var alpha :f32 = exp(power);\r\n    if(opacity>=0){\r\n        alpha = saturate(alpha * opacity );\r\n    }\r\n    /*\r\n    */\r\n    else{\r\n        if(alpha > 7.0/255.0){\r\n            if(alpha < 10.0 /255.0){\r\n                alpha = 1;\r\n                color = vec4<f32> (selectedColor , color.a);\r\n            }\r\n            alpha = saturate(alpha +0.3);\r\n        }\r\n        color = vec4<f32> ( mix(input.color.rgb , selectedColor , 0.5 ) , color.a);\r\n    }\r\n    if(alpha < 1.0/255.0){\r\n        discard;\r\n    }\r\n    \r\n    \r\n    return vec4<f32>(input.color * alpha, alpha);\r\n    //return vec4<f32>(alpha,alpha,alpha, 1);\r\n    //return vec4<f32>(color.rgb, 1);\r\n    //return color;\r\n}\r\n`;\n    return shaderCode;\n}\n//======================\n//      Init Sort buffer\n//======================\nexport function getInitSortBufferCode(count, nShCoeffs) {\n    const WORKGROUP_SIZE = 8;\n    return `\r\n        \r\n        const n_sh_coeffs = ${nShCoeffs};\r\n        struct PointInput {\r\n            @location(0) position: vec3<f32>,\r\n            @location(1) log_scale: vec3<f32>,\r\n            @location(2) rot: vec4<f32>,\r\n            @location(3) opacity_logit: f32,\r\n            sh: array<vec3<f32>, n_sh_coeffs>,\r\n        };\r\n\r\n        struct Uniforms {\r\n            viewMatrix: mat4x4<f32>,\r\n            projMatrix: mat4x4<f32>,\r\n            camera_position: vec3<f32>,\r\n            tan_fovx: f32,\r\n            tan_fovy: f32,\r\n            focal_x: f32,\r\n            focal_y: f32,\r\n            scale_modifier: f32,\r\n        };\r\n\r\n        @group(0) @binding(0) var<storage,read_write> \tgaussian_keys_unsorted\t\t: array<u32>;\r\n\t\t@group(0) @binding(1) var<storage,read_write> \tgaussian_values_unsorted\t: array<u32>; \r\n\t\t@group(0) @binding(2) var<uniform> \t\t\t\tuniforms: Uniforms;\r\n\t\t@group(0) @binding(3) var<storage,read_write> \tsplatPos: array<PointInput>; \t\t\r\n\t\t\r\n\t\tfn float_to_sortable_uint(f: f32) -> u32 {\r\n\t\t\tlet fu: u32 = bitcast<u32>(f);\r\n\t\t\tlet mask: u32 = bitcast<u32>(-(bitcast<i32>(fu) >> 31)) | 0x80000000u;\r\n\t\t\treturn fu ^ mask;\r\n\t\t}\r\n\r\n\t\t@compute\r\n\t\t@workgroup_size(  ${WORKGROUP_SIZE}, 1,1 )\r\n\t\tfn main(\t\t\t\r\n\t\t\t@builtin(workgroup_id) workgroup_id : vec3<u32>,\r\n\t\t\t@builtin(local_invocation_id) local_invocation_id : vec3<u32>,\r\n\t\t\t@builtin(global_invocation_id) global_invocation_id : vec3<u32>,\r\n\t\t\t@builtin(local_invocation_index) local_invocation_index: u32,\r\n\t\t\t@builtin(num_workgroups) num_workgroups: vec3<u32>) {\r\n\r\n\t\t\tlet workgroup_index =  \r\n\t\t\t\tworkgroup_id.x +\r\n\t\t\t\tworkgroup_id.y * num_workgroups.x +\r\n\t\t\t\tworkgroup_id.z * num_workgroups.x * num_workgroups.y;\r\n            /*\r\n            */\r\n\t\t\tlet idx =\r\n\t\t\t\tworkgroup_index * ${WORKGROUP_SIZE} +\r\n\t\t\t\tlocal_invocation_index;\r\n                \r\n            if(idx >= ${count}){\r\n                    return;\r\n            }\r\n            \r\n\r\n\t\t\tgaussian_keys_unsorted[idx] = idx;\r\n\t\t\tlet pos : vec3<f32> = (uniforms.viewMatrix * vec4<f32> (splatPos[idx].position.xyz , 1.0)).xyz;\r\n\t\t\tgaussian_values_unsorted[idx] = float_to_sortable_uint(pos.z);\r\n\t\t\t//gaussian_values_unsorted[idx] =pos.z;\r\n\t\t\t//gaussian_values_unsorted[idx] =idx;\r\n\t\t\t\r\n\t\t\t\r\n\t\t}\r\n    `;\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { loadFileAsArrayBuffer, PackedGaussians } from './ply';\nimport { CameraFileParser, InteractiveCamera } from './camera';\nimport { Renderer } from './renderer';\nif (!navigator.gpu) {\n    alert(\"WebGPU not supported on this browser! (navigator.gpu is null)\");\n}\n// grab the DOM elements\nconst canvas = document.getElementById(\"canvas-webgpu\");\nconst loadingPopup = document.getElementById('loading-popup');\nconst fpsCounter = document.getElementById('fps-counter');\nconst cameraFileInput = document.getElementById('cameraButton');\nconst cameraList = document.getElementById('cameraList');\nconst plyFileInput = document.getElementById('plyButton');\ncanvas.width = window.innerWidth;\ncanvas.height = window.innerHeight;\n// create the camera and renderer globals\nlet interactiveCamera = InteractiveCamera.default(canvas);\nvar currentRenderer;\n// swap the renderer when the ply file changes\nfunction handlePlyChange(event) {\n    const file = event.target.files[0];\n    function onFileLoad(arrayBuffer) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (currentRenderer) {\n                yield currentRenderer.destroy();\n            }\n            const gaussians = new PackedGaussians(arrayBuffer);\n            try {\n                const context = yield Renderer.requestContext(gaussians);\n                const renderer = new Renderer(canvas, interactiveCamera, gaussians, context, fpsCounter);\n                currentRenderer = renderer; // bind to the global scope\n                loadingPopup.style.display = 'none'; // hide loading popup\n            }\n            catch (error) {\n                loadingPopup.style.display = 'none'; // hide loading popup\n                alert(error);\n            }\n        });\n    }\n    if (file) {\n        loadingPopup.style.display = 'block'; // show loading popup\n        loadFileAsArrayBuffer(file)\n            .then(onFileLoad);\n    }\n}\n// loads the default ply file (bundled with the source) at startup, useful for dev\nfunction loadDefaultPly() {\n    return __awaiter(this, void 0, void 0, function* () {\n        // Parse url\n        console.log(window.location.href);\n        const urlObj = new URL(window.location.href);\n        const params = new URLSearchParams(urlObj.search);\n        var url = \"ply.ply\";\n        if (params.has(\"model\")) {\n            const model_name = params.get('model');\n            url = model_name + \".ply\";\n        }\n        // Get specific parameter values\n        //const url = \"ply.ply\";\n        //const url = \"ply3.ply\";\n        //const url = \"m3splat.ply\";\n        loadingPopup.style.display = 'block'; // show loading popup\n        const content = yield fetch(url);\n        const arrayBuffer = yield content.arrayBuffer();\n        const gaussians = new PackedGaussians(arrayBuffer);\n        const context = yield Renderer.requestContext(gaussians);\n        const renderer = new Renderer(canvas, interactiveCamera, gaussians, context, fpsCounter);\n        currentRenderer = renderer; // bind to the global scope\n        loadingPopup.style.display = 'none'; // hide loading popup\n    });\n}\n// DEV: uncomment this line to load the default ply file at startup\nloadDefaultPly();\n// add event listeners\nplyFileInput.addEventListener('change', handlePlyChange);\nconst camParser = new CameraFileParser(cameraFileInput, cameraList, canvas, (camera) => interactiveCamera.setNewCamera(camera));\nfunction loadDefaultCamera() {\n    return __awaiter(this, void 0, void 0, function* () {\n        const url = \"cam.json\";\n        const content = yield fetch(url);\n        if (content.ok) {\n            const data = yield content.json();\n            console.log(data);\n            camParser.handleJsonData(data);\n        }\n    });\n}\nloadDefaultCamera();\n// Resize callback\nfunction resizeCanvas() {\n    canvas.width = window.innerWidth;\n    canvas.height = window.innerHeight;\n    currentRenderer.resize();\n}\nwindow.addEventListener('resize', resizeCanvas);\n"],"names":["exports","_arrayLikeToArray","r","a","length","e","n","Array","_assertClassBrand","t","has","arguments","TypeError","_classCallCheck","_classPrivateMethodInitSpec","_checkPrivateRedeclaration","add","_defineProperties","o","enumerable","configurable","writable","Object","defineProperty","_toPropertyKey","key","_createClass","prototype","_defineProperty","value","ownKeys","keys","getOwnPropertySymbols","filter","getOwnPropertyDescriptor","push","apply","_objectSpread2","forEach","getOwnPropertyDescriptors","defineProperties","_toConsumableArray","isArray","_arrayWithoutHoles","Symbol","iterator","from","_iterableToArray","toString","call","slice","constructor","name","test","_unsupportedIterableToArray","_nonIterableSpread","i","toPrimitive","String","Number","_toPrimitive","find_optimal_dispatch_size","device","workgroup_count","dispatchSize","x","y","limits","maxComputeWorkgroupsPerDimension","Math","floor","sqrt","ceil","create_buffer_from_data","_ref","label","data","_ref$usage","usage","dispatchSizes","createBuffer","size","mappedAtCreation","Uint32Array","getMappedRange","set","unmap","PrefixSumKernel","count","_ref$workgroup_size","workgroup_size","_ref$avoid_bank_confl","avoid_bank_conflicts","this","threads_per_workgroup","items_per_workgroup","log2","Error","concat","pipelines","shaderModule","createShaderModule","code","create_pass_recursive","blockSumBuffer","GPUBufferUsage","STORAGE","COPY_SRC","COPY_DST","bindGroupLayout","createBindGroupLayout","entries","binding","visibility","GPUShaderStage","COMPUTE","buffer","type","bindGroup","createBindGroup","layout","resource","pipelineLayout","createPipelineLayout","bindGroupLayouts","scanPipeline","createComputePipeline","compute","module","entryPoint","constants","pipeline","blockSumPipeline","flatMap","p","pass","dispatchSizeBuffer","offset","undefined","_this$pipelines$i","setPipeline","setBindGroup","dispatchWorkgroups","dispatchWorkgroupsIndirect","radixSortReorderSource","checkSortSource","isLastPass","kernelMode","first_pass_load_data","last_pass","write_reduction_result","last_pass_full","last_pass_fast","CheckSortKernel","result","original","is_sorted","_ref$start","start","_ref$mode","mode","buffers","outputs","create_passes_recursive","passIndex","isFirstPass","outputBuffer","element_count","start_element","checkSortPipeline","dispatchIndirect","item_count","sizes","target_workgroup_count","_RadixSortKernel_brand","WeakSet","RadixSortKernel","values","_ref$bit_count","bit_count","_ref$check_order","check_order","_ref$local_shuffle","local_shuffle","isInteger","prefix_block_workgroup_count","has_values","shaderModules","kernels","create_shader_modules","create_pipelines","remove_values","source","split","line","toLowerCase","includes","join","blockSumSource","blockSum","reorder","create_prefix_sum_kernel","dispatchData","calculate_dispatch_sizes","create_buffers","create_check_sort_kernels","bit","even","inKeys","tmpKeys","inValues","tmpValues","outKeys","outValues","create_block_sum_pipeline","reorderPipeline","create_reorder_pipeline","prefixBlockSumBuffer","prefixSumKernel","prefixSum","prefixBlockSum","prefixSumDispatchSize","get_dispatch_chain","check_sort_fast_count","min","check_sort_full_count","start_full","dispatchSizesFast","find_optimal_dispatch_chain","dispatchSizesFull","initialDispatch","dispatchOffsets","radix_sort","check_sort_fast","prefix_sum","tmpKeysBuffer","tmpValuesBuffer","localPrefixSumBuffer","localPrefixSum","dispatchBuffer","INDIRECT","originalDispatchBuffer","checkSortFullDispatchBuffer","checkSortFullOriginalDispatchBuffer","isSortedBuffer","originalDispatchSize","checkSortFullDispatchSize","originalCheckSortFullDispatchSize","isSorted","checkSortPartitionData","checkSortFull","checkSortFast","initialDispatchElementCount","console","warn","checkSortReset","checkSort","reset","fast","full","_dispatchPipelinesIndirect","_dispatchPipelines","dispatch","_this$pipelines$i2","factory","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","dotF","b","roundUp","multiple","PackingError","message","super","PackingType","alignment","pack","view","setInt32","unpack","content","getInt32","setUint32","getUint32","f32","setFloat32","getFloat32","VectorType","baseType","nValues","newOffset","vec2","vec3","vec4","Struct","members","max","map","_name","_","expectedKeys","_type","actualKeys","every","startingOffset","StaticArray","nElements","stride","MatrixType","nRows","nColumns","vecType","startOffset","j","outerValues","innerValues","mat4x4","PackedGaussians","decodeHeader","plyArrayBuffer","decoder","TextDecoder","headerOffset","headerText","headerChunk","Uint8Array","decode","headerLines","vertexCount","propertyTypes","trim","startsWith","vertexCountMatch","match","parseInt","propertyMatch","propertyType","vertexByteOffset","indexOf","DataView","readRawVertex","vertexData","rawVertex","property","Float32Array","BYTES_PER_ELEMENT","getUint8","nShCoeffs","sphericalHarmonicsDegree","arrangeVertex","shFeatureOrder","shCoeffs","coeff","coeffName","position","z","logScale","scale_0","scale_1","scale_2","rotQuat","rot_0","rot_1","rot_2","rot_3","opacityLogit","opacity","normalizeV4","xyzw","len","NormalizeSwizzleRotation","wxyz","PackSmallest3Rotation","q","absQ","abs","index","maxV","s","three","SQRT2","LinearScale","exp","arrayBuffer","numGaussians","nRestCoeffs","propertyName","nCoeffsPerColor","log","rgb","gaussianLayout","gaussianArrayLayout","positionsLayout","positionsArrayLayout","gaussiansBuffer","ArrayBuffer","gaussianWriteView","positionsBuffer","positionsWriteView","readOffset","gaussianWriteOffset","positionWriteOffset","newReadOffset","qq","idx","round","c","d","result_rot","EPSILON","VecType$1","create$4","dst","ctorMap","Map","Float64Array","fill","newMat3","get","mat3Impl","v0","v1","v2","v3","v4","v5","v6","v7","v8","subtract$2","lerp$2","mulScalar$2","v","k","inverse$3","cross","t1","t2","dot$2","length$2","lengthSq$2","distance$1","dx","dy","dz","distanceSq$1","normalize$2","copy$3","multiply$3","divide$1","setLength$1","vec3Impl","__proto__","addScaled","scale","angle","ax","ay","az","bx","by","bz","mag","cosine","acos","clamp","clone","copy","create","dist","distSq","distance","distanceSq","div","divScalar","divide","dot","equals","equalsApproximately","fromValues","getAxis","m","axis","off","getScaling","xx","xy","xz","yx","yy","yz","zx","zy","zz","getTranslation","inverse","invert","lenSq","lengthSq","lerp","lerpV","midpoint","mul","mulScalar","multiply","negate","normalize","random","PI","zScale","cos","sin","rotateX","rad","rotateY","rotateZ","setDefaultType","ctor","oldType","setLength","sub","subtract","transformMat3","transformMat4","w","transformMat4Upper3x3","transformQuat","qx","qy","qz","w2","uvX","uvY","uvZ","truncate","maxLen","zero","xAxis","yAxis","zAxis","MatType","copy$2","identity$1","inverse$2","m00","m01","m02","m03","m10","m11","m12","m13","m20","m21","m22","m23","m30","m31","m32","m33","tmp0","tmp1","tmp2","tmp3","tmp4","tmp5","tmp6","tmp7","tmp8","tmp9","tmp10","tmp11","tmp12","tmp13","tmp14","tmp15","tmp16","tmp17","tmp18","tmp19","tmp20","tmp21","tmp22","tmp23","t0","t3","multiply$2","a00","a01","a02","a03","a10","a11","a12","a13","a20","a21","a22","a23","a30","a31","a32","a33","b00","b01","b02","b03","b10","b11","b12","b13","b20","b21","b22","b23","b30","b31","b32","b33","axisRotation","angleInRadians","oneMinusCosine","axisRotate","r00","r01","r02","r10","r11","r12","r20","r21","r22","mat4Impl","aim","target","up","cameraAim","eye","v9","v10","v11","v12","v13","v14","v15","determinant","fromMat3","m3","fromQuat","x2","y2","z2","wx","wy","wz","frustum","left","right","bottom","top","near","far","frustumReverseZ","Infinity","rangeInv","identity","lookAt","ortho","perspective","fieldOfViewYInRadians","aspect","zNear","zFar","f","tan","isFinite","perspectiveReverseZ","rotate","rotation","rotationX","rotationY","rotationZ","scaling","setAxis","setTranslation","translate","translation","transpose","uniformScale","uniformScaling","Camera","height","width","viewMatrix","focalX","focalY","scaleModifier","window","innerHeight","innerWidth","dotZ","depthAxis","getPosition","inverseViewMatrix","getProjMatrix","flippedY","diagonal4x4","viewInv","InteractiveCamera","camera","canvas","drag","oldX","oldY","dRX","dRY","dRZ","dTX","dTY","dTZ","dirty","createCallbacks","default","addEventListener","pageX","pageY","setDirty","preventDefault","deltaY","keyMap","setNewCamera","newCamera","setClean","isDirty","getCamera","focal2fov","focal","pixels","atan","GpuContext","gpu","adapter","thisArg","_arguments","generator","navigator","Promise","reject","requestAdapter","requestDevice","P","resolve","fulfilled","step","next","rejected","done","then","destroy","SimpleRender","_contex","_canvas","_pointBuffer","_uniformBuffer","_sortIdxBuffer","presentationFormat","contextGpu","getContext","context","vertices","vertexBuffer","byteLength","VERTEX","queue","writeBuffer","draw_bindinglayout","FRAGMENT","pointBindGroup","draw_pipeline_layout","shader_code","createRenderPipeline","vertex","arrayStride","attributes","format","shaderLocation","fragment","targets","blend","color","srcFactor","dstFactor","operation","alpha","primitive","topology","stripIndexFormat","cullMode","indices","drawIndexBuffer","INDEX","pp_splat_pos_Buffer","point_number","pp_splat_axis_Buffer","preprocess_bindinglayout","preprocess_BindGroup","preprocess_pipeline_layout","pre_processPipeline","textureDescriptor","GPUTextureUsage","RENDER_ATTACHMENT","TEXTURE_BINDING","framebufferTexture","createTexture","framebuffer","draw","gs_number","commandEncoder","createCommandEncoder","renderPassDescriptor","colorAttachments","createView","clearValue","g","storeOp","loadOp","passEncoder","beginRenderPass","setVertexBuffer","setIndexBuffer","drawIndexed","end","submit","finish","PostProcessRenderer","_context","texture","vbo","cellShaderModule","sampleType","sampler","pipeline_layout","post_process_pipeline","createSampler","magFilter","minFilter","getCurrentTexture","uniformLayout","mat4toArrayOfArrays","Renderer","requestContext","gaussians","requiredLimits","maxStorageBufferBindingSize","maxBufferSize","destroyCallback","interactiveCamera","fpsCounter","lastDraw","performance","now","configure","alphaMode","pointDataBuffer","uniformBuffer","UNIFORM","shaderCode","shDegree","screenPar_w","screenPar_h","shComputeCode","getShaderCode","draw_uniform_bindinglayout","draw_data_bindinglayout","drawPipeline","sort_key_buffer","sort_value_buffer","uniformsBindGroup","pointDataBindGroup","radixSortKernel","sort_shaderModule","init_sort_bindinglayout","initSortBindGroup","init_sort_pipeline_layout","init_sort_pipeline","simple_render","post_renderer","requestAnimationFrame","animate","destroyImpl","resize","nextFrameCallback","init_encoder","cs_initSortBuffer_pass","beginComputePass","sort_pass","fps","innerText","toFixed","style","display","forceDraw","tanHalfFovX","tanHalfFovY","depthSortMatrix","uniformsMatrixBuffer","viewMat","projMat","uniforms","projMatrix","cameraPosition","alert","document","getElementById","loadingPopup","cameraFileInput","cameraList","plyFileInput","currentRenderer","location","href","urlObj","URL","params","URLSearchParams","search","url","fetch","renderer","loadDefaultPly","event","file","files","reader","FileReader","onload","onerror","error","readAsArrayBuffer","loadFileAsArrayBuffer","camParser","fileInput","listElement","cameraSetCallback","currentLineId","handleFileInputChange","_a","handleFileLoad","readAsText","contents","jsonData","JSON","parse","innerHTML","handleJsonData","createCallbackForLine","json","cameraJSON","listItem","createElement","rawCamera","canvasW","canvasH","projectionMatrix","znear","zfar","fovX","fovY","z_sign","getProjectionMatrix","fx","fy","R","R_","camToWorld","minusT","worldToCamFromRT","flat","cameraFromJSON","textContent","img_name","appendChild","ok","loadDefaultCamera"],"sourceRoot":""}