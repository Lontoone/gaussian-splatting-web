(()=>{var t={949:function(t,e){!function(t){"use strict";function e(t,e){(null==e||e>t.length)&&(e=t.length);for(var n=0,i=Array(e);n<e;n++)i[n]=t[n];return i}function n(t,e,n){if("function"==typeof t?t===e:t.has(e))return arguments.length<3?e:n;throw new TypeError("Private element is not present on this object")}function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function r(t,e){(function(t,e){if(e.has(t))throw new TypeError("Cannot initialize the same private elements twice on an object")})(t,e),e.add(t)}function o(t,e){for(var n=0;n<e.length;n++){var i=e[n];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(t,f(i.key),i)}}function a(t,e,n){return e&&o(t.prototype,e),n&&o(t,n),Object.defineProperty(t,"prototype",{writable:!1}),t}function s(t,e,n){return(e=f(e))in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function u(t,e){var n=Object.keys(t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(t);e&&(i=i.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),n.push.apply(n,i)}return n}function c(t){for(var e=1;e<arguments.length;e++){var n=null!=arguments[e]?arguments[e]:{};e%2?u(Object(n),!0).forEach((function(e){s(t,e,n[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(n)):u(Object(n)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(n,e))}))}return t}function l(t){return function(t){if(Array.isArray(t))return e(t)}(t)||function(t){if("undefined"!=typeof Symbol&&null!=t[Symbol.iterator]||null!=t["@@iterator"])return Array.from(t)}(t)||function(t,n){if(t){if("string"==typeof t)return e(t,n);var i={}.toString.call(t).slice(8,-1);return"Object"===i&&t.constructor&&(i=t.constructor.name),"Map"===i||"Set"===i?Array.from(t):"Arguments"===i||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i)?e(t,n):void 0}}(t)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function f(t){var e=function(t,e){if("object"!=typeof t||!t)return t;var n=t[Symbol.toPrimitive];if(void 0!==n){var i=n.call(t,e||"default");if("object"!=typeof i)return i;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===e?String:Number)(t)}(t,"string");return"symbol"==typeof e?e:e+""}function d(t,e){var n={x:e,y:1};if(e>t.limits.maxComputeWorkgroupsPerDimension){var i=Math.floor(Math.sqrt(e)),r=Math.ceil(e/i);n.x=i,n.y=r}return n}function p(t){var e=t.device,n=t.label,i=t.data,r=t.usage,o=void 0===r?0:r,a=e.createBuffer({label:n,usage:o,size:4*i.length,mappedAtCreation:!0});return new Uint32Array(a.getMappedRange()).set(i),a.unmap(),a}var h=function(){return a((function t(e){var n=e.device,r=e.data,o=e.count,a=e.workgroup_size,s=void 0===a?{x:16,y:16}:a,u=e.avoid_bank_conflicts,c=void 0!==u&&u;if(i(this,t),this.device=n,this.workgroup_size=s,this.threads_per_workgroup=s.x*s.y,this.items_per_workgroup=2*this.threads_per_workgroup,Math.log2(this.threads_per_workgroup)%1!=0)throw new Error("workgroup_size.x * workgroup_size.y must be a power of two. (current: ".concat(this.threads_per_workgroup,")"));this.pipelines=[],this.shaderModule=this.device.createShaderModule({label:"prefix-sum",code:c?"\n\n@group(0) @binding(0) var<storage, read_write> items: array<u32>;\n@group(0) @binding(1) var<storage, read_write> blockSums: array<u32>;\n\noverride WORKGROUP_SIZE_X: u32;\noverride WORKGROUP_SIZE_Y: u32;\noverride THREADS_PER_WORKGROUP: u32;\noverride ITEMS_PER_WORKGROUP: u32;\noverride ELEMENT_COUNT: u32;\n\nconst NUM_BANKS: u32 = 32;\nconst LOG_NUM_BANKS: u32 = 5;\n\nfn get_offset(offset: u32) -> u32 {\n    // return offset >> LOG_NUM_BANKS; // Conflict-free\n    return (offset >> NUM_BANKS) + (offset >> (2 * LOG_NUM_BANKS)); // Zero bank conflict\n}\n\nvar<workgroup> temp: array<u32, ITEMS_PER_WORKGROUP*2>;\n\n@compute @workgroup_size(WORKGROUP_SIZE_X, WORKGROUP_SIZE_Y, 1)\nfn reduce_downsweep(\n    @builtin(workgroup_id) w_id: vec3<u32>,\n    @builtin(num_workgroups) w_dim: vec3<u32>,\n    @builtin(local_invocation_index) TID: u32, // Local thread ID\n) {\n    let WORKGROUP_ID = w_id.x + w_id.y * w_dim.x;\n    let WID = WORKGROUP_ID * THREADS_PER_WORKGROUP;\n    let GID = WID + TID; // Global thread ID\n    \n    let ELM_TID = TID * 2; // Element pair local ID\n    let ELM_GID = GID * 2; // Element pair global ID\n    \n    // Load input to shared memory\n    let ai: u32 = TID;\n    let bi: u32 = TID + (ITEMS_PER_WORKGROUP >> 1);\n    let s_ai = ai + get_offset(ai);\n    let s_bi = bi + get_offset(bi);\n    let g_ai = ai + WID * 2;\n    let g_bi = bi + WID * 2;\n    temp[s_ai] = select(items[g_ai], 0, g_ai >= ELEMENT_COUNT);\n    temp[s_bi] = select(items[g_bi], 0, g_bi >= ELEMENT_COUNT);\n\n    var offset: u32 = 1;\n\n    // Up-sweep (reduce) phase\n    for (var d: u32 = ITEMS_PER_WORKGROUP >> 1; d > 0; d >>= 1) {\n        workgroupBarrier();\n\n        if (TID < d) {\n            var ai: u32 = offset * (ELM_TID + 1) - 1;\n            var bi: u32 = offset * (ELM_TID + 2) - 1;\n            ai += get_offset(ai);\n            bi += get_offset(bi);\n            temp[bi] += temp[ai];\n        }\n\n        offset *= 2;\n    }\n\n    // Save workgroup sum and clear last element\n    if (TID == 0) {\n        var last_offset = ITEMS_PER_WORKGROUP - 1;\n        last_offset += get_offset(last_offset);\n\n        blockSums[WORKGROUP_ID] = temp[last_offset];\n        temp[last_offset] = 0;\n    }\n\n    // Down-sweep phase\n    for (var d: u32 = 1; d < ITEMS_PER_WORKGROUP; d *= 2) {\n        offset >>= 1;\n        workgroupBarrier();\n\n        if (TID < d) {\n            var ai: u32 = offset * (ELM_TID + 1) - 1;\n            var bi: u32 = offset * (ELM_TID + 2) - 1;\n            ai += get_offset(ai);\n            bi += get_offset(bi);\n\n            let t: u32 = temp[ai];\n            temp[ai] = temp[bi];\n            temp[bi] += t;\n        }\n    }\n    workgroupBarrier();\n\n    // Copy result from shared memory to global memory\n    if (g_ai < ELEMENT_COUNT) {\n        items[g_ai] = temp[s_ai];\n    }\n    if (g_bi < ELEMENT_COUNT) {\n        items[g_bi] = temp[s_bi];\n    }\n}\n\n@compute @workgroup_size(WORKGROUP_SIZE_X, WORKGROUP_SIZE_Y, 1)\nfn add_block_sums(\n    @builtin(workgroup_id) w_id: vec3<u32>,\n    @builtin(num_workgroups) w_dim: vec3<u32>,\n    @builtin(local_invocation_index) TID: u32, // Local thread ID\n) {\n    let WORKGROUP_ID = w_id.x + w_id.y * w_dim.x;\n    let WID = WORKGROUP_ID * THREADS_PER_WORKGROUP;\n    let GID = WID + TID; // Global thread ID\n\n    let ELM_ID = GID * 2;\n\n    if (ELM_ID >= ELEMENT_COUNT) {\n        return;\n    }\n\n    let blockSum = blockSums[WORKGROUP_ID];\n\n    items[ELM_ID] += blockSum;\n\n    if (ELM_ID + 1 >= ELEMENT_COUNT) {\n        return;\n    }\n\n    items[ELM_ID + 1] += blockSum;\n}":"\n\n@group(0) @binding(0) var<storage, read_write> items: array<u32>;\n@group(0) @binding(1) var<storage, read_write> blockSums: array<u32>;\n\noverride WORKGROUP_SIZE_X: u32;\noverride WORKGROUP_SIZE_Y: u32;\noverride THREADS_PER_WORKGROUP: u32;\noverride ITEMS_PER_WORKGROUP: u32;\noverride ELEMENT_COUNT: u32;\n\nvar<workgroup> temp: array<u32, ITEMS_PER_WORKGROUP*2>;\n\n@compute @workgroup_size(WORKGROUP_SIZE_X, WORKGROUP_SIZE_Y, 1)\nfn reduce_downsweep(\n    @builtin(workgroup_id) w_id: vec3<u32>,\n    @builtin(num_workgroups) w_dim: vec3<u32>,\n    @builtin(local_invocation_index) TID: u32, // Local thread ID\n) {\n    let WORKGROUP_ID = w_id.x + w_id.y * w_dim.x;\n    let WID = WORKGROUP_ID * THREADS_PER_WORKGROUP;\n    let GID = WID + TID; // Global thread ID\n    \n    let ELM_TID = TID * 2; // Element pair local ID\n    let ELM_GID = GID * 2; // Element pair global ID\n    \n    // Load input to shared memory\n    temp[ELM_TID]     = select(items[ELM_GID], 0, ELM_GID >= ELEMENT_COUNT);\n    temp[ELM_TID + 1] = select(items[ELM_GID + 1], 0, ELM_GID + 1 >= ELEMENT_COUNT);\n\n    var offset: u32 = 1;\n\n    // Up-sweep (reduce) phase\n    for (var d: u32 = ITEMS_PER_WORKGROUP >> 1; d > 0; d >>= 1) {\n        workgroupBarrier();\n\n        if (TID < d) {\n            var ai: u32 = offset * (ELM_TID + 1) - 1;\n            var bi: u32 = offset * (ELM_TID + 2) - 1;\n            temp[bi] += temp[ai];\n        }\n\n        offset *= 2;\n    }\n\n    // Save workgroup sum and clear last element\n    if (TID == 0) {\n        let last_offset = ITEMS_PER_WORKGROUP - 1;\n\n        blockSums[WORKGROUP_ID] = temp[last_offset];\n        temp[last_offset] = 0;\n    }\n\n    // Down-sweep phase\n    for (var d: u32 = 1; d < ITEMS_PER_WORKGROUP; d *= 2) {\n        offset >>= 1;\n        workgroupBarrier();\n\n        if (TID < d) {\n            var ai: u32 = offset * (ELM_TID + 1) - 1;\n            var bi: u32 = offset * (ELM_TID + 2) - 1;\n\n            let t: u32 = temp[ai];\n            temp[ai] = temp[bi];\n            temp[bi] += t;\n        }\n    }\n    workgroupBarrier();\n\n    // Copy result from shared memory to global memory\n    if (ELM_GID >= ELEMENT_COUNT) {\n        return;\n    }\n    items[ELM_GID] = temp[ELM_TID];\n\n    if (ELM_GID + 1 >= ELEMENT_COUNT) {\n        return;\n    }\n    items[ELM_GID + 1] = temp[ELM_TID + 1];\n}\n\n@compute @workgroup_size(WORKGROUP_SIZE_X, WORKGROUP_SIZE_Y, 1)\nfn add_block_sums(\n    @builtin(workgroup_id) w_id: vec3<u32>,\n    @builtin(num_workgroups) w_dim: vec3<u32>,\n    @builtin(local_invocation_index) TID: u32, // Local thread ID\n) {\n    let WORKGROUP_ID = w_id.x + w_id.y * w_dim.x;\n    let WID = WORKGROUP_ID * THREADS_PER_WORKGROUP;\n    let GID = WID + TID; // Global thread ID\n\n    let ELM_ID = GID * 2;\n\n    if (ELM_ID >= ELEMENT_COUNT) {\n        return;\n    }\n\n    let blockSum = blockSums[WORKGROUP_ID];\n\n    items[ELM_ID] += blockSum;\n\n    if (ELM_ID + 1 >= ELEMENT_COUNT) {\n        return;\n    }\n\n    items[ELM_ID + 1] += blockSum;\n}"}),this.create_pass_recursive(r,o)}),[{key:"create_pass_recursive",value:function(t,e){var n=Math.ceil(e/this.items_per_workgroup),i=d(this.device,n),r=this.device.createBuffer({label:"prefix-sum-block-sum",size:4*n,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST}),o=this.device.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}}]}),a=this.device.createBindGroup({label:"prefix-sum-bind-group",layout:o,entries:[{binding:0,resource:{buffer:t}},{binding:1,resource:{buffer:r}}]}),s=this.device.createPipelineLayout({bindGroupLayouts:[o]}),u=this.device.createComputePipeline({label:"prefix-sum-scan-pipeline",layout:s,compute:{module:this.shaderModule,entryPoint:"reduce_downsweep",constants:{WORKGROUP_SIZE_X:this.workgroup_size.x,WORKGROUP_SIZE_Y:this.workgroup_size.y,THREADS_PER_WORKGROUP:this.threads_per_workgroup,ITEMS_PER_WORKGROUP:this.items_per_workgroup,ELEMENT_COUNT:e}}});if(this.pipelines.push({pipeline:u,bindGroup:a,dispatchSize:i}),n>1){this.create_pass_recursive(r,n);var c=this.device.createComputePipeline({label:"prefix-sum-add-block-pipeline",layout:s,compute:{module:this.shaderModule,entryPoint:"add_block_sums",constants:{WORKGROUP_SIZE_X:this.workgroup_size.x,WORKGROUP_SIZE_Y:this.workgroup_size.y,THREADS_PER_WORKGROUP:this.threads_per_workgroup,ELEMENT_COUNT:e}}});this.pipelines.push({pipeline:c,bindGroup:a,dispatchSize:i})}}},{key:"get_dispatch_chain",value:function(){return this.pipelines.flatMap((function(t){return[t.dispatchSize.x,t.dispatchSize.y,1]}))}},{key:"dispatch",value:function(t,e){for(var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,i=0;i<this.pipelines.length;i++){var r=this.pipelines[i],o=r.pipeline,a=r.bindGroup,s=r.dispatchSize;t.setPipeline(o),t.setBindGroup(0,a),null==e?t.dispatchWorkgroups(s.x,s.y,1):t.dispatchWorkgroupsIndirect(e,n+3*i*4)}}}])}(),_="\n\n@group(0) @binding(0) var<storage, read> inputKeys: array<u32>;\n@group(0) @binding(1) var<storage, read_write> outputKeys: array<u32>;\n@group(0) @binding(2) var<storage, read> local_prefix_sum: array<u32>;\n@group(0) @binding(3) var<storage, read> prefix_block_sum: array<u32>;\n@group(0) @binding(4) var<storage, read> inputValues: array<u32>;\n@group(0) @binding(5) var<storage, read_write> outputValues: array<u32>;\n\noverride WORKGROUP_COUNT: u32;\noverride THREADS_PER_WORKGROUP: u32;\noverride WORKGROUP_SIZE_X: u32;\noverride WORKGROUP_SIZE_Y: u32;\noverride CURRENT_BIT: u32;\noverride ELEMENT_COUNT: u32;\n\n@compute @workgroup_size(WORKGROUP_SIZE_X, WORKGROUP_SIZE_Y, 1)\nfn radix_sort_reorder(\n    @builtin(workgroup_id) w_id: vec3<u32>,\n    @builtin(num_workgroups) w_dim: vec3<u32>,\n    @builtin(local_invocation_index) TID: u32, // Local thread ID\n) { \n    let WORKGROUP_ID = w_id.x + w_id.y * w_dim.x;\n    let WID = WORKGROUP_ID * THREADS_PER_WORKGROUP;\n    let GID = WID + TID; // Global thread ID\n\n    if (GID >= ELEMENT_COUNT) {\n        return;\n    }\n\n    let k = inputKeys[GID];\n    let v = inputValues[GID];\n\n    let local_prefix = local_prefix_sum[GID];\n\n    // Calculate new position\n    let extract_bits = (k >> CURRENT_BIT) & 0x3;\n    let pid = extract_bits * WORKGROUP_COUNT + WORKGROUP_ID;\n    let sorted_position = prefix_block_sum[pid] + local_prefix;\n    \n    outputKeys[sorted_position] = k;\n    outputValues[sorted_position] = v;\n}",v=function(){var t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],e=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"full";return"\n\n@group(0) @binding(0) var<storage, read> input: array<u32>;\n@group(0) @binding(1) var<storage, read_write> output: array<u32>;\n@group(0) @binding(2) var<storage, read> original: array<u32>;\n@group(0) @binding(3) var<storage, read_write> is_sorted: u32;\n\noverride WORKGROUP_SIZE_X: u32;\noverride WORKGROUP_SIZE_Y: u32;\noverride THREADS_PER_WORKGROUP: u32;\noverride ELEMENT_COUNT: u32;\noverride START_ELEMENT: u32;\n\nvar<workgroup> s_data: array<u32, THREADS_PER_WORKGROUP>;\n\n// Reset dispatch buffer and is_sorted flag\n@compute @workgroup_size(WORKGROUP_SIZE_X, WORKGROUP_SIZE_Y, 1)\nfn reset(\n    @builtin(workgroup_id) w_id: vec3<u32>,\n    @builtin(num_workgroups) w_dim: vec3<u32>,\n    @builtin(local_invocation_index) TID: u32, // Local thread ID\n) {\n    if (TID >= ELEMENT_COUNT) {\n        return;\n    }\n\n    if (TID == 0) {\n        is_sorted = 0u;\n    }\n\n    let ELM_ID = TID * 3;\n\n    output[ELM_ID] = original[ELM_ID];\n}\n\n@compute @workgroup_size(WORKGROUP_SIZE_X, WORKGROUP_SIZE_Y, 1)\nfn check_sort(\n    @builtin(workgroup_id) w_id: vec3<u32>,\n    @builtin(num_workgroups) w_dim: vec3<u32>,\n    @builtin(local_invocation_index) TID: u32, // Local thread ID\n) {\n    let WORKGROUP_ID = w_id.x + w_id.y * w_dim.x;\n    let WID = WORKGROUP_ID * THREADS_PER_WORKGROUP + START_ELEMENT;\n    let GID = TID + WID; // Global thread ID\n\n    // Load data into shared memory\n    ".concat(arguments.length>0&&void 0!==arguments[0]&&arguments[0]?g:"s_data[TID] = select(0u, input[GID], GID < ELEMENT_COUNT);","\n\n    // Perform parallel reduction\n    for (var d = 1u; d < THREADS_PER_WORKGROUP; d *= 2u) {      \n        workgroupBarrier();  \n        if (TID % (2u * d) == 0u) {\n            s_data[TID] += s_data[TID + d];\n        }\n    }\n    workgroupBarrier();\n\n    // Write reduction result\n    ").concat(t?x(e):m,"\n}")},m="\n    if (TID == 0) {\n        output[WORKGROUP_ID] = s_data[0];\n    }\n",g="\n    let LAST_THREAD = min(THREADS_PER_WORKGROUP, ELEMENT_COUNT - WID) - 1;\n\n    // Load current element into shared memory\n    // Also load next element for comparison\n    let elm = select(0u, input[GID], GID < ELEMENT_COUNT);\n    let next = select(0u, input[GID + 1], GID < ELEMENT_COUNT-1);\n    s_data[TID] = elm;\n    workgroupBarrier();\n\n    s_data[TID] = select(0u, 1u, GID < ELEMENT_COUNT-1 && elm > next);\n",x=function(t){return"\n    let fullDispatchLength = arrayLength(&output);\n    let dispatchIndex = TID * 3;\n\n    if (dispatchIndex >= fullDispatchLength) {\n        return;\n    }\n\n    ".concat("full"==t?w:y,"\n")},y="\n    output[dispatchIndex] = select(0, original[dispatchIndex], s_data[0] == 0 && is_sorted == 0u);\n",w="\n    if (TID == 0 && s_data[0] == 0) {\n        is_sorted = 1u;\n    }\n\n    output[dispatchIndex] = select(0, original[dispatchIndex], s_data[0] != 0);\n",b=function(){return a((function t(e){var n=e.device,r=e.data,o=e.result,a=e.original,s=e.is_sorted,u=e.count,c=e.start,l=void 0===c?0:c,f=e.mode,d=void 0===f?"full":f,p=e.workgroup_size,h=void 0===p?{x:16,y:16}:p;i(this,t),this.device=n,this.count=u,this.start=l,this.mode=d,this.workgroup_size=h,this.threads_per_workgroup=h.x*h.y,this.pipelines=[],this.buffers={data:r,result:o,original:a,is_sorted:s,outputs:[]},this.create_passes_recursive(r,u)}),[{key:"create_passes_recursive",value:function(t,e){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,i=Math.ceil(e/this.threads_per_workgroup),r=0===n,o=i<=1,a="check-sort-".concat(this.mode,"-").concat(n),s=o?this.buffers.result:this.device.createBuffer({label:a,size:4*i,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST}),u=this.device.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}}].concat(l(o?[{binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:3,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}}]:[]))}),f=this.device.createBindGroup({layout:u,entries:[{binding:0,resource:{buffer:t}},{binding:1,resource:{buffer:s}}].concat(l(o?[{binding:2,resource:{buffer:this.buffers.original}},{binding:3,resource:{buffer:this.buffers.is_sorted}}]:[]))}),d=this.device.createPipelineLayout({bindGroupLayouts:[u]}),p=r?this.start+e:e,h=r?this.start:0,_=this.device.createComputePipeline({layout:d,compute:{module:this.device.createShaderModule({label:a,code:v(r,o,this.mode)}),entryPoint:"reset"==this.mode?"reset":"check_sort",constants:c({ELEMENT_COUNT:p,WORKGROUP_SIZE_X:this.workgroup_size.x,WORKGROUP_SIZE_Y:this.workgroup_size.y},"reset"!=this.mode&&{THREADS_PER_WORKGROUP:this.threads_per_workgroup,START_ELEMENT:h})}});this.buffers.outputs.push(s),this.pipelines.push({pipeline:_,bindGroup:f}),o||this.create_passes_recursive(s,i,n+1)}},{key:"dispatch",value:function(t,e){for(var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,i=0;i<this.pipelines.length;i++){var r=this.pipelines[i],o=r.pipeline,a=r.bindGroup,s="reset"!=this.mode&&("full"==this.mode||i<this.pipelines.length-1);t.setPipeline(o),t.setBindGroup(0,a),s?t.dispatchWorkgroupsIndirect(e,n+3*i*4):t.dispatchWorkgroups(1,1,1)}}}],[{key:"find_optimal_dispatch_chain",value:function(t,e,n){var i=n.x*n.y,r=[];do{var o=Math.ceil(e/i),a=d(t,o);r.push(a.x,a.y,1),e=o}while(e>1);return r}}])}(),P=new WeakSet,S=function(){return a((function t(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},n=e.device,o=e.keys,a=e.values,s=e.count,u=e.bit_count,c=void 0===u?32:u,l=e.workgroup_size,f=void 0===l?{x:16,y:16}:l,d=e.check_order,p=void 0!==d&&d,h=e.local_shuffle,_=void 0!==h&&h,v=e.avoid_bank_conflicts,m=void 0!==v&&v;if(i(this,t),r(this,P),null==n)throw new Error("No device provided");if(null==o)throw new Error("No keys buffer provided");if(!Number.isInteger(s)||s<=0)throw new Error("Invalid count parameter");if(!Number.isInteger(c)||c<=0||c>32)throw new Error("Invalid bit_count parameter: ".concat(c));if(!Number.isInteger(f.x)||!Number.isInteger(f.y))throw new Error("Invalid workgroup_size parameter");if(c%4!=0)throw new Error("bit_count must be a multiple of 4");this.device=n,this.count=s,this.bit_count=c,this.workgroup_size=f,this.check_order=p,this.local_shuffle=_,this.avoid_bank_conflicts=m,this.threads_per_workgroup=f.x*f.y,this.workgroup_count=Math.ceil(s/this.threads_per_workgroup),this.prefix_block_workgroup_count=4*this.workgroup_count,this.has_values=null!=a,this.dispatchSize={},this.shaderModules={},this.kernels={},this.pipelines=[],this.buffers={keys:o,values:a},this.create_shader_modules(),this.create_pipelines()}),[{key:"create_shader_modules",value:function(){var t=function(t){return t.split("\n").filter((function(t){return!t.toLowerCase().includes("values")})).join("\n")},e=this.local_shuffle?"\n\n@group(0) @binding(0) var<storage, read_write> input: array<u32>;\n@group(0) @binding(1) var<storage, read_write> local_prefix_sums: array<u32>;\n@group(0) @binding(2) var<storage, read_write> block_sums: array<u32>;\n@group(0) @binding(3) var<storage, read_write> values: array<u32>;\n\noverride WORKGROUP_COUNT: u32;\noverride THREADS_PER_WORKGROUP: u32;\noverride WORKGROUP_SIZE_X: u32;\noverride WORKGROUP_SIZE_Y: u32;\noverride CURRENT_BIT: u32;\noverride ELEMENT_COUNT: u32;\n\nvar<workgroup> s_prefix_sum: array<u32, 2 * (THREADS_PER_WORKGROUP + 1)>;\nvar<workgroup> s_prefix_sum_scan: array<u32, 4>;\n\n@compute @workgroup_size(WORKGROUP_SIZE_X, WORKGROUP_SIZE_Y, 1)\nfn radix_sort(\n    @builtin(workgroup_id) w_id: vec3<u32>,\n    @builtin(num_workgroups) w_dim: vec3<u32>,\n    @builtin(local_invocation_index) TID: u32, // Local thread ID\n) {\n    let WORKGROUP_ID = w_id.x + w_id.y * w_dim.x;\n    let WID = WORKGROUP_ID * THREADS_PER_WORKGROUP;\n    let GID = WID + TID; // Global thread ID\n\n    // Extract 2 bits from the input\n    var elm: u32 = 0;\n    var val: u32 = 0;\n    if (GID < ELEMENT_COUNT) {\n        elm = input[GID];\n        val = values[GID];\n    }\n    let extract_bits: u32 = (elm >> CURRENT_BIT) & 0x3;\n\n    var bit_prefix_sums = array<u32, 4>(0, 0, 0, 0);\n\n    // If the workgroup is inactive, prevent block_sums buffer update\n    var LAST_THREAD: u32 = 0xffffffff; \n\n    if (WORKGROUP_ID < WORKGROUP_COUNT) {\n        // Otherwise store the index of the last active thread in the workgroup\n        LAST_THREAD = min(THREADS_PER_WORKGROUP, ELEMENT_COUNT - WID) - 1;\n    }\n\n    // Initialize parameters for double-buffering\n    let TPW = THREADS_PER_WORKGROUP + 1;\n    var swapOffset: u32 = 0;\n    var inOffset:  u32 = TID;\n    var outOffset: u32 = TID + TPW;\n\n    // 4-way prefix sum\n    for (var b: u32 = 0; b < 4; b++) {\n        // Initialize local prefix with bitmask\n        let bitmask = select(0u, 1u, extract_bits == b);\n        s_prefix_sum[inOffset + 1] = bitmask;\n        workgroupBarrier();\n\n        var prefix_sum: u32 = 0;\n\n        // Prefix sum\n        for (var offset: u32 = 1; offset < THREADS_PER_WORKGROUP; offset *= 2) {\n            if (TID >= offset) {\n                prefix_sum = s_prefix_sum[inOffset] + s_prefix_sum[inOffset - offset];\n            } else {\n                prefix_sum = s_prefix_sum[inOffset];\n            }\n\n            s_prefix_sum[outOffset] = prefix_sum;\n\n            // Swap buffers\n            outOffset = inOffset;\n            swapOffset = TPW - swapOffset;\n            inOffset = TID + swapOffset;\n            \n            workgroupBarrier();\n        }\n\n        // Store prefix sum for current bit\n        bit_prefix_sums[b] = prefix_sum;\n\n        if (TID == LAST_THREAD) {\n            // Store block sum to global memory\n            let total_sum: u32 = prefix_sum + bitmask;\n            block_sums[b * WORKGROUP_COUNT + WORKGROUP_ID] = total_sum;\n        }\n\n        // Swap buffers\n        outOffset = inOffset;\n        swapOffset = TPW - swapOffset;\n        inOffset = TID + swapOffset;\n    }\n\n    let prefix_sum = bit_prefix_sums[extract_bits];   \n\n    // Scan bit prefix sums\n    if (TID == LAST_THREAD) {\n        var sum: u32 = 0;\n        bit_prefix_sums[extract_bits] += 1;\n        for (var i: u32 = 0; i < 4; i++) {\n            s_prefix_sum_scan[i] = sum;\n            sum += bit_prefix_sums[i];\n        }\n    }\n    workgroupBarrier();\n\n    if (GID < ELEMENT_COUNT) {\n        // Compute new position\n        let new_pos: u32 = prefix_sum + s_prefix_sum_scan[extract_bits];\n\n        // Shuffle elements locally\n        input[WID + new_pos] = elm;\n        values[WID + new_pos] = val;\n        local_prefix_sums[WID + new_pos] = prefix_sum;\n    }\n}":"\n\n@group(0) @binding(0) var<storage, read> input: array<u32>;\n@group(0) @binding(1) var<storage, read_write> local_prefix_sums: array<u32>;\n@group(0) @binding(2) var<storage, read_write> block_sums: array<u32>;\n\noverride WORKGROUP_COUNT: u32;\noverride THREADS_PER_WORKGROUP: u32;\noverride WORKGROUP_SIZE_X: u32;\noverride WORKGROUP_SIZE_Y: u32;\noverride CURRENT_BIT: u32;\noverride ELEMENT_COUNT: u32;\n\nvar<workgroup> s_prefix_sum: array<u32, 2 * (THREADS_PER_WORKGROUP + 1)>;\n\n@compute @workgroup_size(WORKGROUP_SIZE_X, WORKGROUP_SIZE_Y, 1)\nfn radix_sort(\n    @builtin(workgroup_id) w_id: vec3<u32>,\n    @builtin(num_workgroups) w_dim: vec3<u32>,\n    @builtin(local_invocation_index) TID: u32, // Local thread ID\n) {\n    let WORKGROUP_ID = w_id.x + w_id.y * w_dim.x;\n    let WID = WORKGROUP_ID * THREADS_PER_WORKGROUP;\n    let GID = WID + TID; // Global thread ID\n\n    // Extract 2 bits from the input\n    let elm = select(input[GID], 0, GID >= ELEMENT_COUNT);\n    let extract_bits: u32 = (elm >> CURRENT_BIT) & 0x3;\n\n    var bit_prefix_sums = array<u32, 4>(0, 0, 0, 0);\n\n    // If the workgroup is inactive, prevent block_sums buffer update\n    var LAST_THREAD: u32 = 0xffffffff; \n\n    if (WORKGROUP_ID < WORKGROUP_COUNT) {\n        // Otherwise store the index of the last active thread in the workgroup\n        LAST_THREAD = min(THREADS_PER_WORKGROUP, ELEMENT_COUNT - WID) - 1;\n    }\n\n    // Initialize parameters for double-buffering\n    let TPW = THREADS_PER_WORKGROUP + 1;\n    var swapOffset: u32 = 0;\n    var inOffset:  u32 = TID;\n    var outOffset: u32 = TID + TPW;\n\n    // 4-way prefix sum\n    for (var b: u32 = 0; b < 4; b++) {\n        // Initialize local prefix with bitmask\n        let bitmask = select(0u, 1u, extract_bits == b);\n        s_prefix_sum[inOffset + 1] = bitmask;\n        workgroupBarrier();\n\n        var prefix_sum: u32 = 0;\n\n        // Prefix sum\n        for (var offset: u32 = 1; offset < THREADS_PER_WORKGROUP; offset *= 2) {\n            if (TID >= offset) {\n                prefix_sum = s_prefix_sum[inOffset] + s_prefix_sum[inOffset - offset];\n            } else {\n                prefix_sum = s_prefix_sum[inOffset];\n            }\n\n            s_prefix_sum[outOffset] = prefix_sum;\n            \n            // Swap buffers\n            outOffset = inOffset;\n            swapOffset = TPW - swapOffset;\n            inOffset = TID + swapOffset;\n            \n            workgroupBarrier();\n        }\n\n        // Store prefix sum for current bit\n        bit_prefix_sums[b] = prefix_sum;\n\n        if (TID == LAST_THREAD) {\n            // Store block sum to global memory\n            let total_sum: u32 = prefix_sum + bitmask;\n            block_sums[b * WORKGROUP_COUNT + WORKGROUP_ID] = total_sum;\n        }\n\n        // Swap buffers\n        outOffset = inOffset;\n        swapOffset = TPW - swapOffset;\n        inOffset = TID + swapOffset;\n    }\n\n    if (GID < ELEMENT_COUNT) {\n        // Store local prefix sum to global memory\n        local_prefix_sums[GID] = bit_prefix_sums[extract_bits];\n    }\n}";this.shaderModules={blockSum:this.device.createShaderModule({label:"radix-sort-block-sum",code:this.has_values?e:t(e)}),reorder:this.device.createShaderModule({label:"radix-sort-reorder",code:this.has_values?_:t(_)})}}},{key:"create_pipelines",value:function(){this.create_prefix_sum_kernel();var t=this.calculate_dispatch_sizes();this.create_buffers(t),this.create_check_sort_kernels(t);for(var e=0;e<this.bit_count;e+=2){var n=e%4==0,i=n?this.buffers.keys:this.buffers.tmpKeys,r=n?this.buffers.values:this.buffers.tmpValues,o=n?this.buffers.tmpKeys:this.buffers.keys,a=n?this.buffers.tmpValues:this.buffers.values,s=this.create_block_sum_pipeline(i,r,e),u=this.create_reorder_pipeline(i,r,o,a,e);this.pipelines.push({blockSumPipeline:s,reorderPipeline:u})}}},{key:"create_prefix_sum_kernel",value:function(){var t=this.device.createBuffer({label:"radix-sort-prefix-block-sum",size:4*this.prefix_block_workgroup_count,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST}),e=new h({device:this.device,data:t,count:this.prefix_block_workgroup_count,workgroup_size:this.workgroup_size,avoid_bank_conflicts:this.avoid_bank_conflicts});this.kernels.prefixSum=e,this.buffers.prefixBlockSum=t}},{key:"calculate_dispatch_sizes",value:function(){var t=d(this.device,this.workgroup_count),e=this.kernels.prefixSum.get_dispatch_chain(),n=Math.min(this.count,4*this.threads_per_workgroup),i=this.count-n,r=n-1,o=b.find_optimal_dispatch_chain(this.device,n,this.workgroup_size),a=b.find_optimal_dispatch_chain(this.device,i,this.workgroup_size),s=[t.x,t.y,1].concat(l(o.slice(0,3)),l(e));return this.dispatchOffsets={radix_sort:0,check_sort_fast:12,prefix_sum:24},this.dispatchSize=t,this.initialDispatch=s,{initialDispatch:s,dispatchSizesFull:a,check_sort_fast_count:n,check_sort_full_count:i,start_full:r}}},{key:"create_buffers",value:function(t){var e=this.device.createBuffer({label:"radix-sort-tmp-keys",size:4*this.count,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST}),n=this.has_values?this.device.createBuffer({label:"radix-sort-tmp-values",size:4*this.count,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST}):null,i=this.device.createBuffer({label:"radix-sort-local-prefix-sum",size:4*this.count,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST});if(this.buffers.tmpKeys=e,this.buffers.tmpValues=n,this.buffers.localPrefixSum=i,this.check_order){var r=p({device:this.device,label:"radix-sort-dispatch-size",data:t.initialDispatch,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.INDIRECT}),o=p({device:this.device,label:"radix-sort-dispatch-size-original",data:t.initialDispatch,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC}),a=p({label:"check-sort-full-dispatch-size",device:this.device,data:t.dispatchSizesFull,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.INDIRECT}),s=p({label:"check-sort-full-dispatch-size-original",device:this.device,data:t.dispatchSizesFull,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC}),u=p({label:"is-sorted",device:this.device,data:new Uint32Array([0]),usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST});this.buffers.dispatchSize=r,this.buffers.originalDispatchSize=o,this.buffers.checkSortFullDispatchSize=a,this.buffers.originalCheckSortFullDispatchSize=s,this.buffers.isSorted=u}}},{key:"create_check_sort_kernels",value:function(t){if(this.check_order){var e=t.check_sort_fast_count,n=t.check_sort_full_count,i=t.start_full,r=new b({mode:"full",device:this.device,data:this.buffers.keys,result:this.buffers.dispatchSize,original:this.buffers.originalDispatchSize,is_sorted:this.buffers.isSorted,count:n,start:i,workgroup_size:this.workgroup_size}),o=new b({mode:"fast",device:this.device,data:this.buffers.keys,result:this.buffers.checkSortFullDispatchSize,original:this.buffers.originalCheckSortFullDispatchSize,is_sorted:this.buffers.isSorted,count:e,workgroup_size:this.workgroup_size}),a=this.initialDispatch.length/3;if(o.threads_per_workgroup<r.pipelines.length||r.threads_per_workgroup<a)return console.warn("Warning: workgroup size is too small to enable check sort optimization, disabling..."),void(this.check_order=!1);var s=new b({mode:"reset",device:this.device,data:this.buffers.keys,original:this.buffers.originalDispatchSize,result:this.buffers.dispatchSize,is_sorted:this.buffers.isSorted,count:a,workgroup_size:d(this.device,a)});this.kernels.checkSort={reset:s,fast:o,full:r}}}},{key:"create_block_sum_pipeline",value:function(t,e,n){var i=this.device.createBindGroupLayout({label:"radix-sort-block-sum",entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:this.local_shuffle?"storage":"read-only-storage"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}},{binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}}].concat(l(this.local_shuffle&&this.has_values?[{binding:3,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}}]:[]))}),r=this.device.createBindGroup({layout:i,entries:[{binding:0,resource:{buffer:t}},{binding:1,resource:{buffer:this.buffers.localPrefixSum}},{binding:2,resource:{buffer:this.buffers.prefixBlockSum}}].concat(l(this.local_shuffle&&this.has_values?[{binding:3,resource:{buffer:e}}]:[]))}),o=this.device.createPipelineLayout({bindGroupLayouts:[i]});return{pipeline:this.device.createComputePipeline({label:"radix-sort-block-sum",layout:o,compute:{module:this.shaderModules.blockSum,entryPoint:"radix_sort",constants:{WORKGROUP_SIZE_X:this.workgroup_size.x,WORKGROUP_SIZE_Y:this.workgroup_size.y,WORKGROUP_COUNT:this.workgroup_count,THREADS_PER_WORKGROUP:this.threads_per_workgroup,ELEMENT_COUNT:this.count,CURRENT_BIT:n}}}),bindGroup:r}}},{key:"create_reorder_pipeline",value:function(t,e,n,i,r){var o=this.device.createBindGroupLayout({label:"radix-sort-reorder",entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}},{binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:3,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}}].concat(l(this.has_values?[{binding:4,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:5,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}}]:[]))}),a=this.device.createBindGroup({layout:o,entries:[{binding:0,resource:{buffer:t}},{binding:1,resource:{buffer:n}},{binding:2,resource:{buffer:this.buffers.localPrefixSum}},{binding:3,resource:{buffer:this.buffers.prefixBlockSum}}].concat(l(this.has_values?[{binding:4,resource:{buffer:e}},{binding:5,resource:{buffer:i}}]:[]))}),s=this.device.createPipelineLayout({bindGroupLayouts:[o]});return{pipeline:this.device.createComputePipeline({label:"radix-sort-reorder",layout:s,compute:{module:this.shaderModules.reorder,entryPoint:"radix_sort_reorder",constants:{WORKGROUP_SIZE_X:this.workgroup_size.x,WORKGROUP_SIZE_Y:this.workgroup_size.y,WORKGROUP_COUNT:this.workgroup_count,THREADS_PER_WORKGROUP:this.threads_per_workgroup,ELEMENT_COUNT:this.count,CURRENT_BIT:r}}}),bindGroup:a}}},{key:"dispatch",value:function(t){this.check_order?n(P,this,E).call(this,t):n(P,this,R).call(this,t)}}])}();function R(t){for(var e=0;e<this.bit_count/2;e++){var n=this.pipelines[e],i=n.blockSumPipeline,r=n.reorderPipeline;t.setPipeline(i.pipeline),t.setBindGroup(0,i.bindGroup),t.dispatchWorkgroups(this.dispatchSize.x,this.dispatchSize.y,1),this.kernels.prefixSum.dispatch(t),t.setPipeline(r.pipeline),t.setBindGroup(0,r.bindGroup),t.dispatchWorkgroups(this.dispatchSize.x,this.dispatchSize.y,1)}}function E(t){this.kernels.checkSort.reset.dispatch(t);for(var e=0;e<this.bit_count/2;e++){var n=this.pipelines[e],i=n.blockSumPipeline,r=n.reorderPipeline;e%2==0&&(this.kernels.checkSort.fast.dispatch(t,this.buffers.dispatchSize,this.dispatchOffsets.check_sort_fast),this.kernels.checkSort.full.dispatch(t,this.buffers.checkSortFullDispatchSize)),t.setPipeline(i.pipeline),t.setBindGroup(0,i.bindGroup),t.dispatchWorkgroupsIndirect(this.buffers.dispatchSize,this.dispatchOffsets.radix_sort),this.kernels.prefixSum.dispatch(t,this.buffers.dispatchSize,this.dispatchOffsets.prefix_sum),t.setPipeline(r.pipeline),t.setBindGroup(0,r.bindGroup),t.dispatchWorkgroupsIndirect(this.buffers.dispatchSize,this.dispatchOffsets.radix_sort)}}t.PrefixSumKernel=h,t.RadixSortKernel=S}(e)}},e={};function n(i){var r=e[i];if(void 0!==r)return r.exports;var o=e[i]={exports:{}};return t[i].call(o.exports,o,o.exports,n),o.exports}(()=>{"use strict";function t(t,e){for(var n=0,i=0;i<t.length;i++)n+=t[i]*e[i];return n}function e(t,e){return Math.ceil(t/e)*e}class i extends Error{constructor(t){super(t),this.name="PackingError"}}class r{constructor(t,e){this.size=t,this.alignment=e}}new class extends r{constructor(){super(4,4)}pack(t,e,n){if("number"!=typeof e)throw new i(`Expected number, got ${e}`);return n.setInt32(t,e,!0),t+this.size}unpack(t,e){const n=e.getInt32(t,!0);return[t+this.size,n]}},new class extends r{constructor(){super(4,4)}pack(t,e,n){if("number"!=typeof e)throw new i(`Expected number, got ${e}`);return n.setUint32(t,e,!0),t+this.size}unpack(t,e){const n=e.getUint32(t,!0);return[t+this.size,n]}};const o=new class extends r{constructor(){super(4,4)}pack(t,e,n){if("number"!=typeof e)throw new i(`Expected number, got ${e}`);return n.setFloat32(t,e,!0),t+this.size}unpack(t,e){const n=e.getFloat32(t,!0);return[t+this.size,n]}};class a extends r{constructor(t,e,n){super(t.size*e,n),this.baseType=t,this.nValues=e}pack(t,e,n){if(!Array.isArray(e))throw new i(`Expected array, got ${e}`);if(e.length!==this.nValues)throw new i(`Expected ${this.nValues} values, got ${e.length}`);for(;t%this.alignment!=0;)t++;for(let r=0;r<e.length;r++)try{t=this.baseType.pack(t,e[r],n)}catch(t){throw t instanceof i?new i(`Error packing value ${r}: ${t.message}`):t}return t}unpack(t,e){const n=[];for(;t%this.alignment!=0;)t++;for(let i=0;i<this.nValues;i++){let[i,r]=this.baseType.unpack(t,e);t=i,n.push(r)}return[t,n]}}class s extends a{constructor(t){super(t,2,8)}}class u extends a{constructor(t){super(t,3,16)}}class c extends a{constructor(t){super(t,4,16)}}class l extends r{constructor(t){const n=Math.max(...t.map((([t,e])=>e.alignment)));let i=0;for(const[e,n]of t){for(;i%n.alignment!=0;)i++;i+=n.size}super(e(i,n),n),this.members=t}pack(t,e,n){const r=this.members.map((([t,e])=>t)),o=Object.keys(e);if(r.length!==o.length)throw new i(`Expected values for ${r}, got ${o}`);if(!r.every((t=>o.includes(t))))throw new i(`Expected values for ${r}, got ${o}`);const a=t;for(;t%this.alignment!=0;)t++;for(const[r,o]of this.members){const a=e[r];try{t=o.pack(t,a,n)}catch(t){throw t instanceof i?new i(`Error packing value ${r}: ${t.message}`):t}}return t+(this.size-(t-a))}unpack(t,e){const n={},i=t;for(;t%this.alignment!=0;)t++;for(const[i,r]of this.members){let[o,a]=r.unpack(t,e);t=o,n[i]=a}return[t+=this.size-(t-i),n]}}class f extends r{constructor(t,n){const i=t.alignment;super(n*e(t.size,t.alignment),i),this.type=t,this.nElements=n,this.stride=e(t.size,t.alignment)}pack(t,e,n){if(!Array.isArray(e))throw new i(`Expected array, got ${e}`);if(e.length!==this.nElements)throw new i(`Expected ${this.nElements} values, got ${e.length}`);for(;t%this.alignment!=0;)t++;for(let r=0;r<e.length;r++){try{t=this.type.pack(t,e[r],n)}catch(t){throw t instanceof i?new i(`Error packing value ${r}: ${t.message}`):t}t+=this.stride-this.type.size}return t}unpack(t,e){const n=[];for(;t%this.alignment!=0;)t++;for(let i=0;i<this.nElements;i++){let[i,r]=this.type.unpack(t,e);t=i,n.push(r),t+=this.stride-this.type.size}return[t,n]}}class d extends r{constructor(t,e,n){var i;if(2===e)i=new s(t);else if(3===e)i=new u(t);else{if(4!==e)throw new Error(`Invalid number of rows: ${e}`);i=new c(t)}super(new f(i,n).size,i.alignment),this.baseType=t,this.nRows=e,this.nColumns=n}pack(t,e,n){if(!Array.isArray(e))throw new i(`Expected array, got ${e}`);if(e.length!==this.nColumns)throw new i(`Expected ${this.nColumns} columns, got ${e.length}`);for(;t%this.alignment!=0;)t++;const r=t;for(let r=0;r<e.length;r++){if(!Array.isArray(e[r]))throw new i(`Expected array, got ${e[r]}`);for(let o=0;o<e[r].length;o++)try{t=this.baseType.pack(t,e[r][o],n)}catch(t){throw t instanceof i?new i(`Error packing value ${r},${o}: ${t.message}`):t}}return r+this.size}unpack(t,e){for(;t%this.alignment!=0;)t++;const n=t,i=[];for(let n=0;n<this.nColumns;n++){const n=[];for(let i=0;i<this.nRows;i++){let[i,r]=this.baseType.unpack(t,e);t=i,n.push(r)}i.push(n)}return[t+=this.size-(t-n),i]}}class p extends d{constructor(t){super(t,4,4)}}class h{static decodeHeader(t){const e=new TextDecoder;let n=0,i="";for(;;){const r=new Uint8Array(t,n,50);if(i+=e.decode(r),n+=50,i.includes("end_header"))break}const r=i.split("\n");let o=0,a={};for(let t=0;t<r.length;t++){const e=r[t].trim();if(e.startsWith("element vertex")){const t=e.match(/\d+/);t&&(o=parseInt(t[0]))}else if(e.startsWith("property")){const t=e.match(/(\w+)\s+(\w+)\s+(\w+)/);if(t){const e=t[2];a[t[3]]=e}}else if("end_header"===e)break}const s=i.indexOf("end_header")+10+1;return[o,a,new DataView(t,s)]}readRawVertex(t,e,n){let i={};for(const r in n){const o=n[r];"float"===o?(i[r]=e.getFloat32(t,!0),t+=Float32Array.BYTES_PER_ELEMENT):"uchar"===o&&(i[r]=e.getUint8(t)/255,t+=Uint8Array.BYTES_PER_ELEMENT)}return[t,i]}get nShCoeffs(){if(0===this.sphericalHarmonicsDegree)return 1;if(1===this.sphericalHarmonicsDegree)return 4;if(2===this.sphericalHarmonicsDegree)return 9;if(3===this.sphericalHarmonicsDegree)return 16;throw new Error(`Unsupported SH degree: ${this.sphericalHarmonicsDegree}`)}arrangeVertex(t,e){const n=[];for(let i=0;i<this.nShCoeffs;++i){const r=[];for(let n=0;n<3;++n){const o=e[3*i+n];r.push(t[o])}n.push(r)}return{position:[t.x,t.y,t.z],logScale:[t.scale_0,t.scale_1,t.scale_2],rotQuat:[t.rot_0,t.rot_1,t.rot_2,t.rot_3],opacityLogit:t.opacity,shCoeffs:n}}normalizeV4(t){let e=Math.sqrt(t[0]*t[0]+t[1]*t[1]+t[2]*t[2]+t[3]*t[3]);return[t[0]/e,t[1]/e,t[2]/e,t[3]/e]}NormalizeSwizzleRotation(t){var e=this.normalizeV4(t);return[e[1],e[2],e[3],e[0]]}PackSmallest3Rotation(t){var e=[Math.abs(t[0]),Math.abs(t[1]),Math.abs(t[2]),Math.abs(t[3])],n=0,i=e[0];e[1]>i&&(n=1,i=e[1]),e[2]>i&&(n=2,i=e[2]),e[3]>i&&(n=3,i=e[3]),0==n&&(t=[t[1],t[2],t[3],t[0]]),1==n&&(t=[t[0],t[2],t[3],t[1]]),2==n&&(t=[t[0],t[1],t[3],t[2]]);let r=t[4]>=0?1:-1;var o=[t[0]*r,t[1]*r,t[2]*r];return o[0]=o[0]*Math.SQRT2*.5+.5,o[1]=o[1]*Math.SQRT2*.5+.5,o[2]=o[2]*Math.SQRT2*.5+.5,[o[0],o[1],o[2],n/3]}LinearScale(t){return Math.abs(Math.exp(t))}constructor(e){const[n,i,r]=h.decodeHeader(e);this.numGaussians=n;var a=0;for(const t in i)t.startsWith("f_rest_")&&(a+=1);const s=a/3;this.sphericalHarmonicsDegree=Math.sqrt(s+1)-1,console.log("Detected degree",this.sphericalHarmonicsDegree,"with ",s,"coefficients per color");const d=[];for(let t=0;t<3;++t)d.push(`f_dc_${t}`);for(let t=0;t<s;++t)for(let e=0;e<3;++e)d.push(`f_rest_${e*s+t}`);this.gaussianLayout=new l([["position",new u(o)],["logScale",new u(o)],["rotQuat",new c(o)],["opacityLogit",o],["shCoeffs",new f(new u(o),this.nShCoeffs)]]),this.gaussianArrayLayout=new f(this.gaussianLayout,n),this.positionsLayout=new u(o),this.positionsArrayLayout=new f(this.positionsLayout,n),this.gaussiansBuffer=new ArrayBuffer(this.gaussianArrayLayout.size);const p=new DataView(this.gaussiansBuffer);this.positionsBuffer=new ArrayBuffer(this.positionsArrayLayout.size);const _=new DataView(this.positionsBuffer);var v,m=0,g=0,x=0;for(let e=0;e<n;e++){const[e,n]=this.readRawVertex(m,r,i);m=e;var y=[n.rot_0,n.rot_1,n.rot_2,n.rot_3],w=this.NormalizeSwizzleRotation(y);(w=this.PackSmallest3Rotation(w))[0]||(w[0]=0),w[1]||(w[1]=0),w[2]||(w[2]=0),w[3]||(w[3]=0);let o=Math.max(Math.round(3*w[3]));var b=w[0]*Math.sqrt(2)-1/Math.sqrt(2),P=w[1]*Math.sqrt(2)-1/Math.sqrt(2),S=w[2]*Math.sqrt(2)-1/Math.sqrt(2),R=t(new Float32Array([b,P,S]),new Float32Array([b,P,S]));R=Math.sqrt(1-(v=R,Math.min(Math.max(v,0),1)));var E=new Float32Array([b,P,S,R]);0==o&&(E=new Float32Array([R,b,P,S])),1==o&&(E=new Float32Array([b,R,P,S])),2==o&&(E=new Float32Array([b,P,R,S])),n.rot_0=E[0],n.rot_1=E[1],n.rot_2=E[2],n.rot_3=E[3],n.scale_0=this.LinearScale(n.scale_0),n.scale_1=this.LinearScale(n.scale_1),n.scale_2=this.LinearScale(n.scale_2),g=this.gaussianLayout.pack(g,this.arrangeVertex(n,d),p),x=this.positionsLayout.pack(x,[n.x,n.y,n.z],_)}}}let _=1e-6;Float32Array;let v=Float32Array;function m(t,e,n){const i=new v(3);return void 0!==t&&(i[0]=t,void 0!==e&&(i[1]=e,void 0!==n&&(i[2]=n))),i}Float32Array;const g=new Map([[Float32Array,()=>new Float32Array(12)],[Float64Array,()=>new Float64Array(12)],[Array,()=>new Array(12).fill(0)]]);let x=g.get(Float32Array);var y=function(t,e,n,i,r,o,a,s,u){const c=x();return c[3]=0,c[7]=0,c[11]=0,void 0!==t&&(c[0]=t,void 0!==e&&(c[1]=e,void 0!==n&&(c[2]=n,void 0!==i&&(c[4]=i,void 0!==r&&(c[5]=r,void 0!==o&&(c[6]=o,void 0!==a&&(c[8]=a,void 0!==s&&(c[9]=s,void 0!==u&&(c[10]=u))))))))),c};function w(t,e,n){return(n=n||new v(3))[0]=t[0]-e[0],n[1]=t[1]-e[1],n[2]=t[2]-e[2],n}function b(t,e,n,i){return(i=i||new v(3))[0]=t[0]+n*(e[0]-t[0]),i[1]=t[1]+n*(e[1]-t[1]),i[2]=t[2]+n*(e[2]-t[2]),i}function P(t,e,n){return(n=n||new v(3))[0]=t[0]*e,n[1]=t[1]*e,n[2]=t[2]*e,n}function S(t,e){return(e=e||new v(3))[0]=1/t[0],e[1]=1/t[1],e[2]=1/t[2],e}function R(t,e,n){n=n||new v(3);const i=t[2]*e[0]-t[0]*e[2],r=t[0]*e[1]-t[1]*e[0];return n[0]=t[1]*e[2]-t[2]*e[1],n[1]=i,n[2]=r,n}function E(t,e){return t[0]*e[0]+t[1]*e[1]+t[2]*e[2]}function O(t){const e=t[0],n=t[1],i=t[2];return Math.sqrt(e*e+n*n+i*i)}function z(t){const e=t[0],n=t[1],i=t[2];return e*e+n*n+i*i}function M(t,e){const n=t[0]-e[0],i=t[1]-e[1],r=t[2]-e[2];return Math.sqrt(n*n+i*i+r*r)}function U(t,e){const n=t[0]-e[0],i=t[1]-e[1],r=t[2]-e[2];return n*n+i*i+r*r}function T(t,e){e=e||new v(3);const n=t[0],i=t[1],r=t[2],o=Math.sqrt(n*n+i*i+r*r);return o>1e-5?(e[0]=n/o,e[1]=i/o,e[2]=r/o):(e[0]=0,e[1]=0,e[2]=0),e}function G(t,e){return(e=e||new v(3))[0]=t[0],e[1]=t[1],e[2]=t[2],e}function k(t,e,n){return(n=n||new v(3))[0]=t[0]*e[0],n[1]=t[1]*e[1],n[2]=t[2]*e[2],n}function D(t,e,n){return(n=n||new v(3))[0]=t[0]/e[0],n[1]=t[1]/e[1],n[2]=t[2]/e[2],n}function I(t,e,n){return T(t,n=n||new v(3)),P(n,e,n)}var C={__proto__:null,add:function(t,e,n){return(n=n||new v(3))[0]=t[0]+e[0],n[1]=t[1]+e[1],n[2]=t[2]+e[2],n},addScaled:function(t,e,n,i){return(i=i||new v(3))[0]=t[0]+e[0]*n,i[1]=t[1]+e[1]*n,i[2]=t[2]+e[2]*n,i},angle:function(t,e){const n=t[0],i=t[1],r=t[2],o=e[0],a=e[1],s=e[2],u=Math.sqrt(n*n+i*i+r*r)*Math.sqrt(o*o+a*a+s*s),c=u&&E(t,e)/u;return Math.acos(c)},ceil:function(t,e){return(e=e||new v(3))[0]=Math.ceil(t[0]),e[1]=Math.ceil(t[1]),e[2]=Math.ceil(t[2]),e},clamp:function(t,e=0,n=1,i){return(i=i||new v(3))[0]=Math.min(n,Math.max(e,t[0])),i[1]=Math.min(n,Math.max(e,t[1])),i[2]=Math.min(n,Math.max(e,t[2])),i},clone:G,copy:G,create:m,cross:R,dist:M,distSq:U,distance:M,distanceSq:U,div:D,divScalar:function(t,e,n){return(n=n||new v(3))[0]=t[0]/e,n[1]=t[1]/e,n[2]=t[2]/e,n},divide:D,dot:E,equals:function(t,e){return t[0]===e[0]&&t[1]===e[1]&&t[2]===e[2]},equalsApproximately:function(t,e){return Math.abs(t[0]-e[0])<_&&Math.abs(t[1]-e[1])<_&&Math.abs(t[2]-e[2])<_},floor:function(t,e){return(e=e||new v(3))[0]=Math.floor(t[0]),e[1]=Math.floor(t[1]),e[2]=Math.floor(t[2]),e},fromValues:m,getAxis:function(t,e,n){const i=4*e;return(n=n||new v(3))[0]=t[i+0],n[1]=t[i+1],n[2]=t[i+2],n},getScaling:function(t,e){e=e||new v(3);const n=t[0],i=t[1],r=t[2],o=t[4],a=t[5],s=t[6],u=t[8],c=t[9],l=t[10];return e[0]=Math.sqrt(n*n+i*i+r*r),e[1]=Math.sqrt(o*o+a*a+s*s),e[2]=Math.sqrt(u*u+c*c+l*l),e},getTranslation:function(t,e){return(e=e||new v(3))[0]=t[12],e[1]=t[13],e[2]=t[14],e},inverse:S,invert:S,len:O,lenSq:z,length:O,lengthSq:z,lerp:b,lerpV:function(t,e,n,i){return(i=i||new v(3))[0]=t[0]+n[0]*(e[0]-t[0]),i[1]=t[1]+n[1]*(e[1]-t[1]),i[2]=t[2]+n[2]*(e[2]-t[2]),i},max:function(t,e,n){return(n=n||new v(3))[0]=Math.max(t[0],e[0]),n[1]=Math.max(t[1],e[1]),n[2]=Math.max(t[2],e[2]),n},midpoint:function(t,e,n){return b(t,e,.5,n=n||new v(3))},min:function(t,e,n){return(n=n||new v(3))[0]=Math.min(t[0],e[0]),n[1]=Math.min(t[1],e[1]),n[2]=Math.min(t[2],e[2]),n},mul:k,mulScalar:P,multiply:k,negate:function(t,e){return(e=e||new v(3))[0]=-t[0],e[1]=-t[1],e[2]=-t[2],e},normalize:T,random:function(t=1,e){e=e||new v(3);const n=2*Math.random()*Math.PI,i=2*Math.random()-1,r=Math.sqrt(1-i*i)*t;return e[0]=Math.cos(n)*r,e[1]=Math.sin(n)*r,e[2]=i*t,e},rotateX:function(t,e,n,i){i=i||new v(3);const r=[],o=[];return r[0]=t[0]-e[0],r[1]=t[1]-e[1],r[2]=t[2]-e[2],o[0]=r[0],o[1]=r[1]*Math.cos(n)-r[2]*Math.sin(n),o[2]=r[1]*Math.sin(n)+r[2]*Math.cos(n),i[0]=o[0]+e[0],i[1]=o[1]+e[1],i[2]=o[2]+e[2],i},rotateY:function(t,e,n,i){i=i||new v(3);const r=[],o=[];return r[0]=t[0]-e[0],r[1]=t[1]-e[1],r[2]=t[2]-e[2],o[0]=r[2]*Math.sin(n)+r[0]*Math.cos(n),o[1]=r[1],o[2]=r[2]*Math.cos(n)-r[0]*Math.sin(n),i[0]=o[0]+e[0],i[1]=o[1]+e[1],i[2]=o[2]+e[2],i},rotateZ:function(t,e,n,i){i=i||new v(3);const r=[],o=[];return r[0]=t[0]-e[0],r[1]=t[1]-e[1],r[2]=t[2]-e[2],o[0]=r[0]*Math.cos(n)-r[1]*Math.sin(n),o[1]=r[0]*Math.sin(n)+r[1]*Math.cos(n),o[2]=r[2],i[0]=o[0]+e[0],i[1]=o[1]+e[1],i[2]=o[2]+e[2],i},round:function(t,e){return(e=e||new v(3))[0]=Math.round(t[0]),e[1]=Math.round(t[1]),e[2]=Math.round(t[2]),e},scale:P,set:function(t,e,n,i){return(i=i||new v(3))[0]=t,i[1]=e,i[2]=n,i},setDefaultType:function(t){const e=v;return v=t,e},setLength:I,sub:w,subtract:w,transformMat3:function(t,e,n){n=n||new v(3);const i=t[0],r=t[1],o=t[2];return n[0]=i*e[0]+r*e[4]+o*e[8],n[1]=i*e[1]+r*e[5]+o*e[9],n[2]=i*e[2]+r*e[6]+o*e[10],n},transformMat4:function(t,e,n){n=n||new v(3);const i=t[0],r=t[1],o=t[2],a=e[3]*i+e[7]*r+e[11]*o+e[15]||1;return n[0]=(e[0]*i+e[4]*r+e[8]*o+e[12])/a,n[1]=(e[1]*i+e[5]*r+e[9]*o+e[13])/a,n[2]=(e[2]*i+e[6]*r+e[10]*o+e[14])/a,n},transformMat4Upper3x3:function(t,e,n){n=n||new v(3);const i=t[0],r=t[1],o=t[2];return n[0]=i*e[0]+r*e[4]+o*e[8],n[1]=i*e[1]+r*e[5]+o*e[9],n[2]=i*e[2]+r*e[6]+o*e[10],n},transformQuat:function(t,e,n){n=n||new v(3);const i=e[0],r=e[1],o=e[2],a=2*e[3],s=t[0],u=t[1],c=t[2],l=r*c-o*u,f=o*s-i*c,d=i*u-r*s;return n[0]=s+l*a+2*(r*d-o*f),n[1]=u+f*a+2*(o*l-i*d),n[2]=c+d*a+2*(i*f-r*l),n},truncate:function(t,e,n){return n=n||new v(3),O(t)>e?I(t,e,n):G(t,n)},zero:function(t){return(t=t||new v(3))[0]=0,t[1]=0,t[2]=0,t}};let B,W,L,A=Float32Array;function N(t,e){return(e=e||new A(16))[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e[9]=t[9],e[10]=t[10],e[11]=t[11],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15],e}function K(t){return(t=t||new A(16))[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}function H(t,e){e=e||new A(16);const n=t[0],i=t[1],r=t[2],o=t[3],a=t[4],s=t[5],u=t[6],c=t[7],l=t[8],f=t[9],d=t[10],p=t[11],h=t[12],_=t[13],v=t[14],m=t[15],g=d*m,x=v*p,y=u*m,w=v*c,b=u*p,P=d*c,S=r*m,R=v*o,E=r*p,O=d*o,z=r*c,M=u*o,U=l*_,T=h*f,G=a*_,k=h*s,D=a*f,I=l*s,C=n*_,B=h*i,W=n*f,L=l*i,N=n*s,K=a*i,H=g*s+w*f+b*_-(x*s+y*f+P*_),F=x*i+S*f+O*_-(g*i+R*f+E*_),Y=y*i+R*s+z*_-(w*i+S*s+M*_),V=P*i+E*s+M*f-(b*i+O*s+z*f),q=1/(n*H+a*F+l*Y+h*V);return e[0]=q*H,e[1]=q*F,e[2]=q*Y,e[3]=q*V,e[4]=q*(x*a+y*l+P*h-(g*a+w*l+b*h)),e[5]=q*(g*n+R*l+E*h-(x*n+S*l+O*h)),e[6]=q*(w*n+S*a+M*h-(y*n+R*a+z*h)),e[7]=q*(b*n+O*a+z*l-(P*n+E*a+M*l)),e[8]=q*(U*c+k*p+D*m-(T*c+G*p+I*m)),e[9]=q*(T*o+C*p+L*m-(U*o+B*p+W*m)),e[10]=q*(G*o+B*c+N*m-(k*o+C*c+K*m)),e[11]=q*(I*o+W*c+K*p-(D*o+L*c+N*p)),e[12]=q*(G*d+I*v+T*u-(D*v+U*u+k*d)),e[13]=q*(W*v+U*r+B*d-(C*d+L*v+T*r)),e[14]=q*(C*u+K*v+k*r-(N*v+G*r+B*u)),e[15]=q*(N*d+D*r+L*u-(W*u+K*d+I*r)),e}function F(t,e,n){n=n||new A(16);const i=t[0],r=t[1],o=t[2],a=t[3],s=t[4],u=t[5],c=t[6],l=t[7],f=t[8],d=t[9],p=t[10],h=t[11],_=t[12],v=t[13],m=t[14],g=t[15],x=e[0],y=e[1],w=e[2],b=e[3],P=e[4],S=e[5],R=e[6],E=e[7],O=e[8],z=e[9],M=e[10],U=e[11],T=e[12],G=e[13],k=e[14],D=e[15];return n[0]=i*x+s*y+f*w+_*b,n[1]=r*x+u*y+d*w+v*b,n[2]=o*x+c*y+p*w+m*b,n[3]=a*x+l*y+h*w+g*b,n[4]=i*P+s*S+f*R+_*E,n[5]=r*P+u*S+d*R+v*E,n[6]=o*P+c*S+p*R+m*E,n[7]=a*P+l*S+h*R+g*E,n[8]=i*O+s*z+f*M+_*U,n[9]=r*O+u*z+d*M+v*U,n[10]=o*O+c*z+p*M+m*U,n[11]=a*O+l*z+h*M+g*U,n[12]=i*T+s*G+f*k+_*D,n[13]=r*T+u*G+d*k+v*D,n[14]=o*T+c*G+p*k+m*D,n[15]=a*T+l*G+h*k+g*D,n}function Y(t,e,n){n=n||new A(16);let i=t[0],r=t[1],o=t[2];const a=Math.sqrt(i*i+r*r+o*o);i/=a,r/=a,o/=a;const s=i*i,u=r*r,c=o*o,l=Math.cos(e),f=Math.sin(e),d=1-l;return n[0]=s+(1-s)*l,n[1]=i*r*d+o*f,n[2]=i*o*d-r*f,n[3]=0,n[4]=i*r*d-o*f,n[5]=u+(1-u)*l,n[6]=r*o*d+i*f,n[7]=0,n[8]=i*o*d+r*f,n[9]=r*o*d-i*f,n[10]=c+(1-c)*l,n[11]=0,n[12]=0,n[13]=0,n[14]=0,n[15]=1,n}function V(t,e,n,i){i=i||new A(16);let r=e[0],o=e[1],a=e[2];const s=Math.sqrt(r*r+o*o+a*a);r/=s,o/=s,a/=s;const u=r*r,c=o*o,l=a*a,f=Math.cos(n),d=Math.sin(n),p=1-f,h=u+(1-u)*f,_=r*o*p+a*d,v=r*a*p-o*d,m=r*o*p-a*d,g=c+(1-c)*f,x=o*a*p+r*d,y=r*a*p+o*d,w=o*a*p-r*d,b=l+(1-l)*f,P=t[0],S=t[1],R=t[2],E=t[3],O=t[4],z=t[5],M=t[6],U=t[7],T=t[8],G=t[9],k=t[10],D=t[11];return i[0]=h*P+_*O+v*T,i[1]=h*S+_*z+v*G,i[2]=h*R+_*M+v*k,i[3]=h*E+_*U+v*D,i[4]=m*P+g*O+x*T,i[5]=m*S+g*z+x*G,i[6]=m*R+g*M+x*k,i[7]=m*E+g*U+x*D,i[8]=y*P+w*O+b*T,i[9]=y*S+w*z+b*G,i[10]=y*R+w*M+b*k,i[11]=y*E+w*U+b*D,t!==i&&(i[12]=t[12],i[13]=t[13],i[14]=t[14],i[15]=t[15]),i}var q={__proto__:null,aim:function(t,e,n,i){return i=i||new A(16),B=B||m(),W=W||m(),L=L||m(),T(w(e,t,L),L),T(R(n,L,B),B),T(R(L,B,W),W),i[0]=B[0],i[1]=B[1],i[2]=B[2],i[3]=0,i[4]=W[0],i[5]=W[1],i[6]=W[2],i[7]=0,i[8]=L[0],i[9]=L[1],i[10]=L[2],i[11]=0,i[12]=t[0],i[13]=t[1],i[14]=t[2],i[15]=1,i},axisRotate:V,axisRotation:Y,cameraAim:function(t,e,n,i){return i=i||new A(16),B=B||m(),W=W||m(),L=L||m(),T(w(t,e,L),L),T(R(n,L,B),B),T(R(L,B,W),W),i[0]=B[0],i[1]=B[1],i[2]=B[2],i[3]=0,i[4]=W[0],i[5]=W[1],i[6]=W[2],i[7]=0,i[8]=L[0],i[9]=L[1],i[10]=L[2],i[11]=0,i[12]=t[0],i[13]=t[1],i[14]=t[2],i[15]=1,i},clone:N,copy:N,create:function(t,e,n,i,r,o,a,s,u,c,l,f,d,p,h,_){const v=new A(16);return void 0!==t&&(v[0]=t,void 0!==e&&(v[1]=e,void 0!==n&&(v[2]=n,void 0!==i&&(v[3]=i,void 0!==r&&(v[4]=r,void 0!==o&&(v[5]=o,void 0!==a&&(v[6]=a,void 0!==s&&(v[7]=s,void 0!==u&&(v[8]=u,void 0!==c&&(v[9]=c,void 0!==l&&(v[10]=l,void 0!==f&&(v[11]=f,void 0!==d&&(v[12]=d,void 0!==p&&(v[13]=p,void 0!==h&&(v[14]=h,void 0!==_&&(v[15]=_)))))))))))))))),v},determinant:function(t){const e=t[0],n=t[1],i=t[2],r=t[3],o=t[4],a=t[5],s=t[6],u=t[7],c=t[8],l=t[9],f=t[10],d=t[11],p=t[12],h=t[13],_=t[14],v=t[15],m=f*v,g=_*d,x=s*v,y=_*u,w=s*d,b=f*u,P=i*v,S=_*r,R=i*d,E=f*r,O=i*u,z=s*r;return e*(m*a+y*l+w*h-(g*a+x*l+b*h))+o*(g*n+P*l+E*h-(m*n+S*l+R*h))+c*(x*n+S*a+O*h-(y*n+P*a+z*h))+p*(b*n+R*a+z*l-(w*n+E*a+O*l))},equals:function(t,e){return t[0]===e[0]&&t[1]===e[1]&&t[2]===e[2]&&t[3]===e[3]&&t[4]===e[4]&&t[5]===e[5]&&t[6]===e[6]&&t[7]===e[7]&&t[8]===e[8]&&t[9]===e[9]&&t[10]===e[10]&&t[11]===e[11]&&t[12]===e[12]&&t[13]===e[13]&&t[14]===e[14]&&t[15]===e[15]},equalsApproximately:function(t,e){return Math.abs(t[0]-e[0])<_&&Math.abs(t[1]-e[1])<_&&Math.abs(t[2]-e[2])<_&&Math.abs(t[3]-e[3])<_&&Math.abs(t[4]-e[4])<_&&Math.abs(t[5]-e[5])<_&&Math.abs(t[6]-e[6])<_&&Math.abs(t[7]-e[7])<_&&Math.abs(t[8]-e[8])<_&&Math.abs(t[9]-e[9])<_&&Math.abs(t[10]-e[10])<_&&Math.abs(t[11]-e[11])<_&&Math.abs(t[12]-e[12])<_&&Math.abs(t[13]-e[13])<_&&Math.abs(t[14]-e[14])<_&&Math.abs(t[15]-e[15])<_},fromMat3:function(t,e){return(e=e||new A(16))[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=0,e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=0,e[8]=t[8],e[9]=t[9],e[10]=t[10],e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e},fromQuat:function(t,e){e=e||new A(16);const n=t[0],i=t[1],r=t[2],o=t[3],a=n+n,s=i+i,u=r+r,c=n*a,l=i*a,f=i*s,d=r*a,p=r*s,h=r*u,_=o*a,v=o*s,m=o*u;return e[0]=1-f-h,e[1]=l+m,e[2]=d-v,e[3]=0,e[4]=l-m,e[5]=1-c-h,e[6]=p+_,e[7]=0,e[8]=d+v,e[9]=p-_,e[10]=1-c-f,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e},frustum:function(t,e,n,i,r,o,a){const s=e-t,u=i-n,c=r-o;return(a=a||new A(16))[0]=2*r/s,a[1]=0,a[2]=0,a[3]=0,a[4]=0,a[5]=2*r/u,a[6]=0,a[7]=0,a[8]=(t+e)/s,a[9]=(i+n)/u,a[10]=o/c,a[11]=-1,a[12]=0,a[13]=0,a[14]=r*o/c,a[15]=0,a},frustumReverseZ:function(t,e,n,i,r,o=1/0,a){const s=e-t,u=i-n;if((a=a||new A(16))[0]=2*r/s,a[1]=0,a[2]=0,a[3]=0,a[4]=0,a[5]=2*r/u,a[6]=0,a[7]=0,a[8]=(t+e)/s,a[9]=(i+n)/u,a[11]=-1,a[12]=0,a[13]=0,a[15]=0,o===1/0)a[10]=0,a[14]=r;else{const t=1/(o-r);a[10]=r*t,a[14]=o*r*t}return a},getAxis:function(t,e,n){const i=4*e;return(n=n||m())[0]=t[i+0],n[1]=t[i+1],n[2]=t[i+2],n},getScaling:function(t,e){e=e||m();const n=t[0],i=t[1],r=t[2],o=t[4],a=t[5],s=t[6],u=t[8],c=t[9],l=t[10];return e[0]=Math.sqrt(n*n+i*i+r*r),e[1]=Math.sqrt(o*o+a*a+s*s),e[2]=Math.sqrt(u*u+c*c+l*l),e},getTranslation:function(t,e){return(e=e||m())[0]=t[12],e[1]=t[13],e[2]=t[14],e},identity:K,inverse:H,invert:H,lookAt:function(t,e,n,i){return i=i||new A(16),B=B||m(),W=W||m(),L=L||m(),T(w(t,e,L),L),T(R(n,L,B),B),T(R(L,B,W),W),i[0]=B[0],i[1]=W[0],i[2]=L[0],i[3]=0,i[4]=B[1],i[5]=W[1],i[6]=L[1],i[7]=0,i[8]=B[2],i[9]=W[2],i[10]=L[2],i[11]=0,i[12]=-(B[0]*t[0]+B[1]*t[1]+B[2]*t[2]),i[13]=-(W[0]*t[0]+W[1]*t[1]+W[2]*t[2]),i[14]=-(L[0]*t[0]+L[1]*t[1]+L[2]*t[2]),i[15]=1,i},mul:F,multiply:F,negate:function(t,e){return(e=e||new A(16))[0]=-t[0],e[1]=-t[1],e[2]=-t[2],e[3]=-t[3],e[4]=-t[4],e[5]=-t[5],e[6]=-t[6],e[7]=-t[7],e[8]=-t[8],e[9]=-t[9],e[10]=-t[10],e[11]=-t[11],e[12]=-t[12],e[13]=-t[13],e[14]=-t[14],e[15]=-t[15],e},ortho:function(t,e,n,i,r,o,a){return(a=a||new A(16))[0]=2/(e-t),a[1]=0,a[2]=0,a[3]=0,a[4]=0,a[5]=2/(i-n),a[6]=0,a[7]=0,a[8]=0,a[9]=0,a[10]=1/(r-o),a[11]=0,a[12]=(e+t)/(t-e),a[13]=(i+n)/(n-i),a[14]=r/(r-o),a[15]=1,a},perspective:function(t,e,n,i,r){r=r||new A(16);const o=Math.tan(.5*Math.PI-.5*t);if(r[0]=o/e,r[1]=0,r[2]=0,r[3]=0,r[4]=0,r[5]=o,r[6]=0,r[7]=0,r[8]=0,r[9]=0,r[11]=-1,r[12]=0,r[13]=0,r[15]=0,Number.isFinite(i)){const t=1/(n-i);r[10]=i*t,r[14]=i*n*t}else r[10]=-1,r[14]=-n;return r},perspectiveReverseZ:function(t,e,n,i=1/0,r){r=r||new A(16);const o=1/Math.tan(.5*t);if(r[0]=o/e,r[1]=0,r[2]=0,r[3]=0,r[4]=0,r[5]=o,r[6]=0,r[7]=0,r[8]=0,r[9]=0,r[11]=-1,r[12]=0,r[13]=0,r[15]=0,i===1/0)r[10]=0,r[14]=n;else{const t=1/(i-n);r[10]=n*t,r[14]=i*n*t}return r},rotate:V,rotateX:function(t,e,n){n=n||new A(16);const i=t[4],r=t[5],o=t[6],a=t[7],s=t[8],u=t[9],c=t[10],l=t[11],f=Math.cos(e),d=Math.sin(e);return n[4]=f*i+d*s,n[5]=f*r+d*u,n[6]=f*o+d*c,n[7]=f*a+d*l,n[8]=f*s-d*i,n[9]=f*u-d*r,n[10]=f*c-d*o,n[11]=f*l-d*a,t!==n&&(n[0]=t[0],n[1]=t[1],n[2]=t[2],n[3]=t[3],n[12]=t[12],n[13]=t[13],n[14]=t[14],n[15]=t[15]),n},rotateY:function(t,e,n){n=n||new A(16);const i=t[0],r=t[1],o=t[2],a=t[3],s=t[8],u=t[9],c=t[10],l=t[11],f=Math.cos(e),d=Math.sin(e);return n[0]=f*i-d*s,n[1]=f*r-d*u,n[2]=f*o-d*c,n[3]=f*a-d*l,n[8]=f*s+d*i,n[9]=f*u+d*r,n[10]=f*c+d*o,n[11]=f*l+d*a,t!==n&&(n[4]=t[4],n[5]=t[5],n[6]=t[6],n[7]=t[7],n[12]=t[12],n[13]=t[13],n[14]=t[14],n[15]=t[15]),n},rotateZ:function(t,e,n){n=n||new A(16);const i=t[0],r=t[1],o=t[2],a=t[3],s=t[4],u=t[5],c=t[6],l=t[7],f=Math.cos(e),d=Math.sin(e);return n[0]=f*i+d*s,n[1]=f*r+d*u,n[2]=f*o+d*c,n[3]=f*a+d*l,n[4]=f*s-d*i,n[5]=f*u-d*r,n[6]=f*c-d*o,n[7]=f*l-d*a,t!==n&&(n[8]=t[8],n[9]=t[9],n[10]=t[10],n[11]=t[11],n[12]=t[12],n[13]=t[13],n[14]=t[14],n[15]=t[15]),n},rotation:Y,rotationX:function(t,e){e=e||new A(16);const n=Math.cos(t),i=Math.sin(t);return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=n,e[6]=i,e[7]=0,e[8]=0,e[9]=-i,e[10]=n,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e},rotationY:function(t,e){e=e||new A(16);const n=Math.cos(t),i=Math.sin(t);return e[0]=n,e[1]=0,e[2]=-i,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=i,e[9]=0,e[10]=n,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e},rotationZ:function(t,e){e=e||new A(16);const n=Math.cos(t),i=Math.sin(t);return e[0]=n,e[1]=i,e[2]=0,e[3]=0,e[4]=-i,e[5]=n,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e},scale:function(t,e,n){n=n||new A(16);const i=e[0],r=e[1],o=e[2];return n[0]=i*t[0],n[1]=i*t[1],n[2]=i*t[2],n[3]=i*t[3],n[4]=r*t[4],n[5]=r*t[5],n[6]=r*t[6],n[7]=r*t[7],n[8]=o*t[8],n[9]=o*t[9],n[10]=o*t[10],n[11]=o*t[11],t!==n&&(n[12]=t[12],n[13]=t[13],n[14]=t[14],n[15]=t[15]),n},scaling:function(t,e){return(e=e||new A(16))[0]=t[0],e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=t[1],e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=t[2],e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e},set:function(t,e,n,i,r,o,a,s,u,c,l,f,d,p,h,_,v){return(v=v||new A(16))[0]=t,v[1]=e,v[2]=n,v[3]=i,v[4]=r,v[5]=o,v[6]=a,v[7]=s,v[8]=u,v[9]=c,v[10]=l,v[11]=f,v[12]=d,v[13]=p,v[14]=h,v[15]=_,v},setAxis:function(t,e,n,i){i!==t&&(i=N(t,i));const r=4*n;return i[r+0]=e[0],i[r+1]=e[1],i[r+2]=e[2],i},setDefaultType:function(t){const e=A;return A=t,e},setTranslation:function(t,e,n){return t!==(n=n||K())&&(n[0]=t[0],n[1]=t[1],n[2]=t[2],n[3]=t[3],n[4]=t[4],n[5]=t[5],n[6]=t[6],n[7]=t[7],n[8]=t[8],n[9]=t[9],n[10]=t[10],n[11]=t[11]),n[12]=e[0],n[13]=e[1],n[14]=e[2],n[15]=1,n},translate:function(t,e,n){n=n||new A(16);const i=e[0],r=e[1],o=e[2],a=t[0],s=t[1],u=t[2],c=t[3],l=t[4],f=t[5],d=t[6],p=t[7],h=t[8],_=t[9],v=t[10],m=t[11],g=t[12],x=t[13],y=t[14],w=t[15];return t!==n&&(n[0]=a,n[1]=s,n[2]=u,n[3]=c,n[4]=l,n[5]=f,n[6]=d,n[7]=p,n[8]=h,n[9]=_,n[10]=v,n[11]=m),n[12]=a*i+l*r+h*o+g,n[13]=s*i+f*r+_*o+x,n[14]=u*i+d*r+v*o+y,n[15]=c*i+p*r+m*o+w,n},translation:function(t,e){return(e=e||new A(16))[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=t[0],e[13]=t[1],e[14]=t[2],e[15]=1,e},transpose:function(t,e){if((e=e||new A(16))===t){let n;return n=t[1],t[1]=t[4],t[4]=n,n=t[2],t[2]=t[8],t[8]=n,n=t[3],t[3]=t[12],t[12]=n,n=t[6],t[6]=t[9],t[9]=n,n=t[7],t[7]=t[13],t[13]=n,n=t[11],t[11]=t[14],t[14]=n,e}const n=t[0],i=t[1],r=t[2],o=t[3],a=t[4],s=t[5],u=t[6],c=t[7],l=t[8],f=t[9],d=t[10],p=t[11],h=t[12],_=t[13],v=t[14],m=t[15];return e[0]=n,e[1]=a,e[2]=l,e[3]=h,e[4]=i,e[5]=s,e[6]=f,e[7]=_,e[8]=r,e[9]=u,e[10]=d,e[11]=v,e[12]=o,e[13]=c,e[14]=p,e[15]=m,e},uniformScale:function(t,e,n){return(n=n||new A(16))[0]=e*t[0],n[1]=e*t[1],n[2]=e*t[2],n[3]=e*t[3],n[4]=e*t[4],n[5]=e*t[5],n[6]=e*t[6],n[7]=e*t[7],n[8]=e*t[8],n[9]=e*t[9],n[10]=e*t[10],n[11]=e*t[11],t!==n&&(n[12]=t[12],n[13]=t[13],n[14]=t[14],n[15]=t[15]),n},uniformScaling:function(t,e){return(e=e||new A(16))[0]=t,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=t,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=t,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}};Float32Array,Float32Array;class X{constructor(t,e,n,i,r,o,a){this.height=t,this.width=e,this.viewMatrix=n,this.perspective=i,this.focalX=r,this.focalY=o,this.scaleModifier=a}static default(){return new X(window.innerHeight,window.innerWidth,q.lookAt([0,0,-2],[0,0,0],[0,1,0]),q.perspective(1.04719755,1,.03,1e3),600,600,1)}dotZ(){const t=this.depthAxis();return e=>C.dot(t,e)}getPosition(){const t=q.inverse(this.viewMatrix);return q.getTranslation(t)}getProjMatrix(){var t=q.clone(this.perspective);return t=q.mul(t,function(){const t=q.create();return t[0]=1,t[5]=-1,t[10]=1,t[15]=1,t}()),q.multiply(t,this.viewMatrix)}translate(t,e,n){const i=q.inverse(this.viewMatrix);q.translate(i,[t,e,n],i),q.inverse(i,this.viewMatrix)}rotate(t,e,n){const i=q.inverse(this.viewMatrix);q.rotateX(i,e,i),q.rotateY(i,t,i),q.rotateZ(i,n,i),q.inverse(i,this.viewMatrix)}depthAxis(){return q.getAxis(q.transpose(this.viewMatrix),2)}}class j{constructor(t,e){this.drag=!1,this.oldX=0,this.oldY=0,this.dRX=0,this.dRY=0,this.dRZ=0,this.dTX=0,this.dTY=0,this.dTZ=0,this.dirty=!0,this.camera=t,this.canvas=e,this.createCallbacks()}static default(t){return new j(X.default(),t)}createCallbacks(){this.canvas.addEventListener("mousedown",(t=>{this.drag=!0,this.oldX=t.pageX,this.oldY=t.pageY,this.setDirty(),t.preventDefault()}),!1),this.canvas.addEventListener("mouseup",(t=>{this.drag=!1}),!1),this.canvas.addEventListener("mousemove",(t=>{if(!this.drag)return!1;this.dRX=2*(t.pageX-this.oldX)*Math.PI/this.canvas.width,this.dRY=2*-(t.pageY-this.oldY)*Math.PI/this.canvas.height,this.oldX=t.pageX,this.oldY=t.pageY,this.setDirty(),t.preventDefault()}),!1),this.canvas.addEventListener("wheel",(t=>{this.dTZ=.1*t.deltaY,this.setDirty(),t.preventDefault()}),!1),window.addEventListener("keydown",(t=>{const e={w:()=>{this.dTY-=.1},s:()=>{this.dTY+=.1},a:()=>{this.dTX-=.1},d:()=>{this.dTX+=.1},q:()=>{this.dTZ+=.1},e:()=>{this.dTZ-=.1},j:()=>{this.dRX+=.1},l:()=>{this.dRX-=.1},i:()=>{this.dRY+=.1},k:()=>{this.dRY-=.1},u:()=>{this.dRZ+=.1},o:()=>{this.dRZ-=.1}};e[t.key]&&(e[t.key](),this.setDirty(),t.preventDefault())}),!1)}setNewCamera(t){console.log("set camera"+t),this.camera=t,this.setDirty()}setDirty(){this.dirty=!0}setClean(){this.dirty=!1}isDirty(){return this.dirty}getCamera(){return this.isDirty()&&(this.camera.translate(this.dTX,this.dTY,this.dTZ),this.camera.rotate(this.dRX,this.dRY,this.dRZ),this.dTX=this.dTY=this.dTZ=this.dRX=this.dRY=this.dRZ=0,this.setClean()),this.camera}}function Z(t,e){return 2*Math.atan(e/(2*t))}class ${constructor(t,e,n){this.gpu=t,this.adapter=e,this.device=n}static create(){return t=this,e=void 0,i=function*(){const t=navigator.gpu;if(!t)return Promise.reject("WebGPU not supported on this browser! (navigator.gpu is null)");const e=yield t.requestAdapter();if(!e)return Promise.reject("WebGPU not supported on this browser! (gpu.adapter is null)");const n=yield e.requestDevice({label:"GPUDevice"});return new $(t,e,n)},new((n=void 0)||(n=Promise))((function(r,o){function a(t){try{u(i.next(t))}catch(t){o(t)}}function s(t){try{u(i.throw(t))}catch(t){o(t)}}function u(t){var e;t.done?r(t.value):(e=t.value,e instanceof n?e:new n((function(t){t(e)}))).then(a,s)}u((i=i.apply(t,e||[])).next())}));var t,e,n,i}destroy(){this.device.destroy(),this.adapter=null,this.device=null}}var J=n(949);class Q{constructor(t,e,n,i,r){const o="rgba16float",a=e.getContext("webgpu");if(!a)throw new Error("WebGPU context not found!");this.contextGpu=a,this.context=t;const s=new Float32Array([0,.5,0,-.5,-.5,0,.5,-.5,0]);this.vertexBuffer=this.context.device.createBuffer({size:s.byteLength,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC}),this.context.device.queue.writeBuffer(this.vertexBuffer,0,s);const u=this.context.device.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT,buffer:{type:"read-only-storage"}},{binding:1,visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT,buffer:{type:"uniform"}},{binding:2,visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT,buffer:{type:"read-only-storage"}}]});this.pointBindGroup=this.context.device.createBindGroup({layout:u,entries:[{binding:0,resource:{buffer:n}},{binding:1,resource:{buffer:i}},{binding:2,resource:{buffer:r}}]});const c=this.context.device.createPipelineLayout({label:"Simple draw layout ",bindGroupLayouts:[u]});let l=`\n\t\n    // spherical harmonic coefficients\n    const SH_C0 = 0.28209479177387814f;\n    const SH_C1 = 0.4886025119029199f;\n    const SH_C2 = array(\n        1.0925484305920792f,\n        -1.0925484305920792f,\n        0.31539156525252005f,\n        -1.0925484305920792f,\n        0.5462742152960396f\n    );\n    const SH_C3 = array(\n        -0.5900435899266435f,\n        2.890611442640554f,\n        -0.4570457994644658f,\n        0.3731763325901154f,\n        -0.4570457994644658f,\n        1.445305721320277f,\n        -0.5900435899266435f\n    );\n\n    fn compute_color_from_sh(position: vec3<f32>, sh: array<vec3<f32>, 16>) -> vec3<f32> {\n        let dir = normalize(position - uniforms.camera_position);\n        var result = SH_C0 * sh[0];\n\n        // if deg > 0\n        let x = dir.x;\n        let y = dir.y;\n        let z = dir.z;\n\n        result = result + SH_C1 * (-y * sh[1] + z * sh[2] - x * sh[3]);\n\n        let xx = x * x;\n        let yy = y * y;\n        let zz = z * z;\n        let xy = x * y;\n        let xz = x * z;\n        let yz = y * z;\n\n        // if (sh_degree > 1) {\n        result = result +\n            SH_C2[0] * xy * sh[4] +\n            SH_C2[1] * yz * sh[5] +\n            SH_C2[2] * (2. * zz - xx - yy) * sh[6] +\n            SH_C2[3] * xz * sh[7] +\n            SH_C2[4] * (xx - yy) * sh[8];\n        \n        // if (sh_degree > 2) {\n        result = result +\n            SH_C3[0] * y * (3. * xx - yy) * sh[9] +\n            SH_C3[1] * xy * z * sh[10] +\n            SH_C3[2] * y * (4. * zz - xx - yy) * sh[11] +\n            SH_C3[3] * z * (2. * zz - 3. * xx - 3. * yy) * sh[12] +\n            SH_C3[4] * x * (4. * zz - xx - yy) * sh[13] +\n            SH_C3[5] * z * (xx - yy) * sh[14] +\n            SH_C3[6] * x * (xx - 3. * yy) * sh[15];\n\n        // unconditional\n        result = result + 0.5;\n\n        return max(result, vec3<f32>(0.));\n    }\n\n\tconst n_sh_coeffs = 16;\t\n\n\tstruct PointInput {\n            @location(0) position: vec3<f32>,\n            @location(1) log_scale: vec3<f32>,\n            @location(2) rot: vec4<f32>,\n            @location(3) opacity_logit: f32,\n            sh: array<vec3<f32>, n_sh_coeffs>,\n        };\n\tstruct Uniforms {\n            viewMatrix: mat4x4<f32>,\n            projMatrix: mat4x4<f32>,\n            camera_position: vec3<f32>,\n            tan_fovx: f32,\n            tan_fovy: f32,\n            focal_x: f32,\n            focal_y: f32,\n            scale_modifier: f32,\n        };\n\tstruct PointOutput {\n\t\t@builtin(position) position: vec4<f32>,\n\t\t@location(0) color: vec3<f32>,\n\t\t@location(1) uv: vec2<f32>,\n\t\t@location(2) conic_and_opacity: vec4<f32>,\n\t};\n\n\tfn CalcMatrixFromRotationScale(rot: vec4<f32>, scale: vec3<f32>) -> mat3x3<f32> {\n\t\tlet modifier = uniforms.scale_modifier;\n\t\t\tlet ms = mat3x3<f32>(\n\t\t\t\tscale.x  * modifier, 0.0, 0.0,\n\t\t\t\t0.0, scale.y  * modifier, 0.0,\n\t\t\t\t0.0, 0.0, scale.z  * modifier\n\t\t\t);\n\n\t\t\tlet x = rot.x;\n\t\t\tlet y = rot.y;\n\t\t\tlet z = rot.z;\n\t\t\tlet w = rot.w;\n\n\t\t\tlet mr = mat3x3<f32>(\n\t\t\t\t1.0 - 2.0 * (y * y + z * z), 2.0 * (x * y - w * z), 2.0 * (x * z + w * y),\n\t\t\t\t2.0 * (x * y + w * z), 1.0 - 2.0 * (x * x + z * z), 2.0 * (y * z - w * x),\n\t\t\t\t2.0 * (x * z - w * y), 2.0 * (y * z + w * x), 1.0 - 2.0 * (x * x + y * y)\n\t\t\t);\n\n\t\t\treturn mr * ms;\n\t\t}\n\tfn sigmoid(x: f32) -> f32 {\n\t\tif (x >= 0.) {\n\t\t\treturn 1. / (1. + exp(-x));\n\t\t} else {\n\t\t\tlet z = exp(x);\n\t\t\treturn z / (1. + z);\n\t\t}\n\t}\n\n\tfn compute_cov3d(log_scale: vec3<f32>, rot: vec4<f32>) -> array<f32, 6> {\n\t\t// ------------ CalcMatrixFromRotationScale ----------------\n\t\tlet modifier = uniforms.scale_modifier;\n\t\t\n\t\tlet S = mat3x3<f32>(\n\t\t\t(log_scale.x) * modifier, 0., 0.,\n\t\t\t0., (log_scale.y) * modifier, 0.,\n\t\t\t0., 0., (log_scale.z) * modifier,\n\t\t);\n\t\t\n\t\tlet x = rot.x;\n\t\tlet y = rot.y;\n\t\tlet z = rot.z;\n\t\tlet w = rot.w;\n\n\t\tlet R = mat3x3<f32>(\n\t\t\t1-2*(y*y + z*z),   2*(x*y - w*z),   2*(x*z + w*y),\n          \t2*(x*y + w*z), 1-2*(x*x + z*z),   2*(y*z - w*x),\n          \t2*(x*z - w*y),   2*(y*z + w*x), 1-2*(x*x + y*y)\n\t\t);\n\n\t\tlet M =  R * S;\n\n\t\t// ------------ CalcCovariance3D ----------------\n\t\tlet Sigma = M * transpose(M) ;\t\t\n\t\treturn array<f32, 6>(\n\t\t\t/*\n\t\t\t*/\n\t\t\tSigma[0][0],\n\t\t\tSigma[0][1],\n\t\t\tSigma[0][2],\n\t\t\tSigma[1][1],\n\t\t\tSigma[1][2],\t\t\t\n\t\t\tSigma[2][2],\t\t\t\n\t\t);\n\t} \n\n\t@group(0) @binding(0) var<storage, read> points: array<PointInput>;\n\t@group(0) @binding(1) var<uniform> \t\t\t\tuniforms: Uniforms;\n\t@group(0) @binding(2)  var<storage, read> sorted_idx: array<u32>;\n\t@group(0) @binding(3)  var<storage, read_write> debug_arr: array<u32>;\n\t\t\n\t@fragment\n\tfn fs_main(input: PointOutput) ->@location(0) vec4f  {\n\t\tlet selectedColor : vec3<f32> = vec3<f32> (1,0,1);\n\t\tvar opacity = input.conic_and_opacity.w;   \n\t\tvar color : vec4<f32> = vec4<f32> (input.color ,opacity);\n\t\tlet power :f32 = -dot(input.uv, input.uv);\n\t\tvar alpha :f32 = exp(power);\n\t\tif(opacity>=0){\n\t\t\talpha = saturate(alpha * opacity );\n\t\t}\n\t\t/*\n\t\t*/\n\t\telse{\n\t\t\tif(alpha > 7.0/255.0){\n\t\t\t\tif(alpha < 10.0 /255.0){\n\t\t\t\t\talpha = 1;\n\t\t\t\t\tcolor = vec4<f32> (selectedColor , color.a);\n\t\t\t\t}\n\t\t\t\talpha = saturate(alpha +0.3);\n\t\t\t}\n\t\t\tcolor = vec4<f32> ( mix(input.color.rgb , selectedColor , 0.5 ) , color.a);\n\t\t}\n\t\tif(alpha < 1.0/255.0){\n\t\t\tdiscard;\n\t\t}\n\t\t\n\t\t\n\t\treturn vec4<f32>(input.color * alpha, alpha);\n\t\t//return vec4<f32>(alpha,alpha,alpha, 1);\n\t\t//return vec4<f32>(color.rgb, 1);\n\t\t//return color;\n\t\t}\n\tfn asfloat(hex: u32) -> f32 {\n\t\tlet float_value = bitcast<f32>(hex);\n\t\treturn float_value;\n\t}\n\tfn safe_normalize_v2(v: vec2<f32>) -> vec2<f32> {\n\t\tlet epsilon = 1e-10;\n\t\tvar x = v.x;\n\t\tvar y = v.y;\n\t\tif(v.x !=0){\n\t\t\tx= x +epsilon;\n\t\t}\n\t\tif(v.y!=0){\n\t\t\ty= y +epsilon;\n\t\t}\n\t\treturn normalize( vec2f(x,y));\n\t}\n\t@vertex\n\tfn vs_points(\n\t\t@builtin(vertex_index) vtxID: u32,\n    \t@builtin(instance_index) instID: u32,\n\t\t@location(0) pos: vec3f ) -> PointOutput {\n\t\t\n\t\tvar output: PointOutput;\n\t\tlet p_idx = sorted_idx[instID];\n\t\tvar point = points[p_idx] ;\t\t\t\t\n\t\tlet idx = vtxID;\n\n\t\tvar clipPos =  uniforms.projMatrix * uniforms.viewMatrix  * vec4f( point.position , 1);\t\n\n\t\tif(clipPos.w<=0){\n\t\t\tlet nanfloat = asfloat(0x7fc00000);\n\t\t\toutput.position = vec4<f32>(nanfloat , nanfloat , nanfloat,nanfloat); // NaN discards the primitive\n\t\t}\n\t\telse{\n\t\t\n\t\t\tvar quadPos = vec2<f32>(\n\t\t\t\tf32(idx&1), \n\t\t\t\tf32((idx>>1)&1)\n\t\t\t\t) * 2.0 -1 ;\n\t\t\tquadPos *=2;\n\t\t\toutput.uv  = quadPos;\n\t\t\toutput.position  = clipPos  ;\n\t\t\t\t\t\t\t\t\n\n\t\t\tlet splatRotScaleMat : mat3x3<f32> = CalcMatrixFromRotationScale(point.rot, point.log_scale);\n\n\t\t\tlet sig :  mat3x3<f32> = splatRotScaleMat * transpose(splatRotScaleMat);\n\t\t\tvar cov3d0 : vec3f = vec3f (sig[0][0] , sig[0][1] , sig[0][2]  );\n\t\t\tvar cov3d1 : vec3f = vec3f (sig[1][1] , sig[1][2] , sig[2][2]  );\n\t\t\t\n\t\t\t//output.uv *= cov3d1.yz;   // Why it broke?\n\t\t\tlet splatScale = 1.0;\n        \tlet splatScale2 = splatScale * splatScale;\n\t\t\tcov3d0 *= splatScale2;\n\t\t\tcov3d1 *= splatScale2;\n\t\t\t\n\t\t\tlet _VecScreenParams = vec4f(${f=e.width},${d=e.height},0,0);\n\n\t\t\tvar viewPos:vec3f = (uniforms.viewMatrix * vec4<f32>(point.position, 1.0)).xyz;\n\t\t\tlet aspect = uniforms.projMatrix[0][0] / uniforms.projMatrix[1][1] ;  \t\t\t\n\n\t\t\tlet tanFovX: f32 = 1.0 / uniforms.projMatrix[0][0];\n\t\t\tlet tanFovY: f32 = 1.0 / (uniforms.projMatrix[1][1] * aspect);\n\n\t\t\tlet limx = 1.3 * tanFovX;\n\t\t\tlet limy = 1.3 * tanFovY;\n\t\t\tlet txtz = viewPos.x / viewPos.z;\n\t\t\tlet tytz = viewPos.y / viewPos.z;\n\n\t\t\tviewPos.x = min(limx, max(-limx, txtz)) * viewPos.z;\n\t\t\tviewPos.y = min(limy, max(-limy, tytz)) * viewPos.z;\n\n\t\t\tlet focal = _VecScreenParams.x * uniforms.projMatrix[0][0] / 2;\n\t\t\tlet J = mat3x3(\n\t\t\t\tfocal / viewPos.z, 0., -(focal * viewPos.x) / (viewPos.z * viewPos.z),\n\t\t\t\t0., focal / viewPos.z, -(focal * viewPos.y) / (viewPos.z * viewPos.z),\n\t\t\t\t0., 0., 0., \n\t\t\t);\n\n\t\t\tlet W = mat3x3<f32>(\n\t\t\t\tuniforms.viewMatrix[0].xyz,\n\t\t\t\tuniforms.viewMatrix[1].xyz,\n\t\t\t\tuniforms.viewMatrix[2].xyz\n\t\t\t);\n\t\t\t\n\t\t\tlet T = J * W;\n\n\t\t\tlet Vrk = mat3x3(\n\t\t\t\tcov3d0.x, cov3d0.y, cov3d0.z,\n\t\t\t\tcov3d0.y, cov3d1.x, cov3d1.y,\n\t\t\t\tcov3d0.z, cov3d1.y, cov3d1.z\t\n\t\t\t);\n\n\t\t\tvar cov2d_mat = T * ((Vrk) * transpose(T));\n\t\t\tcov2d_mat[0][0] += 0.3;\n\t\t\tcov2d_mat[1][1] += 0.3;\n\n\t\t\tlet cov2d :vec3f  = vec3f(cov2d_mat[0][0] , -cov2d_mat[0][1] , cov2d_mat[1][1]);\n\t\t\t\n\n\t\t\tlet diag1 =  cov2d.x;\n\t\t\tlet diag2 =  cov2d.z;\n\t\t\tlet offDiag =  cov2d.y;\t\t\t\t\t\n\t\t\t\n\t\t\tvar mid =  0.5 *  (diag1 + diag2);\n\t\t\tvar radius = length(vec2<f32>((diag1 - diag2) /2.0  , offDiag));\n\t\t\tvar lambda1 = mid + radius;\n\t\t\tvar lambda2 = max(mid - radius , 0.1);\n\t\t\tvar diagVec : vec2<f32> = safe_normalize_v2(vec2<f32>(offDiag , lambda1 - diag1));\n\t\t\tdiagVec.y = -diagVec.y;\n\t\t\t\n\t\t\tlet maxSize :f32 = 4096.0;\n\t\t\tlet v1 : vec2<f32> = min(sqrt(2.0 * lambda1) , maxSize) * diagVec;        \n\t\t\tlet v2 : vec2<f32> = min(sqrt(2.0 * lambda2) , maxSize) * vec2<f32>(diagVec.y , -diagVec.x);\n\t\t\n\t\tlet _ScreenParams : vec2<f32> = vec2<f32>(${f},${d});       \t\t\n\t\tlet deltaScreenPos :vec2<f32> = vec2<f32>(quadPos.x * v1 + quadPos.y * v2) * 2 /_ScreenParams.xy;\t\t\n\n        output.position  .x += deltaScreenPos.x * clipPos.w;\n        output.position  .y += deltaScreenPos.y * clipPos.w;\n\t\toutput.color = compute_color_from_sh(point.position, point.sh);\n\t\t\n\t\t//================= Other ======================\n\t\tlet det = cov2d.x * cov2d.z - cov2d.y * cov2d.y;\t\n        let det_inv = 1.0 / det;\n\t\t\n        let conic = vec3<f32>(cov2d.z * det_inv, -cov2d.y * det_inv, cov2d.x * det_inv);\n        \toutput.conic_and_opacity = vec4<f32>(conic, sigmoid(point.opacity_logit));\n\t\t}\n\t\treturn output;\n\n\t}\n\t`;var f,d;console.log("canvas w,h"+ +e.width+" "+e.height),this.pipeline=this.context.device.createRenderPipeline({vertex:{module:this.context.device.createShaderModule({code:l}),entryPoint:"vs_points",buffers:[{arrayStride:12,attributes:[{format:"float32x3",offset:0,shaderLocation:0}]}]},fragment:{module:this.context.device.createShaderModule({code:l}),entryPoint:"fs_main",targets:[{format:o,blend:{color:{srcFactor:"one-minus-dst-alpha",dstFactor:"one",operation:"add"},alpha:{srcFactor:"one-minus-dst-alpha",dstFactor:"one",operation:"add"}}}]},primitive:{topology:"triangle-list",stripIndexFormat:void 0,cullMode:void 0},layout:c});const p=new Uint32Array([0,1,2,1,3,2]);this.drawIndexBuffer=this.context.device.createBuffer({size:p.byteLength,usage:GPUBufferUsage.INDEX|GPUBufferUsage.COPY_DST,mappedAtCreation:!0}),new Uint32Array(this.drawIndexBuffer.getMappedRange()).set(p),this.drawIndexBuffer.unmap();this.pp_splat_pos_Buffer=this.context.device.createBuffer({size:1600,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC}),this.context.device.queue.writeBuffer(this.pp_splat_pos_Buffer,0,new Float32Array(400)),this.pp_splat_axis_Buffer=this.context.device.createBuffer({size:1600,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC}),this.context.device.queue.writeBuffer(this.pp_splat_axis_Buffer,0,new Float32Array(400));const h=this.context.device.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}},{binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:3,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}}]});this.preprocess_BindGroup=this.context.device.createBindGroup({layout:h,label:"pre_process BindGroup",entries:[{binding:0,resource:{buffer:this.pp_splat_pos_Buffer}},{binding:1,resource:{buffer:this.pp_splat_axis_Buffer}},{binding:2,resource:{buffer:n}},{binding:3,resource:{buffer:i}}]});const _=this.context.device.createPipelineLayout({bindGroupLayouts:[h]});this.pre_processPipeline=this.context.device.createComputePipeline({layout:_,compute:{module:this.context.device.createShaderModule({code:"\n\t\tstruct PointInput {\n            @location(0) position: vec3<f32>,\n            @location(1) log_scale: vec3<f32>,\n            @location(2) rot: vec4<f32>,\n            @location(3) opacity_logit: f32,\n            sh: array<vec3<f32>, 16>,\n        };\n\t\tstruct Uniforms {\n            viewMatrix: mat4x4<f32>,\n            projMatrix: mat4x4<f32>,\n            camera_position: vec3<f32>,\n            tan_fovx: f32,\n            tan_fovy: f32,\n            focal_x: f32,\n            focal_y: f32,\n            scale_modifier: f32,\n        };\n\n\t\tfn CalcMatrixFromRotationScale(rot: vec4<f32>, scale: vec3<f32>) -> mat3x3<f32> {\n\t\t\tlet ms = mat3x3<f32>(\n\t\t\t\tscale.x, 0.0, 0.0,\n\t\t\t\t0.0, scale.y, 0.0,\n\t\t\t\t0.0, 0.0, scale.z\n\t\t\t);\n\n\t\t\tlet x = rot.x;\n\t\t\tlet y = rot.y;\n\t\t\tlet z = rot.z;\n\t\t\tlet w = rot.w;\n\n\t\t\tlet mr = mat3x3<f32>(\n\t\t\t\t1.0 - 2.0 * (y * y + z * z), 2.0 * (x * y - w * z), 2.0 * (x * z + w * y),\n\t\t\t\t2.0 * (x * y + w * z), 1.0 - 2.0 * (x * x + z * z), 2.0 * (y * z - w * x),\n\t\t\t\t2.0 * (x * z - w * y), 2.0 * (y * z + w * x), 1.0 - 2.0 * (x * x + y * y)\n\t\t\t);\n\n\t\t\treturn mr * ms;\n\t\t}\n\t\tfn safe_normalize_v2(v: vec2<f32>) -> vec2<f32> {\n\t\t\tlet epsilon = 1e-10;\n\t\t\tvar x = v.x;\n\t\t\tvar y = v.y;\n\t\t\tif(v.x !=0){\n\t\t\t\tx= x +epsilon;\n\t\t\t}\n\t\t\tif(v.y!=0){\n\t\t\t\ty= y +epsilon;\n\t\t\t}\n\t\t\treturn normalize( vec2f(x,y));\n\t\t}\n\n\n\t \t@group(0) @binding(0) var<storage,read_write> \tsplat_pos\t\t: array<vec4f>;\n\t\t@group(0) @binding(1) var<storage,read_write> \tsplat_axis\t: array<vec4f>; \t\t\t\t\n\t\t@group(0) @binding(2) var<storage, read> points: array<PointInput>;\n\t\t@group(0) @binding(3) var<uniform> \t\t\t\tuniforms: Uniforms;\n\n\t\t@compute\n\t\t@workgroup_size(  8, 1,1 )\n\t\tfn main(\n\t\t\t@builtin(workgroup_id) workgroup_id : vec3<u32>,\n\t\t\t@builtin(local_invocation_id) local_invocation_id : vec3<u32>,\n\t\t\t@builtin(global_invocation_id) global_invocation_id : vec3<u32>,\n\t\t\t@builtin(local_invocation_index) local_invocation_index: u32,\n\t\t\t@builtin(num_workgroups) num_workgroups: vec3<u32>) {\n\t\t\tlet workgroup_index =  \n\t\t\t\tworkgroup_id.x +\n\t\t\t\tworkgroup_id.y * num_workgroups.x +\n\t\t\t\tworkgroup_id.z * num_workgroups.x * num_workgroups.y;\n\t\t\tlet idx =\n\t\t\t\tworkgroup_index * 8 +\n\t\t\t\tlocal_invocation_index;\n                \n            if(idx >= 100){\n                return;\n            }\n\n\t\t\tvar point = points[idx] ;\t\t\t\t\n\t\t\tvar clipPos =  uniforms.projMatrix * uniforms.viewMatrix  * vec4f( point.position , 1);\n\t\t\tsplat_pos[idx] = clipPos ;\n\n\n\t\t\tlet splatRotScaleMat : mat3x3<f32> = CalcMatrixFromRotationScale(point.rot, point.log_scale);\t\t\t\n\t\t\t\n\t\t\tlet sig :  mat3x3<f32> = splatRotScaleMat * transpose(splatRotScaleMat);\n\t\t\tvar cov3d0 : vec3f = vec3f (sig[0][0] , sig[0][1] , sig[0][2]  );\n\t\t\tvar cov3d1 : vec3f = vec3f (sig[1][1] , sig[1][2] , sig[2][2]  );\n\t\t\t\n\t\t\tlet _VecScreenParams = vec4f(600,600,0,0);\n\n\t\t\t// Cov2d:\t\t\t\n\t\t\tvar viewPos:vec3f = (uniforms.viewMatrix * vec4<f32>(point.position, 1.0)).xyz;\n\t\t\tlet aspect = uniforms.projMatrix[0][0] / uniforms.projMatrix[1][1] ;  // = 1\n\n\t\t\tlet tanFovX: f32 = 1.0 / uniforms.projMatrix[0][0];\n\t\t\tlet tanFovY: f32 = 1.0 / (uniforms.projMatrix[1][1] * aspect);\n\n\t\t\tlet limx = 1.3 * tanFovX;\n\t\t\tlet limy = 1.3 * tanFovY;\n\t\t\tlet txtz = viewPos.x / viewPos.z;\n\t\t\tlet tytz = viewPos.y / viewPos.z;\n\n\t\t\tviewPos.x = min(limx, max(-limx, txtz)) * viewPos.z;\n\t\t\tviewPos.y = min(limy, max(-limy, tytz)) * viewPos.z;\n\n\t\t\tlet focal = _VecScreenParams.x * uniforms.projMatrix[0][0] / 2;\n\t\t\tlet J = mat3x3(\n\t\t\t\tfocal / viewPos.z, 0., -(focal * viewPos.x) / (viewPos.z * viewPos.z),\n\t\t\t\t0., focal / viewPos.z, -(focal * viewPos.y) / (viewPos.z * viewPos.z),\n\t\t\t\t0., 0., 0., \n\t\t\t);\n\n\t\t\tlet W = mat3x3<f32>(\n\t\t\t\tuniforms.viewMatrix[0].xyz,\n\t\t\t\tuniforms.viewMatrix[1].xyz,\n\t\t\t\tuniforms.viewMatrix[2].xyz\n\t\t\t);\n\t\t\t\n\t\t\tlet T = J * W;\n\n\t\t\tlet Vrk = mat3x3(\n\t\t\t\tcov3d0.x, cov3d0.y, cov3d0.z,\n\t\t\t\tcov3d0.y, cov3d1.x, cov3d1.y,\n\t\t\t\tcov3d0.z, cov3d1.y, cov3d1.z\t\n\t\t\t);\n\n\t\t\t//var cov2d_mat = transpose(T) * transpose(Vrk) * T;\n\t\t\tvar cov2d_mat = T * ((Vrk) * transpose(T));\n\t\t\tcov2d_mat[0][0] += 0.3;\n\t\t\tcov2d_mat[1][1] += 0.3;\n\n\t\t\tlet cov2d :vec3f  = vec3f(cov2d_mat[0][0] , -cov2d_mat[0][1] , cov2d_mat[1][1]);\n\n\t\t\tlet diag1 =  cov2d.x;\n\t\t\tlet diag2 =  cov2d.z;\n\t\t\tvar offDiag =  cov2d.y;\t\t\t\t\t\t\n\t\t\t\n\t\t\tvar mid =  0.5 *  (diag1 + diag2);\n\t\t\tvar radius = length(vec2<f32>((diag1 - diag2) /2.0  , offDiag));\n\t\t\tvar lambda1 = mid + radius;\n\t\t\tvar lambda2 = max(mid - radius , 0.1);\n\n\t\t\t\n\t\t\t//var diagVec : vec2<f32> = normalize(vec2<f32>(offDiag , lambda1 - diag1));\n\t\t\tvar diagVec : vec2<f32> = safe_normalize_v2(vec2<f32>(offDiag , lambda1 - diag1));\n\t\t\tdiagVec.y = -diagVec.y;\n\t\t\t\n\t\t\tlet maxSize :f32 = 4096.0;\n\t\t\tlet v1 : vec2<f32> = min(sqrt(2.0 * lambda1) , maxSize) * diagVec;        \n\t\t\tlet v2 : vec2<f32> = min(sqrt(2.0 * lambda2) , maxSize) * vec2<f32>(diagVec.y , -diagVec.x);\n\t\t\t\n\t\t\t//splat_pos[idx] = vec4f(diagVec,offDiag , lambda1 - diag1 );\n\t\t\t//splat_pos[idx] = vec4f(point.rot);\n\t\t\t//splat_pos[idx] = vec4f(v1 , v2);\n\t\t\t//splat_pos[idx] = vec4f(splatRotScaleMat[idx].xyz ,0);\n\t\t\t//splat_pos[idx] = vec4f( cov2d_mat[idx] , f32(idx));\n\t\t\t//splat_pos[idx] = vec4f( focal, tanFovX, tanFovY, tytz);\n\t\t\t//splat_pos[idx] = vec4f( diag1 , diag2 , offDiag,0);\n\t\t\tsplat_pos[idx] = vec4f( viewPos,0);\n\n\t\t\tsplat_axis[idx] = vec4f(v1 , v2);\n\t\t\n\t\t}\n\t"}),entryPoint:"main"}});const v={size:[e.width,e.height,1],format:o,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING},m=this.context.device.createTexture(v);this.framebuffer=m}draw(t){const e=this.context.device.createCommandEncoder(),n={colorAttachments:[{view:this.framebuffer.createView(),clearValue:{r:0,g:0,b:0,a:0},storeOp:"store",loadOp:"clear"}]},i=e.beginRenderPass(n);i.setPipeline(this.pipeline),i.setVertexBuffer(0,this.vertexBuffer),i.setBindGroup(0,this.pointBindGroup),i.setIndexBuffer(this.drawIndexBuffer,"uint32"),i.drawIndexed(6,t),i.end(),this.context.device.queue.submit([e.finish()])}}class tt{constructor(t,e,n){this.context=t,this.canvas=e,this.texture=n;const i=e.getContext("webgpu");if(!i)throw new Error("WebGPU context not found!");this.contextGpu=i;const r=new Float32Array([-1,-1,1,-1,1,1,-1,1,1,1,-1,-1]);this.vbo=this.context.device.createBuffer({label:"Cell vertices",size:r.byteLength,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST}),this.context.device.queue.writeBuffer(this.vbo,0,r);const o=this.context.device.createShaderModule({label:"Cell shader",code:`\n\t\t\t@vertex\n\t\t\tfn vertexMain(@location(0) pos: vec2f) -> @builtin(position) vec4f {\n\t\t\t\treturn vec4f(pos.x, pos.y, 0, 1);\n\t\t\t}\n\n\t\t\t@group(0) @binding(0) var myTexture: texture_2d<f32>;\n\t\t\t@group(0) @binding(1) var mySampler: sampler;\n\t\t\t@fragment\n\t\t\tfn fragmentMain(@builtin(position) fragCoord: vec4<f32>) -> @location(0) vec4f {\n\t\t\t    var uv = fragCoord.xy / vec2<f32>(${this.canvas.width}, ${this.canvas.height});\n\t\t\t\tuv.y = 1-uv.y;\t\t\t\t\n\t\t\t\tvar color:vec4f = textureSample(myTexture, mySampler, uv)  ;\n\t\t\t\t\n\t\t\t\tcolor.a = saturate(color.a * 1.5);\n\n\t\t\t\tif(color.a <0.99){\n\t\t\t\t\t//discard;\n\t\t\t\t\tcolor.a = pow(color.a , 4);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn color;\n\t\t\t}\n\t\t\t`}),a=this.context.device.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.FRAGMENT,texture:{sampleType:"float"}},{binding:1,visibility:GPUShaderStage.FRAGMENT,sampler:{type:"filtering"}}]}),s=this.context.device.createPipelineLayout({label:"Simple draw layout ",bindGroupLayouts:[a]});this.post_process_pipeline=this.context.device.createRenderPipeline({label:"post_process_pipeline",layout:s,vertex:{module:o,entryPoint:"vertexMain",buffers:[{arrayStride:8,attributes:[{format:"float32x2",offset:0,shaderLocation:0}]}]},fragment:{module:o,entryPoint:"fragmentMain",targets:[{format:"rgba16float"}]}});const u=this.context.device.createSampler({label:"mip",magFilter:"linear",minFilter:"linear"});this.bindGroup=this.context.device.createBindGroup({layout:a,entries:[{binding:0,resource:this.texture.createView()},{binding:1,resource:u}]})}draw(){const t={colorAttachments:[{view:this.contextGpu.getCurrentTexture().createView(),clearValue:{r:0,g:0,b:0,a:0},storeOp:"store",loadOp:"clear"}]},e=this.context.device.createCommandEncoder(),n=e.beginRenderPass(t);n.setPipeline(this.post_process_pipeline),n.setVertexBuffer(0,this.vbo),n.setBindGroup(0,this.bindGroup),n.draw(6,2),n.end(),this.context.device.queue.submit([e.finish()])}}var et=function(t,e,n,i){return new(n||(n=Promise))((function(r,o){function a(t){try{u(i.next(t))}catch(t){o(t)}}function s(t){try{u(i.throw(t))}catch(t){o(t)}}function u(t){var e;t.done?r(t.value):(e=t.value,e instanceof n?e:new n((function(t){t(e)}))).then(a,s)}u((i=i.apply(t,e||[])).next())}))};const nt=new l([["viewMatrix",new p(o)],["projMatrix",new p(o)],["cameraPosition",new u(o)],["tanHalfFovX",o],["tanHalfFovY",o],["focalX",o],["focalY",o],["scaleModifier",o]]);function it(t){return[[t[0],t[1],t[2],t[3]],[t[4],t[5],t[6],t[7]],[t[8],t[9],t[10],t[11]],[t[12],t[13],t[14],t[15]]]}class rt{static requestContext(t){return et(this,void 0,void 0,(function*(){const e=navigator.gpu;if(!e)return Promise.reject("WebGPU not supported on this browser! (navigator.gpu is null)");const n=yield e.requestAdapter();if(!n)return Promise.reject("WebGPU not supported on this browser! (gpu.adapter is null)");const i=t.gaussiansBuffer.byteLength,r=yield n.requestDevice({requiredLimits:{maxStorageBufferBindingSize:1.5*i,maxBufferSize:1.5*i}});return new $(e,n,r)}))}destroy(){return et(this,void 0,void 0,(function*(){return new Promise(((t,e)=>{this.destroyCallback=t}))}))}constructor(t,e,n,i,r){this.destroyCallback=null,this.canvas=t,this.interactiveCamera=e,this.context=i;const o=t.getContext("webgpu");if(!o)throw new Error("WebGPU context not found!");this.contextGpu=o,this.fpsCounter=r,this.lastDraw=performance.now(),this.numGaussians=n.numGaussians;const a="rgba16float";this.contextGpu.configure({device:this.context.device,format:a,alphaMode:"premultiplied"}),this.pointDataBuffer=this.context.device.createBuffer({size:n.gaussianArrayLayout.size,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC,mappedAtCreation:!0,label:"renderer.pointDataBuffer"}),new Uint8Array(this.pointDataBuffer.getMappedRange()).set(new Uint8Array(n.gaussiansBuffer)),this.pointDataBuffer.unmap(),this.uniformBuffer=this.context.device.createBuffer({size:nt.size,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,label:"renderer.uniformBuffer"});const s=function(t,e,n,i,r){const o={1:"\n    // spherical harmonic coefficients\n    const SH_C0 = 0.28209479177387814f;\n    const SH_C1 = 0.4886025119029199f;\n\n    fn compute_color_from_sh(position: vec3<f32>, sh: array<vec3<f32>, 4>) -> vec3<f32> {\n        let dir = normalize(position - uniforms.camera_position);\n        var result = SH_C0 * sh[0];\n\n        // if deg > 0\n        let x = dir.x;\n        let y = dir.y;\n        let z = dir.z;\n\n        result = result + SH_C1 * (-y * sh[1] + z * sh[2] - x * sh[3]);\n\n        // unconditional\n        result = result + 0.5;\n\n        return max(result, vec3<f32>(0.));\n    }\n",2:"\n    // spherical harmonic coefficients\n    const SH_C0 = 0.28209479177387814f;\n    const SH_C1 = 0.4886025119029199f;\n    const SH_C2 = array(\n        1.0925484305920792f,\n        -1.0925484305920792f,\n        0.31539156525252005f,\n        -1.0925484305920792f,\n        0.5462742152960396f\n    );\n\n    fn compute_color_from_sh(position: vec3<f32>, sh: array<vec3<f32>, 9>) -> vec3<f32> {\n        let dir = normalize(position - uniforms.camera_position);\n        var result = SH_C0 * sh[0];\n\n        // if deg > 0\n        let x = dir.x;\n        let y = dir.y;\n        let z = dir.z;\n\n        result = result + SH_C1 * (-y * sh[1] + z * sh[2] - x * sh[3]);\n\n        let xx = x * x;\n        let yy = y * y;\n        let zz = z * z;\n        let xy = x * y;\n        let xz = x * z;\n        let yz = y * z;\n\n        // if (sh_degree > 1) {\n        result = result +\n            SH_C2[0] * xy * sh[4] +\n            SH_C2[1] * yz * sh[5] +\n            SH_C2[2] * (2. * zz - xx - yy) * sh[6] +\n            SH_C2[3] * xz * sh[7] +\n            SH_C2[4] * (xx - yy) * sh[8];\n        \n        // unconditional\n        result = result + 0.5;\n\n        return max(result, vec3<f32>(0.));\n    }\n",3:"\n    // spherical harmonic coefficients\n    const SH_C0 = 0.28209479177387814f;\n    const SH_C1 = 0.4886025119029199f;\n    const SH_C2 = array(\n        1.0925484305920792f,\n        -1.0925484305920792f,\n        0.31539156525252005f,\n        -1.0925484305920792f,\n        0.5462742152960396f\n    );\n    const SH_C3 = array(\n        -0.5900435899266435f,\n        2.890611442640554f,\n        -0.4570457994644658f,\n        0.3731763325901154f,\n        -0.4570457994644658f,\n        1.445305721320277f,\n        -0.5900435899266435f\n    );\n\n    fn compute_color_from_sh(position: vec3<f32>, sh: array<vec3<f32>, 16>) -> vec3<f32> {\n        let dir = normalize(position - uniforms.camera_position);\n        var result = SH_C0 * sh[0];\n\n        // if deg > 0\n        let x = dir.x;\n        let y = dir.y;\n        let z = dir.z;\n\n        result = result + SH_C1 * (-y * sh[1] + z * sh[2] - x * sh[3]);\n\n        let xx = x * x;\n        let yy = y * y;\n        let zz = z * z;\n        let xy = x * y;\n        let xz = x * z;\n        let yz = y * z;\n\n        // if (sh_degree > 1) {\n        result = result +\n            SH_C2[0] * xy * sh[4] +\n            SH_C2[1] * yz * sh[5] +\n            SH_C2[2] * (2. * zz - xx - yy) * sh[6] +\n            SH_C2[3] * xz * sh[7] +\n            SH_C2[4] * (xx - yy) * sh[8];\n        \n        // if (sh_degree > 2) {\n        result = result +\n            SH_C3[0] * y * (3. * xx - yy) * sh[9] +\n            SH_C3[1] * xy * z * sh[10] +\n            SH_C3[2] * y * (4. * zz - xx - yy) * sh[11] +\n            SH_C3[3] * z * (2. * zz - 3. * xx - 3. * yy) * sh[12] +\n            SH_C3[4] * x * (4. * zz - xx - yy) * sh[13] +\n            SH_C3[5] * z * (xx - yy) * sh[14] +\n            SH_C3[6] * x * (xx - 3. * yy) * sh[15];\n\n        // unconditional\n        result = result + 0.5;\n\n        return max(result, vec3<f32>(0.));\n    }\n"}[e];return`\n// for some reason passing these as uniform is broken\nconst canvas_height = ${t.height};\nconst canvas_width = ${t.width};\nconst sh_degree = ${e};\nconst n_sh_coeffs = ${n};\n\nstruct PointInput {\n    @location(0) position: vec3<f32>,\n    @location(1) log_scale: vec3<f32>,\n    @location(2) rot: vec4<f32>,\n    @location(3) opacity_logit: f32,\n    sh: array<vec3<f32>, n_sh_coeffs>,\n};\n\nstruct PointOutput {\n    @builtin(position) position: vec4<f32>,\n    @location(0) color: vec3<f32>,\n    @location(1) uv: vec2<f32>,\n    @location(2) conic_and_opacity: vec4<f32>,\n};\n\nstruct Uniforms {\n    viewMatrix: mat4x4<f32>,\n    projMatrix: mat4x4<f32>,\n    camera_position: vec3<f32>,\n    tan_fovx: f32,\n    tan_fovy: f32,\n    focal_x: f32,\n    focal_y: f32,\n    scale_modifier: f32,\n};\n\n${o}\n\nfn sigmoid(x: f32) -> f32 {\n    if (x >= 0.) {\n        return 1. / (1. + exp(-x));\n    } else {\n        let z = exp(x);\n        return z / (1. + z);\n    }\n}\nfn CalcMatrixFromRotationScale(rot: vec4<f32>, scale: vec3<f32>) -> mat3x3<f32> {\n\t\t\tlet ms = mat3x3<f32>(\n\t\t\t\tscale.x, 0.0, 0.0,\n\t\t\t\t0.0, scale.y, 0.0,\n\t\t\t\t0.0, 0.0, scale.z\n\t\t\t);\n\n\t\t\tlet x = rot.x;\n\t\t\tlet y = rot.y;\n\t\t\tlet z = rot.z;\n\t\t\tlet w = rot.w;\n\n\t\t\tlet mr = mat3x3<f32>(\n\t\t\t\t1.0 - 2.0 * (y * y + z * z), 2.0 * (x * y - w * z), 2.0 * (x * z + w * y),\n\t\t\t\t2.0 * (x * y + w * z), 1.0 - 2.0 * (x * x + z * z), 2.0 * (y * z - w * x),\n\t\t\t\t2.0 * (x * z - w * y), 2.0 * (y * z + w * x), 1.0 - 2.0 * (x * x + y * y)\n\t\t\t);\n\n\t\t\treturn mr * ms;\n\t\t}\nfn compute_cov3d(log_scale: vec3<f32>, rot: vec4<f32>) -> array<f32, 6> {\n\t\tlet modifier = uniforms.scale_modifier;\n\t\t\n\t\tlet S = mat3x3<f32>(\n\t\t\t(log_scale.x) * modifier, 0., 0.,\n\t\t\t0., (log_scale.y) * modifier, 0.,\n\t\t\t0., 0., (log_scale.z) * modifier,\n\t\t);\n\t\t\n\t\tlet x = rot.x;\n\t\tlet y = rot.y;\n\t\tlet z = rot.z;\n\t\tlet w = rot.w;\n\n\t\tlet R = mat3x3<f32>(\n\t\t\t1-2*(y*y + z*z),   2*(x*y - w*z),   2*(x*z + w*y),\n          \t2*(x*y + w*z), 1-2*(x*x + z*z),   2*(y*z - w*x),\n          \t2*(x*z - w*y),   2*(y*z + w*x), 1-2*(x*x + y*y)\n\t\t);\n\n\t\tlet M =  R * S;\n\n\t\t// ------------ CalcCovariance3D ----------------\n\t\tlet Sigma = M * transpose(M) ;\t\t\n\t\treturn array<f32, 6>(\n\t\t\t/*\n\t\t\t*/\n\t\t\tSigma[0][0],\n\t\t\tSigma[0][1],\n\t\t\tSigma[0][2],\n\t\t\tSigma[1][1],\n\t\t\tSigma[1][2],\t\t\t\n\t\t\tSigma[2][2],\t\t\t\n\t\t);\n\t} \n\n\tfn compute_cov2d(position: vec3<f32>, log_scale: vec3<f32>, rot: vec4<f32>) -> vec3<f32> {\n\t\t//let cov3d = compute_cov3d(log_scale, rot);\t\t\n        let splatRotScaleMat : mat3x3<f32> = CalcMatrixFromRotationScale(rot, log_scale);\t\t\t\n\t\t\t\n\t\tlet sig :  mat3x3<f32> = splatRotScaleMat * transpose(splatRotScaleMat);\n\t\tvar cov3d0 : vec3f = vec3f (sig[0][0] , sig[0][1] , sig[0][2]  );\n\t\tvar cov3d1 : vec3f = vec3f (sig[1][1] , sig[1][2] , sig[2][2]  );\n\t\t\t\n\t\tlet _VecScreenParams = vec4f(600,600,0,0);\n\n        // Cov2d:\t\t\t\n        var viewPos:vec3f = (uniforms.viewMatrix * vec4<f32>(position, 1.0)).xyz;\n        let aspect = uniforms.projMatrix[0][0] / uniforms.projMatrix[1][1] ;  // = 1\n\n        let tanFovX: f32 = 1.0 / uniforms.projMatrix[0][0];\n        let tanFovY: f32 = 1.0 / (uniforms.projMatrix[1][1] * aspect);\n\n        let limx = 1.3 * tanFovX;\n        let limy = 1.3 * tanFovY;\n        let txtz = viewPos.x / viewPos.z;\n        let tytz = viewPos.y / viewPos.z;\n\n        viewPos.x = min(limx, max(-limx, txtz)) * viewPos.z;\n        viewPos.y = min(limy, max(-limy, tytz)) * viewPos.z;\n\n        let focal = _VecScreenParams.x * uniforms.projMatrix[0][0] / 2;\n        let J = mat3x3(\n            focal / viewPos.z, 0., -(focal * viewPos.x) / (viewPos.z * viewPos.z),\n            0., focal / viewPos.z, -(focal * viewPos.y) / (viewPos.z * viewPos.z),\n            0., 0., 0., \n        );\n\n        let W = mat3x3<f32>(\n            uniforms.viewMatrix[0].xyz,\n            uniforms.viewMatrix[1].xyz,\n            uniforms.viewMatrix[2].xyz\n        );\n        \n        let T = J * W;\n\n        let Vrk = mat3x3(\n            cov3d0.x, cov3d0.y, cov3d0.z,\n            cov3d0.y, cov3d1.x, cov3d1.y,\n            cov3d0.z, cov3d1.y, cov3d1.z\t\n        );\n\n        //var cov2d_mat = transpose(T) * transpose(Vrk) * T;\n        var cov2d_mat = T * ((Vrk) * transpose(T));\n        cov2d_mat[0][0] += 0.3;\n        cov2d_mat[1][1] += 0.3;\n\n        let cov2d :vec3f  = vec3f(cov2d_mat[0][0] , -cov2d_mat[0][1] , cov2d_mat[1][1]);\n\n\t\t//return vec3<f32>(cov[0][0], cov[0][1], cov[1][1]);\n        return cov2d;\n\t}\n\n\n@binding(0) @group(0) var<uniform> uniforms: Uniforms;\n@binding(1) @group(1) var<storage, read> points: array<PointInput>;\n@binding(2) @group(1) var<storage, read> sorted_idx: array<u32>;\n\nfn asfloat(hex: u32) -> f32 {\n    let float_value = bitcast<f32>(hex);\n    return float_value;\n}\n@vertex\nfn vs_points(\n    //@builtin(vertex_index) vertex_index: u32\n    @builtin(vertex_index) vtxID: u32,\n    @builtin(instance_index) instID: u32\n    ) -> PointOutput {\n\n    var output: PointOutput;\n    let p_idx = sorted_idx[instID];\n    let point = points[p_idx];\n    let idx = vtxID;\n\n    var clipPos = uniforms.projMatrix  * uniforms.viewMatrix *  vec4<f32>(point.position, 1.0);    \n    //var clipPos = uniforms.projMatrix  *  vec4<f32>(point.position, 1.0);    \n\n    if(clipPos.w<=0){\n        let nanfloat = asfloat(0x7fc00000);\n        output.position = vec4<f32>(nanfloat , nanfloat , nanfloat,nanfloat); // NaN discards the primitive\n    }\n    else{\n\n        var quadPos = vec2<f32>(\n            f32(idx&1), \n            f32((idx>>1)&1)\n            ) * 2.0 -1 ;\n        quadPos *=2;\n        output.uv  = quadPos;\n        output.position  = clipPos  ;\n        \n\n        // cov3d:\n        let splatRotScaleMat : mat3x3<f32> = CalcMatrixFromRotationScale(point.rot, point.log_scale);\t\t\t\n\t\t\t\n\t\tlet sig :  mat3x3<f32> = splatRotScaleMat * transpose(splatRotScaleMat);\n\t\tvar cov3d0 : vec3f = vec3f (sig[0][0] , sig[0][1] , sig[0][2]  );\n\t\tvar cov3d1 : vec3f = vec3f (sig[1][1] , sig[1][2] , sig[2][2]  );\n\t\tlet _VecScreenParams = vec4f(600,600,0,0);\n\n\t\toutput.uv *= cov3d1.yz;\n        let splatScale = 1.0;\n        let splatScale2 = splatScale * splatScale;\n\t\tcov3d0 *= splatScale2;\n\t\tcov3d1 *= splatScale2;\n\n        // Cov2d:\t\t\t\n        var viewPos:vec3f = (uniforms.viewMatrix * vec4<f32>(point.position, 1.0)).xyz;\n        let aspect = uniforms.projMatrix[0][0] / uniforms.projMatrix[1][1] ;  // = 1\n\n        let tanFovX: f32 = 1.0 / uniforms.projMatrix[0][0];\n        let tanFovY: f32 = 1.0 / (uniforms.projMatrix[1][1] * aspect);\n\n        let limx = 1.3 * tanFovX;\n        let limy = 1.3 * tanFovY;\n        let txtz = viewPos.x / viewPos.z;\n        let tytz = viewPos.y / viewPos.z;\n\n        viewPos.x = min(limx, max(-limx, txtz)) * viewPos.z;\n        viewPos.y = min(limy, max(-limy, tytz)) * viewPos.z;\n\n        let focal = _VecScreenParams.x * uniforms.projMatrix[0][0] / 2;\n        let J = mat3x3(\n            focal / viewPos.z, 0., -(focal * viewPos.x) / (viewPos.z * viewPos.z),\n            0., focal / viewPos.z, -(focal * viewPos.y) / (viewPos.z * viewPos.z),\n            0., 0., 0., \n        );\n\n        let W = mat3x3<f32>(\n            uniforms.viewMatrix[0].xyz,\n            uniforms.viewMatrix[1].xyz,\n            uniforms.viewMatrix[2].xyz\n        );\n        \n        let T = J * W;\n\n        let Vrk = mat3x3(\n            cov3d0.x, cov3d0.y, cov3d0.z,\n            cov3d0.y, cov3d1.x, cov3d1.y,\n            cov3d0.z, cov3d1.y, cov3d1.z\t\n        );\n\n        //var cov2d_mat = transpose(T) * transpose(Vrk) * T;\n        var cov2d_mat = T * ((Vrk) * transpose(T));\n        cov2d_mat[0][0] += 0.3;\n        cov2d_mat[1][1] += 0.3;\n\n        let cov2d :vec3f  = vec3f(cov2d_mat[0][0] , -cov2d_mat[0][1] , cov2d_mat[1][1]);\n        //let cov2d = compute_cov2d(point.position, point.log_scale, point.rot);\n\n        let det = cov2d.x * cov2d.z - cov2d.y * cov2d.y;\n        let det_inv = 1.0 / det;\n        let conic = vec3<f32>(cov2d.z * det_inv, -cov2d.y * det_inv, cov2d.x * det_inv);\n        output.conic_and_opacity = vec4<f32>(conic, sigmoid(point.opacity_logit));\n        \n        let diag1 =  cov2d.x;\n\t\tlet diag2 =  cov2d.z;\n\t\tlet offDiag =  cov2d.y;\t\n        var mid =  0.5 *  (diag1 + diag2);\n        var radius = length(vec2<f32>((diag1 - diag2) /2.0  , offDiag));\n        var lambda1 = mid + radius;\n        var lambda2 = max(mid - radius , 0.1);\n        var diagVec : vec2<f32> = normalize(vec2<f32>(offDiag , lambda1 - diag1));\n        diagVec.y = -diagVec.y;\n\n        let maxSize :f32 = 4096.0;\n\t\tlet v1 : vec2<f32> = min(sqrt(2.0 * lambda1) , maxSize) * diagVec;        \n\t\tlet v2 : vec2<f32> = min(sqrt(2.0 * lambda2) , maxSize) * vec2<f32>(diagVec.y , -diagVec.x);\n        \n        let _ScreenParams : vec2<f32> = vec2<f32>(${i} , ${r});       \n        \n        let deltaScreenPos :vec2<f32> = (quadPos.x * v1 + quadPos.y * v2) * 2 / _ScreenParams.xy;\n        \n        output.position  .x += deltaScreenPos.x * clipPos.w;\n        output.position  .y += deltaScreenPos.y * clipPos.w;\n        \n        output.color = compute_color_from_sh(point.position, point.sh);\n    }\n\n\n\t\n    /*\n    let cov2d = compute_cov2d(point.position, point.log_scale, point.rot);\n    let det = cov2d.x * cov2d.z - cov2d.y * cov2d.y;\n    let det_inv = 1.0 / det;\n    let conic = vec3<f32>(cov2d.z * det_inv, -cov2d.y * det_inv, cov2d.x * det_inv);\n    output.conic_and_opacity = vec4<f32>(conic, sigmoid(point.opacity_logit));\n\n    var projPosition = uniforms.projMatrix * vec4<f32>(point.position, 1.0);   \n    if(projPosition.w <=0){\n        //behind camera\n        output.uv = vec2f(-99,-99);\n        return output;\n    }\n    var mid =  0.5 * (cov2d.x + cov2d.z);\n\tvar radius = length(vec2<f32>((cov2d.x - cov2d.z) /2.0  , cov2d.y));\n\tvar lambda1 = mid + radius;\n\tvar lambda2 = max(mid - radius , 0.1);\n\tvar diagVec : vec2<f32> = normalize(vec2<f32>(cov2d.y , lambda1 - lambda2));\n\tdiagVec.y = -diagVec.y;\n\t\t\n\tlet maxSize :f32 = 4096.0;\n\tlet v1 : vec2<f32> = min(sqrt(2.0 * lambda1) , maxSize) * diagVec;\n\tlet v2 : vec2<f32> = min(sqrt(2.0 * lambda2) , maxSize) * vec2<f32>(diagVec.y , -diagVec.x);\n\n    let _ScreenParams : vec2<f32> = vec2<f32>(${i} , ${r});\n    \n    output.uv  = quadPos;\n    output.position  = projPosition;\n    let deltaScreenPos :vec2<f32> = (quadPos.x * v1 + quadPos.y * v2) * 2 / _ScreenParams.xy;\n\n\toutput.position  .x += deltaScreenPos.x * projPosition.w;\n\toutput.position  .y += deltaScreenPos.y * projPosition.w;\n\n    output.color = compute_color_from_sh(point.position, point.sh);\n    */\n\n    return output;\n}\n\n@fragment\nfn fs_main(input: PointOutput) -> @location(0) vec4<f32> {\n   \n    let selectedColor : vec3<f32> = vec3<f32> (1,0,1);\n    var opacity = input.conic_and_opacity.w;   \n    var color : vec4<f32> = vec4<f32> (input.color ,opacity);\n    let power :f32 = -dot(input.uv, input.uv);\n    var alpha :f32 = exp(power);\n    if(opacity>=0){\n        alpha = saturate(alpha * opacity );\n    }\n    /*\n    */\n    else{\n        if(alpha > 7.0/255.0){\n            if(alpha < 10.0 /255.0){\n                alpha = 1;\n                color = vec4<f32> (selectedColor , color.a);\n            }\n            alpha = saturate(alpha +0.3);\n        }\n        color = vec4<f32> ( mix(input.color.rgb , selectedColor , 0.5 ) , color.a);\n    }\n    if(alpha < 1.0/255.0){\n        discard;\n    }\n    \n    \n    return vec4<f32>(input.color * alpha, alpha);\n    //return vec4<f32>(alpha,alpha,alpha, 1);\n    //return vec4<f32>(color.rgb, 1);\n    //return color;\n}\n`}(t,n.sphericalHarmonicsDegree,n.nShCoeffs,this.canvas.width,this.canvas.height);console.log(this.interactiveCamera.getCamera());const u=this.context.device.createShaderModule({code:s}),c=this.context.device.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT,buffer:{type:"uniform"}}]}),l=this.context.device.createBindGroupLayout({label:"draw_data_bindinglayout",entries:[{binding:1,visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT,buffer:{type:"read-only-storage"}},{binding:2,visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT,buffer:{type:"read-only-storage"}}]}),f=this.context.device.createPipelineLayout({label:"draw_pipeline_layout ",bindGroupLayouts:[c,l]});this.drawPipeline=this.context.device.createRenderPipeline({layout:f,vertex:{module:u,entryPoint:"vs_points"},fragment:{module:u,entryPoint:"fs_main",targets:[{format:a,blend:{color:{srcFactor:"one-minus-dst-alpha",dstFactor:"one",operation:"add"},alpha:{srcFactor:"one-minus-dst-alpha",dstFactor:"one",operation:"add"}}}]},primitive:{topology:"triangle-list",stripIndexFormat:void 0,cullMode:void 0}}),this.sort_key_buffer=this.context.device.createBuffer({size:4*this.numGaussians,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC,mappedAtCreation:!1}),this.sort_value_buffer=this.context.device.createBuffer({size:4*this.numGaussians,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC,mappedAtCreation:!1}),this.uniformsBindGroup=this.context.device.createBindGroup({layout:c,entries:[{binding:0,resource:{buffer:this.uniformBuffer}}]}),this.pointDataBindGroup=this.context.device.createBindGroup({layout:l,entries:[{binding:1,resource:{buffer:this.pointDataBuffer}},{binding:2,resource:{buffer:this.sort_key_buffer}}]}),this.radixSortKernel=new J.RadixSortKernel({device:this.context.device,keys:this.sort_value_buffer,values:this.sort_key_buffer,count:this.numGaussians,check_order:!0,bit_count:32,workgroup_size:{x:16,y:16}}),console.log(this.radixSortKernel);const d=this.context.device.createShaderModule({code:(p=this.numGaussians,h=n.nShCoeffs,`\n        \n        const n_sh_coeffs = ${h};\n        struct PointInput {\n            @location(0) position: vec3<f32>,\n            @location(1) log_scale: vec3<f32>,\n            @location(2) rot: vec4<f32>,\n            @location(3) opacity_logit: f32,\n            sh: array<vec3<f32>, n_sh_coeffs>,\n        };\n\n        struct Uniforms {\n            viewMatrix: mat4x4<f32>,\n            projMatrix: mat4x4<f32>,\n            camera_position: vec3<f32>,\n            tan_fovx: f32,\n            tan_fovy: f32,\n            focal_x: f32,\n            focal_y: f32,\n            scale_modifier: f32,\n        };\n\n        @group(0) @binding(0) var<storage,read_write> \tgaussian_keys_unsorted\t\t: array<u32>;\n\t\t@group(0) @binding(1) var<storage,read_write> \tgaussian_values_unsorted\t: array<u32>; \n\t\t@group(0) @binding(2) var<uniform> \t\t\t\tuniforms: Uniforms;\n\t\t@group(0) @binding(3) var<storage,read_write> \tsplatPos: array<PointInput>; \t\t\n\t\t\n\t\tfn float_to_sortable_uint(f: f32) -> u32 {\n\t\t\tlet fu: u32 = bitcast<u32>(f);\n\t\t\tlet mask: u32 = bitcast<u32>(-(bitcast<i32>(fu) >> 31)) | 0x80000000u;\n\t\t\treturn fu ^ mask;\n\t\t}\n\n\t\t@compute\n\t\t@workgroup_size(  8, 1,1 )\n\t\tfn main(\t\t\t\n\t\t\t@builtin(workgroup_id) workgroup_id : vec3<u32>,\n\t\t\t@builtin(local_invocation_id) local_invocation_id : vec3<u32>,\n\t\t\t@builtin(global_invocation_id) global_invocation_id : vec3<u32>,\n\t\t\t@builtin(local_invocation_index) local_invocation_index: u32,\n\t\t\t@builtin(num_workgroups) num_workgroups: vec3<u32>) {\n\n\t\t\tlet workgroup_index =  \n\t\t\t\tworkgroup_id.x +\n\t\t\t\tworkgroup_id.y * num_workgroups.x +\n\t\t\t\tworkgroup_id.z * num_workgroups.x * num_workgroups.y;\n            /*\n            */\n\t\t\tlet idx =\n\t\t\t\tworkgroup_index * 8 +\n\t\t\t\tlocal_invocation_index;\n                \n            if(idx >= ${p}){\n                    return;\n            }\n            \n\n\t\t\tgaussian_keys_unsorted[idx] = idx;\n\t\t\tlet pos : vec3<f32> = (uniforms.viewMatrix * vec4<f32> (splatPos[idx].position.xyz , 1.0)).xyz;\n\t\t\tgaussian_values_unsorted[idx] = float_to_sortable_uint(pos.z);\n\t\t\t//gaussian_values_unsorted[idx] =pos.z;\n\t\t\t//gaussian_values_unsorted[idx] =idx;\n\t\t\t\n\t\t\t\n\t\t}\n    `)});var p,h;const _=this.context.device.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}},{binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},{binding:3,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}}]});this.initSortBindGroup=this.context.device.createBindGroup({layout:_,label:"initSortBindGroup",entries:[{binding:0,resource:{buffer:this.sort_key_buffer}},{binding:1,resource:{buffer:this.sort_value_buffer}},{binding:2,resource:{buffer:this.uniformBuffer}},{binding:3,resource:{buffer:this.pointDataBuffer}}]});const v=this.context.device.createPipelineLayout({bindGroupLayouts:[_]});this.init_sort_pipeline=this.context.device.createComputePipeline({layout:v,compute:{module:d,entryPoint:"main"}});const m=new Uint32Array([0,1,2,1,3,2]);this.drawIndexBuffer=this.context.device.createBuffer({size:m.byteLength,usage:GPUBufferUsage.INDEX|GPUBufferUsage.COPY_DST,mappedAtCreation:!0}),new Uint32Array(this.drawIndexBuffer.getMappedRange()).set(m),this.drawIndexBuffer.unmap(),this.simple_render=new Q(i,t,this.pointDataBuffer,this.uniformBuffer,this.sort_key_buffer),this.post_renderer=new tt(i,t,this.simple_render.framebuffer),requestAnimationFrame((()=>this.animate(!0)))}destroyImpl(){if(null===this.destroyCallback)throw new Error("destroyImpl called without destroyCallback set!");this.uniformBuffer.destroy(),this.pointDataBuffer.destroy(),this.drawIndexBuffer.destroy(),this.context.destroy(),this.destroyCallback()}resize(){this.simple_render=new Q(this.context,this.canvas,this.pointDataBuffer,this.uniformBuffer,this.sort_key_buffer),this.post_renderer=new tt(this.context,this.canvas,this.simple_render.framebuffer)}draw(t){const e=this.context.device.createCommandEncoder(),n=e.beginComputePass();n.setPipeline(this.init_sort_pipeline),n.setBindGroup(0,this.initSortBindGroup),n.dispatchWorkgroups(Math.max(this.numGaussians/8,8),1,1),n.end(),this.context.device.queue.submit([e.finish()]);const i=this.context.device.createCommandEncoder(),r=i.beginComputePass();this.radixSortKernel.dispatch(r),r.end(),this.context.device.queue.submit([i.finish()]),this.simple_render.draw(this.numGaussians),this.post_renderer.draw();const o=performance.now(),a=1e3/(o-this.lastDraw);this.lastDraw=o,this.fpsCounter.innerText="FPS: "+a.toFixed(2),this.fpsCounter.style.display="block",requestAnimationFrame(t)}animate(t){if(null!==this.destroyCallback)return void this.destroyImpl();if(!this.interactiveCamera.isDirty()&&!t)return void requestAnimationFrame((()=>this.animate()));const e=this.interactiveCamera.getCamera(),n=e.getPosition(),i=.5*this.canvas.width/e.focalX,r=.5*this.canvas.height/e.focalY;this.depthSortMatrix=it(e.viewMatrix),console.log(e);let o=new ArrayBuffer(this.uniformBuffer.size),a=it(e.viewMatrix),s=it(e.perspective);console.log(e.perspective);let u={viewMatrix:a,projMatrix:s,cameraPosition:Array.from(n),tanHalfFovX:i,tanHalfFovY:r,focalX:e.focalX,focalY:e.focalY,scaleModifier:e.scaleModifier};nt.pack(0,u,new DataView(o)),this.context.device.queue.writeBuffer(this.uniformBuffer,0,o,0,o.byteLength),this.draw((()=>this.animate()))}}var ot=function(t,e,n,i){return new(n||(n=Promise))((function(r,o){function a(t){try{u(i.next(t))}catch(t){o(t)}}function s(t){try{u(i.throw(t))}catch(t){o(t)}}function u(t){var e;t.done?r(t.value):(e=t.value,e instanceof n?e:new n((function(t){t(e)}))).then(a,s)}u((i=i.apply(t,e||[])).next())}))};navigator.gpu||alert("WebGPU not supported on this browser! (navigator.gpu is null)");const at=document.getElementById("canvas-webgpu"),st=document.getElementById("loading-popup"),ut=document.getElementById("fps-counter"),ct=document.getElementById("cameraButton"),lt=document.getElementById("cameraList"),ft=document.getElementById("plyButton");at.width=window.innerWidth,at.height=window.innerHeight;let dt=j.default(at);var pt;!function(){ot(this,void 0,void 0,(function*(){console.log(window.location.href);const t=new URL(window.location.href),e=new URLSearchParams(t.search);var n="ply.ply";e.has("model")&&(n=e.get("model")+".ply"),st.style.display="block";const i=yield fetch(n),r=yield i.arrayBuffer(),o=new h(r),a=yield rt.requestContext(o),s=new rt(at,dt,o,a,ut);pt=s,st.style.display="none"}))}(),ft.addEventListener("change",(function(t){const e=t.target.files[0];e&&(st.style.display="block",function(t){return new Promise(((e,n)=>{const i=new FileReader;i.onload=t=>{t.target&&t.target.result?"string"!=typeof t.target.result?e(t.target.result):n("Got a text file instead of a binary one"):n("Failed to load file")},i.onerror=t=>{t.target?n(t.target.error):n("Failed to load file")},i.readAsArrayBuffer(t)}))}(e).then((function(t){return ot(this,void 0,void 0,(function*(){pt&&(yield pt.destroy());const e=new h(t);try{const t=yield rt.requestContext(e),n=new rt(at,dt,e,t,ut);pt=n,st.style.display="none"}catch(t){st.style.display="none",alert(t)}}))})))}));const ht=new class{constructor(t,e,n,i){this.currentLineId=0,this.handleFileInputChange=t=>{var e;const n=null===(e=this.fileInput.files)||void 0===e?void 0:e[0];if(n){const t=new FileReader;t.onload=this.handleFileLoad,t.readAsText(n)}},this.handleFileLoad=t=>{if(!t.target)return;const e=t.target.result,n=JSON.parse(e);this.currentLineId=0,this.listElement.innerHTML="",this.handleJsonData(n)},this.createCallbackForLine=t=>()=>{this.cameraSetCallback(t)},this.fileInput=t,this.listElement=e,this.canvas=n,this.cameraSetCallback=i,this.fileInput.addEventListener("change",this.handleFileInputChange)}handleJsonData(t){t.forEach((t=>{this.currentLineId++;const e=document.createElement("li"),n=function(t,e,n){const i=function(t,e,n,i){const r=Math.tan(i/2)*t,o=-r,a=Math.tan(n/2)*t,s=-a,u=q.create();return u[0]=.4/(a-s),u[5]=.4/(r-o),u[8]=(a+s)/(a-s),u[9]=(r+o)/(r-o),u[10]=100/99.8,u[11]=-20/99.8,u[14]=1,u[15]=0,q.transpose(u)}(.2,0,Z(t.fx,e),Z(t.fy,n)),r=function(t,e){const n=t,i=q.fromMat3(n),r=C.mulScalar(e,-1);return q.translate(i,r,i),i}(y(...t.rotation.flat()),t.position);return new X(n,e,r,i,n,e,1)}(t,this.canvas.width,this.canvas.height);e.textContent=t.img_name,e.addEventListener("click",this.createCallbackForLine(n)),this.listElement.appendChild(e)}))}}(ct,lt,at,(t=>dt.setNewCamera(t)));!function(){ot(this,void 0,void 0,(function*(){const t=yield fetch("cam.json");if(t.ok){const e=yield t.json();console.log(e),ht.handleJsonData(e)}}))}(),window.addEventListener("resize",(function(){at.width=window.innerWidth,at.height=window.innerHeight,pt.resize()}))})()})();
//# sourceMappingURL=main.js.map